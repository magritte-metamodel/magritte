THERE_BE_DRAGONS_HERE
Warning
21 July 2020 5:00:48.810069 pm

VM: Mac OS - x64 - 1015.5 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.536.sha.d59067fc469a97960a339dcc45d9ed85f6d85791 (64 Bit)]

MCPackageLoader(Object)>>notify:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		aString: 	'This package depends on the following classes:
  PluggableTextFieldMo...etc..
	Receiver's instance variables: 
		requirements: 	#(#PluggableTextFieldMorph)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(PluggableTextFie...etc...
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCOrganizationDefinition(#('PharoEnhancements...etc...
		removals: 	an OrderedCollection(a MCOrganizationDefinition(#(#PharoEnhancements)...etc...
		errorDefinitions: 	nil
		provisions: 	a Set(#RBRemoveMethodTransformationTest #WindowCollapsed #MalReduce...etc...
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>warnAboutDependencies
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		requirements: 	#(#PluggableTextFieldMorph)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(PluggableTextFie...etc...
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCOrganizationDefinition(#('PharoEnhancements...etc...
		removals: 	an OrderedCollection(a MCOrganizationDefinition(#(#PharoEnhancements)...etc...
		errorDefinitions: 	nil
		provisions: 	a Set(#RBRemoveMethodTransformationTest #WindowCollapsed #MalReduce...etc...
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>validate
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		requirements: 	#(#PluggableTextFieldMorph)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(PluggableTextFie...etc...
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCOrganizationDefinition(#('PharoEnhancements...etc...
		removals: 	an OrderedCollection(a MCOrganizationDefinition(#(#PharoEnhancements)...etc...
		errorDefinitions: 	nil
		provisions: 	a Set(#RBRemoveMethodTransformationTest #WindowCollapsed #MalReduce...etc...
		methodAdditions: 	an OrderedCollection()


MCPackageLoader>>loadWithNameLike:
	Receiver: a MCPackageLoader
	Arguments and temporary variables: 
		baseName: 	'PharoEnhancements-CompatibleUserName.1580613142
	Receiver's instance variables: 
		requirements: 	#(#PluggableTextFieldMorph)
		unloadableDefinitions: 	a SortedCollection(a MCMethodDefinition(PluggableTextFie...etc...
		obsoletions: 	a Dictionary()
		additions: 	an OrderedCollection(a MCOrganizationDefinition(#('PharoEnhancements...etc...
		removals: 	an OrderedCollection(a MCOrganizationDefinition(#(#PharoEnhancements)...etc...
		errorDefinitions: 	nil
		provisions: 	a Set(#RBRemoveMethodTransformationTest #WindowCollapsed #MalReduce...etc...
		methodAdditions: 	an OrderedCollection()


MCVersionLoader>>basicLoadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements-CompatibleUserName.1580613142'
		loader: 	a MCPackageLoade
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements-CompatibleUserName.1580613142
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements-CompatibleUserName.1580613142'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	ni
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ returnValue := aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			self announceLoadStop: aString ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceL...etc...
		startpc: 	a CompiledBlock: [ returnValue := aBlock value ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements-CompatibleUserName.1580613142'
		aBlock: 	[ self basicLoadWithNameLike: aString ]
		returnValue: 	ni
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self announceLoadStart: aString ]
	Arguments and temporary variables: 
		aBlock: 	[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadSto...etc...
		complete: 	true
		returnValue: 	a MCVersionLoade
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>announceLoad:do:
		startpc: 	a CompiledBlock: [ self announceLoadStart: aString ]
		numArgs: 	0
		receiver: 	a MCVersionLoader


MCVersionLoader>>announceLoad:do:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		returnValue: 	nil
		aString: 	'PharoEnhancements-CompatibleUserName.1580613142'
		aBlock: 	[ self basicLoadWithNameLike: aString 
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


MCVersionLoader>>loadWithNameLike:
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements-CompatibleUserName.1580613142
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(PharoEnhancements-CompatibleUserName.1...etc..
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self ensurePackage: version package.
		  self loadWithNameLike: version info name ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	[   
		| version |
		version := versions first. 
		[ self ensureP...etc...
		startpc: 	a CompiledBlock: [ self ensurePackage: version package.
		  self loadW...etc...
		numArgs: 	0
		receiver: 	a MCVersionLoader


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: versio...etc...
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading PharoEnhancements-CompatibleUserName.1580613142'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Jo
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Jo
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: versio...etc...
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading PharoEnhancements-CompatibleUserName.1580613142'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob value: self d...etc...
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ self ensurePackage: version package.
		  self loadWithNameLike: versio...etc...
		currentValue: 	0
		min: 	0
		max: 	100
		title: 	'Loading PharoEnhancements-CompatibleUserName.1580613142'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil


[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 
		version: 	a MCVersion(an IceMCVersionInfo(PharoEnhancements-CompatibleUserName.1...etc..
	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
...etc...
	Arguments and temporary variables: 
		aBlock: 	[ 
		self cacheActive: oldActive.
		self isCacheActive ifFalse: [ self ...etc...
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	MCVersionLoader>>load
		startpc: 	a CompiledBlock: [   
		| version |
		version := versions first. 
		[ ...etc...
		numArgs: 	0
		receiver: 	a MCVersionLoader


RPackageSet class>>withCacheDo:
	Receiver: RPackageSet
	Arguments and temporary variables: 
		aBlock: 	[   
		| version |
		version := versions first. 
		[ self ensurePackage...etc...
		oldActive: 	fals
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#asRPackageSet->RPackageSet>>#asRPackageSet #cat...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{MetacelloTestsPackageSet}
		name: 	#RPackageSet
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'RPackage-Core-Base'
		cacheActive: 	true
		cachePackages: 	an IdentityDictionary(#PharoEnhancements->a RPackageSet )


MCVersionLoader>>load
	Receiver: a MCVersionLoader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		versions: 	an OrderedCollection(a MCVersion(an IceMCVersionInfo(PharoEnhancement...etc...


MetacelloGoferLoad(GoferLoad)>>execute
	Receiver: a MetacelloGoferLoad
	Arguments and temporary variables: 

	Receiver's instance variables: 
		gofer: 	a MetacelloGofer
		model: 	a MCVersionLoader


[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : PharoEnhancements-CompatibleUserName.1580613142
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: 'PharoEnhancements'
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoa...etc...
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'PharoEnhance...etc...
		goferLoad: 	a MetacelloGoferLoa
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
	Receiver: a MetacelloLoadingMCSpecLoader
	Arguments and temporary variables: 
		aPackageLoadDirective: 	load : PharoEnhancements-CompatibleUserName.1580613142
		aGofer: 	a MetacelloGofer
		packageSpec: 	spec name: 'PharoEnhancements'
		goferLoad: 	a MetacelloGoferLoad
		loadBlock: 	[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoa...etc...
		answers: 	#()
		resolvedReference: 	a MetacelloCachingGoferResolvedReference name: 'PharoEnhance...etc..
	Receiver's instance variables: 
		spec: 	a MetacelloMCVersionSpecLoader
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | loadBlock goferLoad answers resolvedReference |

			aGofer disableP...etc...
		aString: 	'Loading PharoEnhancements'
		bar: 	a Jo
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displ...etc...
		startpc: 	a CompiledBlock: [:bar |
            bar value: 1.
            aBlock ...etc...
		numArgs: 	1
		receiver: 	an IceMetacelloPharoPlatform


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
            ...etc...
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading PharoEnhancements'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Jo
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	a Jo
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
            ...etc...
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading PharoEnhancements'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	a CompiledBlock: [ self prepareForRunning.
	  CurrentJob value: self d...etc...
		numArgs: 	0
		receiver: 	a Job


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[:bar |
            bar value: 1.
            aBlock value.
            ...etc...
		currentValue: 	1
		min: 	0
		max: 	2
		title: 	'Loading PharoEnhancements'
		children: 	an OrderedCollection(a Job)
		isRunning: 	true
		parent: 	a Job
		process: 	a Process in nil



--- The full stack ---
MCPackageLoader(Object)>>notify:
MCPackageLoader>>warnAboutDependencies
MCPackageLoader>>validate
MCPackageLoader>>loadWithNameLike:
MCVersionLoader>>basicLoadWithNameLike:
[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
MCVersionLoader>>announceLoad:do:
MCVersionLoader>>loadWithNameLike:
[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
MetacelloGoferLoad(GoferLoad)>>execute
[ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			] in [ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[ | loadBlock goferLoad answers resolvedReference |

			aGofer disablePackageCache.	"for good luck:)"
			resolvedReference := self resolvePackageSpec: packageSpec gofer: aGofer.
			resolvedReference ifNil: [ "Package version already loaded into image" ^ self ].
			loadBlock := [ "mcLoader preLoad: packageSpec."
			goferLoad := MetacelloGoferLoad on: aGofer.
			goferLoad addResolved: resolvedReference.
			goferLoad execute.
			MetacelloPlatform current clearCurrentVersionCache	"mcLoader postLoad: packageSpec"
			].
			( answers := packageSpec answers ) notEmpty
				ifTrue: [ loadBlock valueSupplyingMetacelloAnswers: answers ]
				ifFalse: [ loadBlock value ].
			resolvedReference workingCopy repositoryGroup addRepository: aPackageLoadDirective repository.
			MetacelloNotification signal:
					'Loaded -> ' , resolvedReference name , ' --- '
						, aPackageLoadDirective repository repositoryDescription , ' --- '
						, resolvedReference repository description
			] in MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
MetacelloLoadingMCSpecLoader(MetacelloCommonMCSpecLoader)>>loadPackageDirective:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadPackageDirective:gofer:
MetacelloPackageLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
[:directive | directive loadUsing: aLoaderDirective gofer: aGofer ] in MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
OrderedCollection>>do:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadLinearLoadDirective:gofer:
MetacelloLinearLoadDirective>>loadUsing:gofer:
MetacelloLinearLoadDirective(MetacelloVersionLoadDirective)>>loadWithPolicy:
MetacelloLoaderPolicy>>load
MetacelloFetchingMCSpecLoader>>doLoad
[  fetchLoader doLoad ] in [	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
[:bar |
            bar value: 1.
            aBlock value.
            bar value: 2 ] in IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
IceMetacelloPharoPlatform(MetacelloPharoCommonPlatform)>>do:displaying:
[	| fetchLoader |
		fetchLoader := self fetchRequiredFromArray: (self defaultPackageNamesToLoad: anArray).
		MetacelloPlatform current
			do:  [  fetchLoader doLoad ]
			displaying: 'Loading ', displayString.
		MetacelloNotification signal: ('...finished ', self versionNumber printString).
		^fetchLoader ] in MetacelloMCVersion>>doLoadRequiredFromArray:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloMCVersion>>doLoadRequiredFromArray:
MetacelloMCVersion>>load
[ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] in [ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ] in [ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
[ 
  [ 
  [ 
  actionBlock
    on:
      MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
        , MetacelloProjectSpecLoadedNotification
        , MetacelloScriptEnsureProjectLoadedForDevelopment
        , MetacelloLookupBaselineSpecForEnsureLoad
    do: [ :ex | 
      "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications"
      ex handleResolutionFor: self ] ]
    on:
      MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
        , MetacelloAllowConflictingProjectUpgrade
    do: [ :ex | 
      "option handlers need to be outermost set of handlers ... last line of defense before users are involved"
      ex handleResolutionFor: self ] ]
    on: MetacelloAllowLockedProjectChange
    do: [ :ex | 
      "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers"
      ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
FullBlockClosure(BlockClosure)>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ 
      self
        handleNotificationsForAction: [ 
          | version loadedSpec |
          self setDefaultsAndValidateProjectSpec.
          [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
            on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
            do: [ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
          version := loadedSpec versionForScriptEngine: self.
          self
            root:
              (required isEmpty
                ifTrue: [ version load ]
                ifFalse: [ version load: required ]) loadDirective.
          loadedSpec loads: required.
          MetacelloProjectRegistration
            registrationForProjectSpec: loadedSpec
            ifAbsent: [ :new | 
              new
                loadedInImage: true;
                registerProject ]
            ifPresent: [ :existing :new | 
              existing
                copyOnWrite: [ :existingCopy | 
                  existingCopy
                    loadedInImage: true;
                    merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
FullBlockClosure(BlockClosure)>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
      | engine |
      engine := MetacelloScriptEngine new
        options: self options copy;
        projectSpec: projectSpec;
        yourself.
      engine perform: actionArg key withArguments: actionArg value.
      engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
      projectSpec
        ifNotNil: [ projectSpecBlock value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ 
		super execute: statements ] in MetacelloScriptApiExecutor>>execute:
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
IceMetacelloLoadSessionContext(DynamicVariable)>>value:during:
IceMetacelloLoadSessionContext class(DynamicVariable class)>>value:during:
IceMetacelloPharoPlatform>>withMetacelloLoadSessionDo:
MetacelloScriptApiExecutor>>execute:
Metacello>>execute:args:
Metacello>>load:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>basicInstallBaseline:groups:
[ self basicInstallBaseline: icePackage groups: anArray ] in [ 
			Iceberg announcer 
				suspendAllForRepository: self repositoryModel entity
				while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
FullBlockClosure(BlockClosure)>>ensure:
IceAnnouncer>>suspendAllMatching:while:
IceAnnouncer>>suspendAllForRepository:while:
[ 
			Iceberg announcer 
				suspendAllForRepository: self repositoryModel entity
				while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ 
		self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
FullBlockClosure(BlockClosure)>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:
IceTipMetacelloInstallBaselineDefaultCommand>>execute
IceTipRepositoryListContext(CmdToolContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: 
			(anEvent transformedBy: (focusHolder transformedFrom: self)).
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[:h |
		self activeHand: h.
		h processEvents.
		self activeHand: nil.
	] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
'Morphic UI Process' in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of GRAnsiBooleansRule class did not understand #enabledSettingID
25 August 2020 5:22:00.931141 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.536.sha.d59067fc469a97960a339dcc45d9ed85f6d85791 (64 Bit)]

GRAnsiBooleansRule class(Object)>>doesNotUnderstand: #enabledSettingID
	Receiver: GRAnsiBooleansRule
	Arguments and temporary variables: 
		aMessage: 	enabledSettingID
		exception: 	MessageNotUnderstood: GRAnsiBooleansRule class>> #enabledSettingID
		resumeValue: 	ni
	Receiver's instance variables: 
		superclass: 	GRSlimeTransformationRule
		methodDict: 	a MethodDictionary(#group->GRAnsiBooleansRule>>#group #initialize->...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GRAnsiBooleansRule
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Grease-Pharo40-Slime'


[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] in [ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilder
		rule: 	GRAnsiBooleansRule
		inst: 	a GRAnsiBooleansRule name: 'Booleans
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(FloatReferencesRule GRAnsiBooleansRule GRAnsiCharactersRule GRAnsiCol...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting:...etc...
		index: 	
	Receiver's instance variables: 
		array: 	{FloatReferencesRule. GRAnsiBooleansRule. GRAnsiCharactersRule. GRAnsiCo...etc...
		firstIndex: 	1
		lastIndex: 	175


[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


SettingTreeBuilder>>parent:while:
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 
		aNode: 	a SettingNodeBuilder
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc...
		oldParent: 	ni
	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


SettingNodeBuilder>>asParentWhile:
	Receiver: a SettingNodeBuilder
	Arguments and temporary variables: 
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc..
	Receiver's instance variables: 
		node: 	Node(a PragmaSetting)
		builder: 	a SettingTreeBuilder


SettingNodeBuilder>>with:
	Receiver: a SettingNodeBuilder
	Arguments and temporary variables: 
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc..
	Receiver's instance variables: 
		node: 	Node(a PragmaSetting)
		builder: 	a SettingTreeBuilder


ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


SettingTreeBuilder>>systemsettings
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


SettingTreeBuilder>>buildPragma:
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 
		aPragma: 	<systemsettings
	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


[:p | builder buildPragma: p] in SettingTree>>nodeList
	Receiver: a SettingTree
	Arguments and temporary variables: 
		builder: 	a SettingTreeBuilder
		p: 	<systemsettings
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(<systemsettings> <systemsettings> <systemsettings> <systemsettings> <...etc...
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p]
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(<systemsettings> <systemsettings> <systemsettings> <systemsetti...etc...
		firstIndex: 	1
		lastIndex: 	104


PragmaCollector>>do:
	Receiver: a PragmaCollector
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		collected: 	an OrderedCollection(<systemsettings> <systemsettings> <systemsettin...etc...
		filter: 	[:prg | prg methodClass isMeta and: [keywords includes: prg selector]]
		announcing: 	true


SettingTree>>pragmasDo:
	Receiver: a SettingTree
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SettingTree>>nodeList
	Receiver: a SettingTree
	Arguments and temporary variables: 
		builder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SystemSettingsPersistence>>updateSettingNodes
	Receiver: a SystemSettingsPersistence
	Arguments and temporary variables: 

	Receiver's instance variables: 
		fileReference: 	File @ /Users/norbert/Library/Preferences/pharo/9.0/system-setti...etc...
		settingTree: 	a SettingTree


SystemSettingsPersistence class>>updateSettingNodes
	Receiver: SystemSettingsPersistence
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allStoredSettings->SystemSettingsPersistence>>#...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SystemSettingsPersistence
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Settings-Core-Persistence-Ston-Core'
		lastSettingsComputerID: 	'2795650d-8468-0d00-b6f5-4bf30044e941'


SystemSettingsPersistence class>>resumeSystemSettings
	Receiver: SystemSettingsPersistence
	Arguments and temporary variables: 
		thisComputerID: 	'2795650d-8468-0d00-b6f5-4bf30044e941
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allStoredSettings->SystemSettingsPersistence>>#...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SystemSettingsPersistence
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Settings-Core-Persistence-Ston-Core'
		lastSettingsComputerID: 	'2795650d-8468-0d00-b6f5-4bf30044e941'


[:persistence | 
		persistence resumeSystemSettings] in PharoCommandLineHandler>>runPreferences
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 
		persistence: 	SystemSettingsPersistenc
	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:persistence | 
		persistence resumeSystemSettings]
	Arguments and temporary variables: 
		anArg: 	SystemSettingsPersistenc
	Receiver's instance variables: 
		outerContext: 	PharoCommandLineHandler>>runPreferences
		startpc: 	a CompiledBlock: [:persistence | 
		persistence resumeSystemSettings]
		numArgs: 	1
		receiver: 	a PharoCommandLineHandler


SystemDictionary(Dictionary)>>at:ifPresent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#SystemSettingsPersistence
		aBlock: 	[:persistence | 
		persistence resumeSystemSettings]
		assoc: 	#SystemSettingsPersistence->SystemSettingsPersistenc
	Receiver's instance variables: 
		tally: 	9755
		array: 	an Array(#TSequencedConcatenationTest->TSequencedConcatenationTest #RBRe...etc...
		cachedClassNames: 	an OrderedCollection(#AColorSelectorMorph #ASTCache #ASTCache...etc...
		cachedNonClassNames: 	an OrderedCollection(#ActiveWorld #Display #Processor #Sen...etc...
		cachedBehaviors: 	an OrderedCollection(AColorSelectorMorph AColorSelectorMorph c...etc...


SmalltalkImage>>at:ifPresent:
	Receiver: Smalltalk
	Arguments and temporary variables: 
		key: 	#SystemSettingsPersistence
		aBlock: 	[:persistence | 
		persistence resumeSystemSettings
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		vm: 	a VirtualMachine


PharoCommandLineHandler>>runPreferences
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler>>activate
	Receiver: a PharoCommandLineHandler
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commandLine: 	a CommandLineArguments
		session: 	a WorkingSession
		stdout: 	a VTermOutputDriver
		stderr: 	a VTermOutputDriver


PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArgument
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary(#ForcePreferencesOmission->false )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler-Base'


[ 
		super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
	Receiver: PharoCommandLineHandler
	Arguments and temporary variables: 
		aCommandLine: 	a CommandLineArgument
	Receiver's instance variables: 
		superclass: 	BasicCommandLineHandler
		methodDict: 	a MethodDictionary(#activate->PharoCommandLineHandler>>#activate #c...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoCommandLineHandler
		classPool: 	a Dictionary(#ForcePreferencesOmission->false )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-CommandLineHandler-Base'


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(838144) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[ 
		super activateWith: aCommandLine 
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(498002432))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(140400896) named: Pl...etc...
		lastStepTime: 	335531
		lastStepMessage: 	nil
		lastCycleTime: 	335554
		alarms: 	a Heap()
		lastAlarmTime: 	335531
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(498002432)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	a VMWorldRenderer
		realWindowExtent: 	(1672@1201)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(838144) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1672@1201)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(420006144) a TaskbarMorph(170835200) a Syste...etc...
		fullBounds: 	(0@0) corner: (1672@1201)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (1043820288) [other:  (dragEnabled -> true) (dropEn...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(838144) [world
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(498002432))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(140400896) named: Pl...etc...
		lastStepTime: 	335531
		lastStepMessage: 	nil
		lastCycleTime: 	335554
		alarms: 	a Heap()
		lastAlarmTime: 	335531
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(498002432)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	a VMWorldRenderer
		realWindowExtent: 	(1672@1201)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(838144) [world
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(498002432))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(140400896) named: Pl...etc...
		lastStepTime: 	335531
		lastStepMessage: 	nil
		lastCycleTime: 	335554
		alarms: 	a Heap()
		lastAlarmTime: 	335531
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(498002432)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	a VMWorldRenderer
		realWindowExtent: 	(1672@1201)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(838144) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1672@1201)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(420006144) a TaskbarMorph(170835200) a Syste...etc...
		fullBounds: 	(0@0) corner: (1672@1201)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (1043820288) [other:  (dragEnabled -> true) (dropEn...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(83...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 

	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		arg1: 	spawnNewProcess
	UIProcess := [ MorphicRenderLoop new doOneCycleWhile: [ ...etc..
	Receiver's instance variables: 
a MorphicRenderLoop

'Morphic UI Process' in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
	Receiver: 'Morphic UI Process'
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	109
		numArgs: 	0



--- The full stack ---
GRAnsiBooleansRule class(Object)>>doesNotUnderstand: #enabledSettingID
[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] in [ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
OrderedCollection>>do:
[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
SettingTreeBuilder>>parent:while:
SettingNodeBuilder>>asParentWhile:
SettingNodeBuilder>>with:
ReRuleManager class>>ruleToggleSettingsOn:
SettingTreeBuilder>>systemsettings
SettingTreeBuilder>>buildPragma:
[:p | builder buildPragma: p] in SettingTree>>nodeList
OrderedCollection>>do:
PragmaCollector>>do:
SettingTree>>pragmasDo:
SettingTree>>nodeList
SystemSettingsPersistence>>updateSettingNodes
SystemSettingsPersistence class>>updateSettingNodes
SystemSettingsPersistence class>>resumeSystemSettings
[:persistence | 
		persistence resumeSystemSettings] in PharoCommandLineHandler>>runPreferences
FullBlockClosure(BlockClosure)>>cull:
SystemDictionary(Dictionary)>>at:ifPresent:
SmalltalkImage>>at:ifPresent:
PharoCommandLineHandler>>runPreferences
PharoCommandLineHandler>>activate
PharoCommandLineHandler class(CommandLineHandler class)>>activateWith:
[ 
		super activateWith: aCommandLine ] in PharoCommandLineHandler class>>activateWith:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
'Morphic UI Process' in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateActive ] asContext in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: not supported
25 August 2020 5:22:51.558759 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.536.sha.d59067fc469a97960a339dcc45d9ed85f6d85791 (64 Bit)]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'not supported
	Receiver's instance variables: 
		encoder: 	an EncoderForSistaV1
		seqOrder: 	an IdentityDictionary(an Object->1 1->2 )
		orderSeq: 	an OrderedCollection(an Object 1)
		seqBytes: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordered...etc...
		jumps: 	an IdentityDictionary(an Object->nil 1->nil )
		literals: 	an OCLiteralList()
		lastLiteral: 	nil
		currentSeqId: 	1
		currentSeqNum: 	2
		bytes: 	an OrderedCollection(76 64)
		lastSpecialReturn: 	nil
		primitiveBytes: 	nil
		instrMaps: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordere...etc...
		instrMap: 	an OrderedCollection(pushReceiver->1 pushTemp: #aMessage->2 send: #do...etc...
		stacks: 	an IdentityDictionary(an Object->an IRStackCount start 0 stop 0 max 0 1...etc...
		stack: 	an IRStackCount start 0 stop 2 max 2
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	1
		additionalLiterals: 	an OCLiteralSet()
		forceLongForm: 	false
		primNumber: 	0
		encoderClass: 	EncoderForSistaV1
		inBlock: 	true
		compilationContext: 	a CompilationContext


IRBytecodeGenerator>>send:toSuperOf:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		selector: 	#doesNotUnderstand:
		behavior: 	TMagritteBootstrap
		index: 	nil
		nArgs: 	ni
	Receiver's instance variables: 
		encoder: 	an EncoderForSistaV1
		seqOrder: 	an IdentityDictionary(an Object->1 1->2 )
		orderSeq: 	an OrderedCollection(an Object 1)
		seqBytes: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordered...etc...
		jumps: 	an IdentityDictionary(an Object->nil 1->nil )
		literals: 	an OCLiteralList()
		lastLiteral: 	nil
		currentSeqId: 	1
		currentSeqNum: 	2
		bytes: 	an OrderedCollection(76 64)
		lastSpecialReturn: 	nil
		primitiveBytes: 	nil
		instrMaps: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordere...etc...
		instrMap: 	an OrderedCollection(pushReceiver->1 pushTemp: #aMessage->2 send: #do...etc...
		stacks: 	an IdentityDictionary(an Object->an IRStackCount start 0 stop 0 max 0 1...etc...
		stack: 	an IRStackCount start 0 stop 2 max 2
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	1
		additionalLiterals: 	an OCLiteralSet()
		forceLongForm: 	false
		primNumber: 	0
		encoderClass: 	EncoderForSistaV1
		inBlock: 	true
		compilationContext: 	a CompilationContext


IRTranslator>>visitSend:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		send: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstrap
		behavior: 	TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRSend>>accept:
	Receiver: send: #doesNotUnderstand: toSuperOf: TMagritteBootstrap
	Arguments and temporary variables: 
		aVisitor: 	an IRTranslato
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(super doesNotUnderstand: aMessage)
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (1)
		selector: 	#doesNotUnderstand:
		superOf: 	TMagritteBootstrap


IRTranslator(IRVisitor)>>visitNode:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		elem: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instr: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


[ :instr | self visitInstruction: instr] in IRTranslator(IRVisitor)>>visitSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		sequence: 	an IRSequence (1)
		instr: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(pushReceiver pushTemp: #aMessage send: #doesNotUnderstand: toSuperOf:...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self visitInstruction: instr]
		index: 	
	Receiver's instance variables: 
		array: 	an Array(pushReceiver pushTemp: #aMessage send: #doesNotUnderstand: toSu...etc...
		firstIndex: 	1
		lastIndex: 	4


IRSequence>>do:
	Receiver: an IRSequence (1)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self visitInstruction: instr
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(pushReceiver pushTemp: #aMessage send: #doesNotU...etc...
		orderNumber: 	1
		method: 	an IRMethod


IRTranslator(IRVisitor)>>visitSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		sequence: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRSequence>>accept:
	Receiver: an IRSequence (1)
	Arguments and temporary variables: 
		aVisitor: 	an IRTranslato
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(pushReceiver pushTemp: #aMessage send: #doesNotU...etc...
		orderNumber: 	1
		method: 	an IRMethod


IRTranslator(IRVisitor)>>visitNode:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		elem: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


[ :each | self visitNode: each ] in IRTranslator(IRVisitor)>>visitNodes:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		col: 	a SortedCollection(an IRSequence (1) an IRSequence (2))
		each: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self visitNode: each ]
		index: 	
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2))
		firstIndex: 	1
		lastIndex: 	2
		sortBlock: 	[:x :y | x orderNumber <= y orderNumber]


IRTranslator(IRVisitor)>>visitNodes:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		col: 	a SortedCollection(an IRSequence (1) an IRSequence (2)
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitSequences:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2)
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitMethod:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMetho
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRMethod>>accept:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		aVisitor: 	an IRTranslato
	Receiver's instance variables: 
		sourceNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary(#aMessage->1 )
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet()
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRTranslator(IRVisitor)>>visitNode:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		elem: 	an IRMetho
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRMethod>>generateBlock:withScope:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		scope: 	an OCBlockScope 2
		irTranslator: 	an IRTranslato
	Receiver's instance variables: 
		sourceNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary(#aMessage->1 )
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet()
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledBlock:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		scope: 	an OCBlockScope 
	Receiver's instance variables: 
		sourceNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary(#aMessage->1 )
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet()
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


OCASTTranslator>>translateFullBlock:
	Receiver: an OCASTTranslator
	Arguments and temporary variables: 
		aBlockNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitFullBlockNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aBlockNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		compiledBlock: 	ni
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitBlockNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aBlockNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


RBBlockNode>>acceptVisitor:
	Receiver: RBBlockNode([ super doesNotUnderstand: aMessage ])
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an OCASTTranslatorForValu
	Receiver's instance variables: 
		parent: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handl...etc...
		properties: 	a SmallDictionary(#ir->an IRMethod)
		parentheses: 	nil
		left: 	207
		right: 	243
		colons: 	an OrderedCollection()
		arguments: 	an OrderedCollection()
		bar: 	nil
		body: 	RBSequenceNode(super doesNotUnderstand: aMessage)
		scope: 	an OCBlockScope 2
		bcToASTCache: 	nil


OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


[:each | 
		valueTranslator visitNode: each] in OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aMessageNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor...etc...
		each: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OrderedCollection>>do:
	Receiver: an OrderedCollection(RBBlockNode([ :d | d accessor handlesSelector: aMessage selector ]) R...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | 
		valueTranslator visitNode: each]
		index: 	
	Receiver's instance variables: 
		array: 	an Array(RBBlockNode([ :d | d accessor handlesSelector: aMessage selecto...etc...
		firstIndex: 	1
		lastIndex: 	3


OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aMessageNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitMessageNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aMessageNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


RBMessageNode>>acceptVisitor:
	Receiver: RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handlesSelector: aMessag...etc...
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an OCASTTranslatorForValu
	Receiver's instance variables: 
		parent: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor ha...etc...
		properties: 	nil
		parentheses: 	nil
		receiver: 	RBMessageNode(self magritteDescription)
		selector: 	#detect:ifFound:ifNone:
		keywordsPositions: 	an IntegerArray(64 130 199)
		arguments: 	an OrderedCollection(RBBlockNode([ :d | d accessor handlesSelector: ...etc...


OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handle...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handle...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForEffect(OCASTTranslator)>>visitReturnNode:
	Receiver: an OCASTTranslatorForEffect
	Arguments and temporary variables: 
		aReturnNode: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d access...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


RBReturnNode>>acceptVisitor:
	Receiver: RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor handlesSelector: aMes...etc...
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an OCASTTranslatorForEffec
	Receiver's instance variables: 
		parent: 	RBSequenceNode(^ self magritteDescription
	  detect: [ :d | d accessor ...etc...
		properties: 	nil
		return: 	33
		value: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handle...etc...


OCASTTranslatorForEffect(RBProgramNodeVisitor)>>visitNode:
	Receiver: an OCASTTranslatorForEffect
	Arguments and temporary variables: 
		aNode: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor han...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForEffect(OCASTTranslator)>>visitNode:
	Receiver: an OCASTTranslatorForEffect
	Arguments and temporary variables: 
		aNode: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor han...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>send:toSuperOf:
IRTranslator>>visitSend:
IRSend>>accept:
IRTranslator(IRVisitor)>>visitNode:
IRTranslator>>visitInstruction:
[ :instr | self visitInstruction: instr] in IRTranslator(IRVisitor)>>visitSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRVisitor)>>visitSequence:
IRTranslator>>visitSequence:
IRSequence>>accept:
IRTranslator(IRVisitor)>>visitNode:
[ :each | self visitNode: each ] in IRTranslator(IRVisitor)>>visitNodes:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRVisitor)>>visitNodes:
IRTranslator>>visitSequences:
IRTranslator>>visitMethod:
IRMethod>>accept:
IRTranslator(IRVisitor)>>visitNode:
IRMethod>>generateBlock:withScope:
IRMethod>>compiledBlock:
OCASTTranslator>>translateFullBlock:
OCASTTranslatorForValue(OCASTTranslator)>>visitFullBlockNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitBlockNode:
RBBlockNode>>acceptVisitor:
OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
[:each | 
		valueTranslator visitNode: each] in OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
OrderedCollection>>do:
OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
OCASTTranslatorForEffect(OCASTTranslator)>>visitReturnNode:
RBReturnNode>>acceptVisitor:
OCASTTranslatorForEffect(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForEffect(OCASTTranslator)>>visitNode:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[:each | self visitNode: each] in OCASTTranslatorForEffect>>visitSequenceNode:
OrderedCollection>>do:
OCASTTranslatorForEffect>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
OCASTTranslatorForEffect(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForEffect(OCASTTranslator)>>visitNode:
OCASTTranslator>>visitMethodNode:
RBMethodNode>>acceptVisitor:
OCASTTranslator(RBProgramNodeVisitor)>>visitNode:
OCASTTranslator>>visitNode:
RBMethodNode>>generateIR
RBMethodNode>>generate:
[ 	[	self parse.
			self transformDoit.
			self doSemanticAnalysis. 
			self callPlugins.  
		] 	on: ReparseAfterSourceEditing 
			do: 
			[  	:notification | 
				self source: notification newSource. 
				notification retry. 
			]. 
		cm := compilationContext optionEmbeddSources
			ifTrue: [ ast generateWithSource ]
			ifFalse: [ast generate: self compilationContext compiledMethodTrailer   ]
		
	] in OpalCompiler>>compile
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>compile
MethodAddition>>createCompiledMethod
MCMethodDefinition>>addMethodAdditionTo:
[ :each | each addMethodAdditionTo: methodAdditions ] in MCPackageLoader>>basicLoadDefinitions
[ :each | | newLabel |
			"Special handling for first and last element"
			(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) 
				ifTrue: [ 
					bar current: count.
					oldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) 
						ifFalse: [
							bar label: newLabel.
							oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
			aBlock value: each.
			count := count + 1 ] in [:bar |
		labelBlock := aStringOrBlock isString
			ifTrue: [
				bar label: aStringOrBlock.
				[ :dummyItem | aStringOrBlock] ]
			ifFalse: [ aStringOrBlock ].

		self do: [ :each | | newLabel |
			"Special handling for first and last element"
			(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) 
				ifTrue: [ 
					bar current: count.
					oldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) 
						ifFalse: [
							bar label: newLabel.
							oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
			aBlock value: each.
			count := count + 1 ] ] in OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection>>do:
[:bar |
		labelBlock := aStringOrBlock isString
			ifTrue: [
				bar label: aStringOrBlock.
				[ :dummyItem | aStringOrBlock] ]
			ifFalse: [ aStringOrBlock ].

		self do: [ :each | | newLabel |
			"Special handling for first and last element"
			(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) 
				ifTrue: [ 
					bar current: count.
					oldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) 
						ifFalse: [
							bar label: newLabel.
							oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
			aBlock value: each.
			count := count + 1 ] ] in OrderedCollection(Collection)>>do:displayingProgress:every:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection(Collection)>>do:displayingProgress:
MCPackageLoader>>basicLoadDefinitions
[self basicLoadDefinitions] in MCPackageLoader>>basicLoad
[ aBlock value ] in SourceFileArray>>deferFlushDuring:
FullBlockClosure(BlockClosure)>>ensure:
SourceFileArray>>deferFlushDuring:
MCPackageLoader>>basicLoad
[self basicLoad] in MCPackageLoader>>loadWithNameLike:
FullBlockClosure(BlockClosure)>>ensure:
MCPackageLoader>>useChangeSetNamed:during:
MCPackageLoader>>useNewChangeSetNamedLike:during:
MCPackageLoader>>loadWithNameLike:
MCVersionLoader>>basicLoadWithNameLike:
[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
MCVersionLoader>>announceLoad:do:
MCVersionLoader>>loadWithNameLike:
[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
[ | loader |
		loader := MCVersionLoader new.
		aCollection do: [ :name | | package packageVersion |
			package := self packageNamed: name.
			packageVersion := (IceSavedPackageVersion
				fromCommit: aCommit
				package: package)
					mcVersion.
			loader addVersion: packageVersion.
			package beClean.
		].
		loader load ] in IceWorkingCopy>>loadPackagesNamed:fromCommit:
FullBlockClosure(BlockClosure)>>ensure:
IceWorkingCopy>>ignoreNotificationsDuring:
IceWorkingCopy>>loadPackagesNamed:fromCommit:
IceWorkingCopy>>loadPackagesNamed:
IceWorkingCopy>>loadPackageNamed:
IcePackage>>load
[ self entity load ] in [ 
			Iceberg announcer
				suspendAllForRepository: self entity repository
				while: [ self entity load ] ] in IceTipPackageModel>>load
FullBlockClosure(BlockClosure)>>ensure:
IceAnnouncer>>suspendAllMatching:while:
IceAnnouncer>>suspendAllForRepository:while:
[ 
			Iceberg announcer
				suspendAllForRepository: self entity repository
				while: [ self entity load ] ] in IceTipPackageModel>>load
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ 
		self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
FullBlockClosure(BlockClosure)>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipPackageModel>>load
IceTipCachedModel>>forwardMessage:
IceTipCachedModel>>doesNotUnderstand: #load
IceTipLoadPackageCommand>>execute
IceTipWorkingCopyContext(CmdToolContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: 
			(anEvent transformedBy: (focusHolder transformedFrom: self)).
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[:h |
		self activeHand: h.
		h processEvents.
		self activeHand: nil.
	] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: not supported
25 August 2020 5:23:21.695962 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.536.sha.d59067fc469a97960a339dcc45d9ed85f6d85791 (64 Bit)]

IRBytecodeGenerator(Object)>>error:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		aString: 	'not supported
	Receiver's instance variables: 
		encoder: 	an EncoderForSistaV1
		seqOrder: 	an IdentityDictionary(an Object->1 1->2 )
		orderSeq: 	an OrderedCollection(an Object 1)
		seqBytes: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordered...etc...
		jumps: 	an IdentityDictionary(an Object->nil 1->nil )
		literals: 	an OCLiteralList()
		lastLiteral: 	nil
		currentSeqId: 	1
		currentSeqNum: 	2
		bytes: 	an OrderedCollection(76 64)
		lastSpecialReturn: 	nil
		primitiveBytes: 	nil
		instrMaps: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordere...etc...
		instrMap: 	an OrderedCollection(pushReceiver->1 pushTemp: #aMessage->2 send: #do...etc...
		stacks: 	an IdentityDictionary(an Object->an IRStackCount start 0 stop 0 max 0 1...etc...
		stack: 	an IRStackCount start 0 stop 2 max 2
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	1
		additionalLiterals: 	an OCLiteralSet()
		forceLongForm: 	false
		primNumber: 	0
		encoderClass: 	EncoderForSistaV1
		inBlock: 	true
		compilationContext: 	a CompilationContext


IRBytecodeGenerator>>send:toSuperOf:
	Receiver: an IRBytecodeGenerator
	Arguments and temporary variables: 
		selector: 	#doesNotUnderstand:
		behavior: 	TMagritteBootstrap
		index: 	nil
		nArgs: 	ni
	Receiver's instance variables: 
		encoder: 	an EncoderForSistaV1
		seqOrder: 	an IdentityDictionary(an Object->1 1->2 )
		orderSeq: 	an OrderedCollection(an Object 1)
		seqBytes: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordered...etc...
		jumps: 	an IdentityDictionary(an Object->nil 1->nil )
		literals: 	an OCLiteralList()
		lastLiteral: 	nil
		currentSeqId: 	1
		currentSeqNum: 	2
		bytes: 	an OrderedCollection(76 64)
		lastSpecialReturn: 	nil
		primitiveBytes: 	nil
		instrMaps: 	an IdentityDictionary(an Object->an OrderedCollection() 1->an Ordere...etc...
		instrMap: 	an OrderedCollection(pushReceiver->1 pushTemp: #aMessage->2 send: #do...etc...
		stacks: 	an IdentityDictionary(an Object->an IRStackCount start 0 stop 0 max 0 1...etc...
		stack: 	an IRStackCount start 0 stop 2 max 2
		numArgs: 	0
		properties: 	nil
		numberOfTemps: 	1
		additionalLiterals: 	an OCLiteralSet()
		forceLongForm: 	false
		primNumber: 	0
		encoderClass: 	EncoderForSistaV1
		inBlock: 	true
		compilationContext: 	a CompilationContext


IRTranslator>>visitSend:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		send: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstrap
		behavior: 	TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRSend>>accept:
	Receiver: send: #doesNotUnderstand: toSuperOf: TMagritteBootstrap
	Arguments and temporary variables: 
		aVisitor: 	an IRTranslato
	Receiver's instance variables: 
		sourceNode: 	RBMessageNode(super doesNotUnderstand: aMessage)
		bytecodeIndex: 	nil
		sequence: 	an IRSequence (1)
		selector: 	#doesNotUnderstand:
		superOf: 	TMagritteBootstrap


IRTranslator(IRVisitor)>>visitNode:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		elem: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitInstruction:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instr: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


[ :instr | self visitInstruction: instr] in IRTranslator(IRVisitor)>>visitSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		sequence: 	an IRSequence (1)
		instr: 	send: #doesNotUnderstand: toSuperOf: TMagritteBootstra
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


OrderedCollection>>do:
	Receiver: an OrderedCollection(pushReceiver pushTemp: #aMessage send: #doesNotUnderstand: toSuperOf:...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self visitInstruction: instr]
		index: 	
	Receiver's instance variables: 
		array: 	an Array(pushReceiver pushTemp: #aMessage send: #doesNotUnderstand: toSu...etc...
		firstIndex: 	1
		lastIndex: 	4


IRSequence>>do:
	Receiver: an IRSequence (1)
	Arguments and temporary variables: 
		aBlock: 	[ :instr | self visitInstruction: instr
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(pushReceiver pushTemp: #aMessage send: #doesNotU...etc...
		orderNumber: 	1
		method: 	an IRMethod


IRTranslator(IRVisitor)>>visitSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		sequence: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitSequence:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		instructionSequence: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRSequence>>accept:
	Receiver: an IRSequence (1)
	Arguments and temporary variables: 
		aVisitor: 	an IRTranslato
	Receiver's instance variables: 
		sequence: 	an OrderedCollection(pushReceiver pushTemp: #aMessage send: #doesNotU...etc...
		orderNumber: 	1
		method: 	an IRMethod


IRTranslator(IRVisitor)>>visitNode:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		elem: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


[ :each | self visitNode: each ] in IRTranslator(IRVisitor)>>visitNodes:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		col: 	a SortedCollection(an IRSequence (1) an IRSequence (2))
		each: 	an IRSequence (1
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


SortedCollection(OrderedCollection)>>do:
	Receiver: a SortedCollection(an IRSequence (1) an IRSequence (2))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self visitNode: each ]
		index: 	
	Receiver's instance variables: 
		array: 	an Array(an IRSequence (1) an IRSequence (2))
		firstIndex: 	1
		lastIndex: 	2
		sortBlock: 	[:x :y | x orderNumber <= y orderNumber]


IRTranslator(IRVisitor)>>visitNodes:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		col: 	a SortedCollection(an IRSequence (1) an IRSequence (2)
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitSequences:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		irSequences: 	a SortedCollection(an IRSequence (1) an IRSequence (2)
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRTranslator>>visitMethod:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		anIr: 	an IRMetho
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRMethod>>accept:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		aVisitor: 	an IRTranslato
	Receiver's instance variables: 
		sourceNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary(#aMessage->1 )
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet()
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRTranslator(IRVisitor)>>visitNode:
	Receiver: an IRTranslator
	Arguments and temporary variables: 
		elem: 	an IRMetho
	Receiver's instance variables: 
		gen: 	an IRBytecodeGenerator
		currentScope: 	a Stack(an IRMethod)
		trailer: 	a CompiledMethodTrailer
		tempVectorStack: 	a Stack()
		compilationContext: 	a CompilationContext


IRMethod>>generateBlock:withScope:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		trailer: 	a CompiledMethodTrailer
		scope: 	an OCBlockScope 2
		irTranslator: 	an IRTranslato
	Receiver's instance variables: 
		sourceNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary(#aMessage->1 )
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet()
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


IRMethod>>compiledBlock:
	Receiver: an IRMethod
	Arguments and temporary variables: 
		scope: 	an OCBlockScope 
	Receiver's instance variables: 
		sourceNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		startSequence: 	an IRSequence (1)
		numArgs: 	0
		properties: 	nil
		tempMap: 	a Dictionary(#aMessage->1 )
		pragmas: 	an OrderedCollection()
		additionalLiterals: 	an OCLiteralSet()
		compiledMethod: 	nil
		compilationContext: 	a CompilationContext
		irPrimitive: 	primitive 0


OCASTTranslator>>translateFullBlock:
	Receiver: an OCASTTranslator
	Arguments and temporary variables: 
		aBlockNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitFullBlockNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aBlockNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ])
		compiledBlock: 	ni
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitBlockNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aBlockNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


RBBlockNode>>acceptVisitor:
	Receiver: RBBlockNode([ super doesNotUnderstand: aMessage ])
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an OCASTTranslatorForValu
	Receiver's instance variables: 
		parent: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handl...etc...
		properties: 	a SmallDictionary(#ir->an IRMethod)
		parentheses: 	nil
		left: 	207
		right: 	243
		colons: 	an OrderedCollection()
		arguments: 	an OrderedCollection()
		bar: 	nil
		body: 	RBSequenceNode(super doesNotUnderstand: aMessage)
		scope: 	an OCBlockScope 2
		bcToASTCache: 	nil


OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


[:each | 
		valueTranslator visitNode: each] in OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aMessageNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor...etc...
		each: 	RBBlockNode([ super doesNotUnderstand: aMessage ]
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OrderedCollection>>do:
	Receiver: an OrderedCollection(RBBlockNode([ :d | d accessor handlesSelector: aMessage selector ]) R...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | 
		valueTranslator visitNode: each]
		index: 	
	Receiver's instance variables: 
		array: 	an Array(RBBlockNode([ :d | d accessor handlesSelector: aMessage selecto...etc...
		firstIndex: 	1
		lastIndex: 	3


OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aMessageNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitMessageNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aMessageNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


RBMessageNode>>acceptVisitor:
	Receiver: RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handlesSelector: aMessag...etc...
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an OCASTTranslatorForValu
	Receiver's instance variables: 
		parent: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor ha...etc...
		properties: 	nil
		parentheses: 	nil
		receiver: 	RBMessageNode(self magritteDescription)
		selector: 	#detect:ifFound:ifNone:
		keywordsPositions: 	an IntegerArray(64 130 199)
		arguments: 	an OrderedCollection(RBBlockNode([ :d | d accessor handlesSelector: ...etc...


OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handle...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
	Receiver: an OCASTTranslatorForValue
	Arguments and temporary variables: 
		aNode: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handle...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForEffect(OCASTTranslator)>>visitReturnNode:
	Receiver: an OCASTTranslatorForEffect
	Arguments and temporary variables: 
		aReturnNode: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d access...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


RBReturnNode>>acceptVisitor:
	Receiver: RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor handlesSelector: aMes...etc...
	Arguments and temporary variables: 
		aProgramNodeVisitor: 	an OCASTTranslatorForEffec
	Receiver's instance variables: 
		parent: 	RBSequenceNode(^ self magritteDescription
	  detect: [ :d | d accessor ...etc...
		properties: 	nil
		return: 	33
		value: 	RBMessageNode(self magritteDescription
	detect: [ :d | d accessor handle...etc...


OCASTTranslatorForEffect(RBProgramNodeVisitor)>>visitNode:
	Receiver: an OCASTTranslatorForEffect
	Arguments and temporary variables: 
		aNode: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor han...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue


OCASTTranslatorForEffect(OCASTTranslator)>>visitNode:
	Receiver: an OCASTTranslatorForEffect
	Arguments and temporary variables: 
		aNode: 	RBReturnNode(^ self magritteDescription
	  detect: [ :d | d accessor han...etc..
	Receiver's instance variables: 
		methodBuilder: 	an IRBuilder
		effectTranslator: 	an OCASTTranslatorForEffect
		valueTranslator: 	an OCASTTranslatorForValue



--- The full stack ---
IRBytecodeGenerator(Object)>>error:
IRBytecodeGenerator>>send:toSuperOf:
IRTranslator>>visitSend:
IRSend>>accept:
IRTranslator(IRVisitor)>>visitNode:
IRTranslator>>visitInstruction:
[ :instr | self visitInstruction: instr] in IRTranslator(IRVisitor)>>visitSequence:
OrderedCollection>>do:
IRSequence>>do:
IRTranslator(IRVisitor)>>visitSequence:
IRTranslator>>visitSequence:
IRSequence>>accept:
IRTranslator(IRVisitor)>>visitNode:
[ :each | self visitNode: each ] in IRTranslator(IRVisitor)>>visitNodes:
SortedCollection(OrderedCollection)>>do:
IRTranslator(IRVisitor)>>visitNodes:
IRTranslator>>visitSequences:
IRTranslator>>visitMethod:
IRMethod>>accept:
IRTranslator(IRVisitor)>>visitNode:
IRMethod>>generateBlock:withScope:
IRMethod>>compiledBlock:
OCASTTranslator>>translateFullBlock:
OCASTTranslatorForValue(OCASTTranslator)>>visitFullBlockNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitBlockNode:
RBBlockNode>>acceptVisitor:
OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
[:each | 
		valueTranslator visitNode: each] in OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
OrderedCollection>>do:
OCASTTranslatorForValue(OCASTTranslator)>>emitMessageNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitMessageNode:
RBMessageNode>>acceptVisitor:
OCASTTranslatorForValue(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForValue(OCASTTranslator)>>visitNode:
OCASTTranslatorForEffect(OCASTTranslator)>>visitReturnNode:
RBReturnNode>>acceptVisitor:
OCASTTranslatorForEffect(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForEffect(OCASTTranslator)>>visitNode:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[:each | self visitNode: each] in OCASTTranslatorForEffect>>visitSequenceNode:
OrderedCollection>>do:
OCASTTranslatorForEffect>>visitSequenceNode:
RBSequenceNode>>acceptVisitor:
OCASTTranslatorForEffect(RBProgramNodeVisitor)>>visitNode:
OCASTTranslatorForEffect(OCASTTranslator)>>visitNode:
OCASTTranslator>>visitMethodNode:
RBMethodNode>>acceptVisitor:
OCASTTranslator(RBProgramNodeVisitor)>>visitNode:
OCASTTranslator>>visitNode:
RBMethodNode>>generateIR
RBMethodNode>>generate:
[ 	[	self parse.
			self transformDoit.
			self doSemanticAnalysis. 
			self callPlugins.  
		] 	on: ReparseAfterSourceEditing 
			do: 
			[  	:notification | 
				self source: notification newSource. 
				notification retry. 
			]. 
		cm := compilationContext optionEmbeddSources
			ifTrue: [ ast generateWithSource ]
			ifFalse: [ast generate: self compilationContext compiledMethodTrailer   ]
		
	] in OpalCompiler>>compile
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>compile
MethodAddition>>createCompiledMethod
MCMethodDefinition>>addMethodAdditionTo:
[ :each | each addMethodAdditionTo: methodAdditions ] in MCPackageLoader>>basicLoadDefinitions
[ :each | | newLabel |
			"Special handling for first and last element"
			(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) 
				ifTrue: [ 
					bar current: count.
					oldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) 
						ifFalse: [
							bar label: newLabel.
							oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
			aBlock value: each.
			count := count + 1 ] in [:bar |
		labelBlock := aStringOrBlock isString
			ifTrue: [
				bar label: aStringOrBlock.
				[ :dummyItem | aStringOrBlock] ]
			ifFalse: [ aStringOrBlock ].

		self do: [ :each | | newLabel |
			"Special handling for first and last element"
			(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) 
				ifTrue: [ 
					bar current: count.
					oldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) 
						ifFalse: [
							bar label: newLabel.
							oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
			aBlock value: each.
			count := count + 1 ] ] in OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection>>do:
[:bar |
		labelBlock := aStringOrBlock isString
			ifTrue: [
				bar label: aStringOrBlock.
				[ :dummyItem | aStringOrBlock] ]
			ifFalse: [ aStringOrBlock ].

		self do: [ :each | | newLabel |
			"Special handling for first and last element"
			(count = 0 or: [ count + 1 = size or: [(Time millisecondsSince: lastUpdate) >= msecs]]) 
				ifTrue: [ 
					bar current: count.
					oldLabel = (newLabel := (labelBlock cull: each) ifNil: [oldLabel]) 
						ifFalse: [
							bar label: newLabel.
							oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
			aBlock value: each.
			count := count + 1 ] ] in OrderedCollection(Collection)>>do:displayingProgress:every:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection(Collection)>>do:displayingProgress:
MCPackageLoader>>basicLoadDefinitions
[self basicLoadDefinitions] in MCPackageLoader>>basicLoad
[ aBlock value ] in SourceFileArray>>deferFlushDuring:
FullBlockClosure(BlockClosure)>>ensure:
SourceFileArray>>deferFlushDuring:
MCPackageLoader>>basicLoad
[self basicLoad] in MCPackageLoader>>loadWithNameLike:
FullBlockClosure(BlockClosure)>>ensure:
MCPackageLoader>>useChangeSetNamed:during:
MCPackageLoader>>useNewChangeSetNamedLike:during:
MCPackageLoader>>loadWithNameLike:
MCVersionLoader>>basicLoadWithNameLike:
[ self basicLoadWithNameLike: aString ] in MCVersionLoader>>loadWithNameLike:
[ returnValue := aBlock value ] in [ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
[ 
		[ returnValue := aBlock value ] ensure: [ 
			self announceLoadStop: aString ] ] in MCVersionLoader>>announceLoad:do:
FullBlockClosure(BlockClosure)>>ensure:
MCVersionLoader>>announceLoad:do:
MCVersionLoader>>loadWithNameLike:
[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] in [   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
[   
		| version |
		version := versions first. 
		[ self ensurePackage: version package.
		  self loadWithNameLike: version info name ] asJob
				title: 'Loading ', version info name asString;
				run ] in MCVersionLoader>>load
FullBlockClosure(BlockClosure)>>ensure:
RPackageSet class>>withCacheDo:
MCVersionLoader>>load
[ | loader |
		loader := MCVersionLoader new.
		aCollection do: [ :name | | package packageVersion |
			package := self packageNamed: name.
			packageVersion := (IceSavedPackageVersion
				fromCommit: aCommit
				package: package)
					mcVersion.
			loader addVersion: packageVersion.
			package beClean.
		].
		loader load ] in IceWorkingCopy>>loadPackagesNamed:fromCommit:
FullBlockClosure(BlockClosure)>>ensure:
IceWorkingCopy>>ignoreNotificationsDuring:
IceWorkingCopy>>loadPackagesNamed:fromCommit:
IceWorkingCopy>>loadPackagesNamed:
IceWorkingCopy>>loadPackageNamed:
IcePackage>>load
IcePackage>>reload
[ self entity reload ] in [ 
			Iceberg announcer 
				suspendAllForRepository: self entity repository 
				while: [ self entity reload ] ] in IceTipPackageModel>>reload
FullBlockClosure(BlockClosure)>>ensure:
IceAnnouncer>>suspendAllMatching:while:
IceAnnouncer>>suspendAllForRepository:while:
[ 
			Iceberg announcer 
				suspendAllForRepository: self entity repository 
				while: [ self entity reload ] ] in IceTipPackageModel>>reload
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ 
		self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
FullBlockClosure(BlockClosure)>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipPackageModel>>reload
IceTipCachedModel>>forwardMessage:
IceTipCachedModel>>doesNotUnderstand: #reload
IceTipReloadPackageCommand>>execute
IceTipWorkingCopyContext(CmdToolContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: 
			(anEvent transformedBy: (focusHolder transformedFrom: self)).
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[:h |
		self activeHand: h.
		h processEvents.
		self activeHand: nil.
	] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Method protocol '*magritte-pharo-model' for the method 'magrittePharoModel' in class 'GRPackage' is inconsistent with the package name '*magritte-pharo20-model'
25 August 2020 5:23:55.8479 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.536.sha.d59067fc469a97960a339dcc45d9ed85f6d85791 (64 Bit)]

IceLibgitFiletreeReader(Object)>>error:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aString: 	'Method protocol ''*magritte-pharo-model'' for the method ''magrittePh...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateExtensionMethodCategory:for:selector:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		categoryName: 	'*magritte-pharo-model'
		className: 	'GRPackage'
		selector: 	#magrittePharoModel
		prefix: 	'*magritte-pharo20-model
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] in [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] in [ :entry | 
			| classIsMeta |
			classIsMeta := false.
			entry name = 'class' ifTrue: [ classIsMeta := true ].
			(entry name = 'instance' or: [ entry name = 'class' ])
				ifTrue: [ (self loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
						do: [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st')
		fileStream: 	a ReadStream
		category: 	'*magritte-pharo-model'
		source: 	'magrittePharoModel
	^ self new
		name: ''Magritte-Pharo-Model'';
		add...etc...
		timestamp: 	'CompatibleUserName 8/6/2020 03:30:13'
		selector: 	#magrittePharoMode
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


LGitTreeEntry>>readStreamDo:
	Receiver: a LGitTreeEntry ('magrittePharoModel.st')
	Arguments and temporary variables: 
		aBlock: 	[ :fileStream | 
									| category source timestamp selector |
						...etc..
	Receiver's instance variables: 
		handle: 	(void*)@ 16r7FE94C0A0A90
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		parent: 	a LGitTree (number of entries: 1)


[ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] in [ :entry | 
			| classIsMeta |
			classIsMeta := false.
			entry name = 'class' ifTrue: [ classIsMeta := true ].
			(entry name = 'instance' or: [ entry name = 'class' ])
				ifTrue: [ (self loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
						do: [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('magrittePharoModel.st'))
	Arguments and temporary variables: 
		aBlock: 	[ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStrea...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('magrittePharoModel.st'))

[ :entry | 
			| classIsMeta |
			classIsMeta := false.
			entry name = 'class' ifTrue: [ classIsMeta := true ].
			(entry name = 'instance' or: [ entry name = 'class' ])
				ifTrue: [ (self loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
						do: [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
			| classIsMeta |
			classIsMeta := false.
			entry name =...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addExtensionClassAndMethodDefinitionsFromEntry:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		classPropertiesDict: 	a Dictionary('name'->'GRPackage' )
		methodPropertiesDict: 	a Dictionary()
		classEntry: 	a LGitTreeEntry ('GRPackage.extension')
		classDirectory: 	a LGitTree (number of entries: 2)
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :entry | 
            (entry name endsWith: '.trait')
                ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
            (entry name endsWith: '.class')
                ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
            (entry name endsWith: '.extension')
                ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		entry: 	a LGitTreeEntry ('GRPackage.extension'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
            (entry name endsWith: '.trait')
               ...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		entries: 	an Array(a LGitTreeEntry ('categories.st') a LGitTreeEntry ('initializ...etc...
		directory: 	a LGitTreeEntry ('monticello.meta'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>definitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>snapshot
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>version
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ | commit |
		commit := iceVersion commit libgitCommit.
		^ (iceVersion commit readerClass on: commit iceVersion: iceVersion) version ] in IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)
		commit: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 92%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ | commit |
		commit := iceVersion commit libgitCommit.
		^ (iceVersion commit readerClas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ 
		IceVersionDoesNotExist new
			version: iceVersion;
			signa...etc..
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>mcVersionFor:
		startpc: 	a CompiledBlock: [ | commit |
		commit := iceVersion commit libgitComm...etc...
		numArgs: 	0
		receiver: 	IceLibgitRepository(magritte)


IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 92%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitCommit(IceCommitish)>>mcVersionFor:
	Receiver: IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
	Arguments and temporary variables: 
		anIceSavedPackageVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		id: 	'6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1'
		author: 	'Sean DeNigris'
		datetime: 	2020-08-06T03:30:13+02:00
		ancestorIds: 	#('1724c2e0707db8f940c1c9db85df56ae6f2bbf78' 'd40ec27103e85535214a...etc...
		comment: 	'Merge pull request #154 from seandenigris/bug_metacello-invert-depend...etc...


IceSavedPackageVersion>>mcVersion
	Receiver: IceSavedPackageVersion(Magritte-Pharo20-Model)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		entry: 	nil
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


IceConvertFormatAction>>migratePackage:commit:
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		packageName: 	IcePackage(Magritte-Pharo20-Model, not loaded)
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		filetreePackage: 	nil
		srcDir: 	File @ /Users/norbert/work/projects/magritte/source
		subDirWithDelim: 	'source/'
		mcVersion: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


[ :each | 
		self 
			migratePackage: each 
			commit: commit ] in IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		each: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self 
			migratePackage: each 
			commit: commit ]
		index: 	2
	Receiver's instance variables: 
an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...

IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


IceConvertFormatAction>>execute
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		oldBranch: 	IceGitLocalBranch(convert-to-tonel)
		newBranch: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


IceTipFiletreeToTonelDialog>>doAccept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel'
		repository: 	IceLibgitRepository(magritte)


[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel'
		repository: 	IceLibgitRepository(magritte)


[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[:bar | bar label: aString. aBlock value]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [:bar | aBlock value: bar]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		startpc: 	a CompiledBlock: [:bar | aBlock value: bar]
		numArgs: 	1
		receiver: 	a MorphicUIManager


[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a CurrentJob


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[:bar | aBlock value: bar]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil



--- The full stack ---
IceLibgitFiletreeReader(Object)>>error:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateExtensionMethodCategory:for:selector:
[ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] in [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] in [ :entry | 
			| classIsMeta |
			classIsMeta := false.
			entry name = 'class' ifTrue: [ classIsMeta := true ].
			(entry name = 'instance' or: [ entry name = 'class' ])
				ifTrue: [ (self loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
						do: [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
LGitTreeEntry>>readStreamDo:
[ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] in [ :entry | 
			| classIsMeta |
			classIsMeta := false.
			entry name = 'class' ifTrue: [ classIsMeta := true ].
			(entry name = 'instance' or: [ entry name = 'class' ])
				ifTrue: [ (self loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
						do: [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
Array(SequenceableCollection)>>do:
[ :entry | 
			| classIsMeta |
			classIsMeta := false.
			entry name = 'class' ifTrue: [ classIsMeta := true ].
			(entry name = 'instance' or: [ entry name = 'class' ])
				ifTrue: [ (self loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
						do: [ :methodEntry | 
							methodEntry
								readStreamDo: [ :fileStream | 
									| category source timestamp selector |
									category := fileStream nextLine.
									source := fileStream upToEnd.
									selector := self methodSelectorFor: source.
									timestamp := methodProperties at: (classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
									timestamp ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' ' , self info time print24 ].
									extensionMethod ifTrue: [ self validateExtensionMethodCategory: category for: className selector: selector ].
									definitions
										add:
											(MCMethodDefinition
												className: className
												classIsMeta: classIsMeta
												selector: selector
												category: category
												timeStamp: timestamp
												source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
Array(SequenceableCollection)>>do:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addExtensionClassAndMethodDefinitionsFromEntry:
[ :entry | 
            (entry name endsWith: '.trait')
                ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
            (entry name endsWith: '.class')
                ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
            (entry name endsWith: '.extension')
                ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
Array(SequenceableCollection)>>do:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
IceLibgitFiletreeReader(MCVersionReader)>>definitions
IceLibgitFiletreeReader(MCVersionReader)>>snapshot
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
IceLibgitFiletreeReader(MCVersionReader)>>version
[ | commit |
		commit := iceVersion commit libgitCommit.
		^ (iceVersion commit readerClass on: commit iceVersion: iceVersion) version ] in IceLibgitRepository>>mcVersionFor:
FullBlockClosure(BlockClosure)>>on:do:
IceLibgitRepository>>mcVersionFor:
IceGitCommit(IceCommitish)>>mcVersionFor:
IceSavedPackageVersion>>mcVersion
IceConvertFormatAction>>migratePackage:commit:
[ :each | 
		self 
			migratePackage: each 
			commit: commit ] in IceConvertFormatAction>>migrateSources
Array(SequenceableCollection)>>do:
IceConvertFormatAction>>migrateSources
IceConvertFormatAction>>execute
IceTipFiletreeToTonelDialog>>doAccept
[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
[:bar | bar label: aString. aBlock value] in MorphicUIManager(UIManager)>>informUser:during:
[:bar | aBlock value: bar] in MorphicUIManager>>informUserDuring:
FullBlockClosure(BlockClosure)>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
	  CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ 
		self basicExecute.
		self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
FullBlockClosure(BlockClosure)>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipFiletreeToTonelDialog>>accept
[ self accept ] in IceTipFiletreeToTonelDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
		ifFalse: [ owner 
			ifNil: [ self delete ] 
			ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: 
			(anEvent transformedBy: (focusHolder transformedFrom: self)).
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[:h |
		self activeHand: h.
		h processEvents.
		self activeHand: nil.
	] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of GRAnsiBooleansRule class did not understand #enabledSettingID
25 August 2020 5:26:24.530344 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.536.sha.d59067fc469a97960a339dcc45d9ed85f6d85791 (64 Bit)]

GRAnsiBooleansRule class(Object)>>doesNotUnderstand: #enabledSettingID
	Receiver: GRAnsiBooleansRule
	Arguments and temporary variables: 
		aMessage: 	enabledSettingID
		exception: 	MessageNotUnderstood: GRAnsiBooleansRule class>> #enabledSettingID
		resumeValue: 	ni
	Receiver's instance variables: 
		superclass: 	GRSlimeTransformationRule
		methodDict: 	a MethodDictionary(#group->GRAnsiBooleansRule>>#group #initialize->...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GRAnsiBooleansRule
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Grease-Pharo40-Slime'


[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] in [ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilder
		rule: 	GRAnsiBooleansRule
		inst: 	a GRAnsiBooleansRule name: 'Booleans
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(FloatReferencesRule GRAnsiBooleansRule GRAnsiCharactersRule GRAnsiCol...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting:...etc...
		index: 	
	Receiver's instance variables: 
		array: 	{FloatReferencesRule. GRAnsiBooleansRule. GRAnsiCharactersRule. GRAnsiCo...etc...
		firstIndex: 	1
		lastIndex: 	175


[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


SettingTreeBuilder>>parent:while:
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 
		aNode: 	a SettingNodeBuilder
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc...
		oldParent: 	ni
	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


SettingNodeBuilder>>asParentWhile:
	Receiver: a SettingNodeBuilder
	Arguments and temporary variables: 
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc..
	Receiver's instance variables: 
		node: 	Node(a PragmaSetting)
		builder: 	a SettingTreeBuilder


SettingNodeBuilder>>with:
	Receiver: a SettingNodeBuilder
	Arguments and temporary variables: 
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc..
	Receiver's instance variables: 
		node: 	Node(a PragmaSetting)
		builder: 	a SettingTreeBuilder


ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


SettingTreeBuilder>>systemsettings
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


SettingTreeBuilder>>buildPragma:
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 
		aPragma: 	<systemsettings
	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


[:p | builder buildPragma: p] in SettingTree>>nodeList
	Receiver: a SettingTree
	Arguments and temporary variables: 
		builder: 	a SettingTreeBuilder
		p: 	<systemsettings
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(<systemsettings> <systemsettings> <systemsettings> <systemsettings> <...etc...
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p]
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(<systemsettings> <systemsettings> <systemsettings> <systemsetti...etc...
		firstIndex: 	1
		lastIndex: 	104


PragmaCollector>>do:
	Receiver: a PragmaCollector
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		collected: 	an OrderedCollection(<systemsettings> <systemsettings> <systemsettin...etc...
		filter: 	[:prg | prg methodClass isMeta and: [keywords includes: prg selector]]
		announcing: 	true


SettingTree>>pragmasDo:
	Receiver: a SettingTree
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SettingTree>>nodeList
	Receiver: a SettingTree
	Arguments and temporary variables: 
		builder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SettingTree>>settingTreeRoots
	Receiver: a SettingTree
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SettingBrowser>>rootNodes
	Receiver: a SettingBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(565622272) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


MorphTreeMorph>>getList
	Receiver: a MorphTreeMorph(580384512)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (150@120)
		owner: 	nil
		submorphs: 	an Array(a MorphTreeResizerMorph(130752000) a Morph(676318976) a Mor...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (263156224) [other:  (announcer -> an Announcer)]
		borderWidth: 	0
		borderColor: 	(Color r: 0.7839687194525904 g: 0.7839687194525904 b: 0.7839687194...etc...
		model: 	a SettingBrowser
		scrollBar: 	a ScrollBar(127310592)
		scroller: 	a MorphTreeTransformMorph(84387328)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(816481792)
		columns: 	an OrderedCollection(a MorphTreeColumn a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	6
		columnInset: 	6
		columnResizers: 	an OrderedCollection(a MorphTreeResizerMorph(130752000))
		withHLines: 	nil
		preferedPaneColor: 	nil
		indentGap: 	nil
		expandedToggleImage: 	nil
		notExpandedToggleImage: 	nil
		resizerWidth: 	3
		gapAfterToggle: 	nil
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(676318976)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{(Color r: 0.9413489736070382 g: 0.9413489736070382 b: 0.94134897360...etc...
		nodeList: 	nil
		iconBlock: 	nil
		treeLineWidth: 	nil
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	nil
		maxNodeWidth: 	nil
		enabled: 	nil


MorphTreeMorph>>nodeList
	Receiver: a MorphTreeMorph(580384512)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (150@120)
		owner: 	nil
		submorphs: 	an Array(a MorphTreeResizerMorph(130752000) a Morph(676318976) a Mor...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (263156224) [other:  (announcer -> an Announcer)]
		borderWidth: 	0
		borderColor: 	(Color r: 0.7839687194525904 g: 0.7839687194525904 b: 0.7839687194...etc...
		model: 	a SettingBrowser
		scrollBar: 	a ScrollBar(127310592)
		scroller: 	a MorphTreeTransformMorph(84387328)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(816481792)
		columns: 	an OrderedCollection(a MorphTreeColumn a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	6
		columnInset: 	6
		columnResizers: 	an OrderedCollection(a MorphTreeResizerMorph(130752000))
		withHLines: 	nil
		preferedPaneColor: 	nil
		indentGap: 	nil
		expandedToggleImage: 	nil
		notExpandedToggleImage: 	nil
		resizerWidth: 	3
		gapAfterToggle: 	nil
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(676318976)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{(Color r: 0.9413489736070382 g: 0.9413489736070382 b: 0.94134897360...etc...
		nodeList: 	nil
		iconBlock: 	nil
		treeLineWidth: 	nil
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	nil
		maxNodeWidth: 	nil
		enabled: 	nil


MorphTreeMorph>>buildContents
	Receiver: a MorphTreeMorph(580384512)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (150@120)
		owner: 	nil
		submorphs: 	an Array(a MorphTreeResizerMorph(130752000) a Morph(676318976) a Mor...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (263156224) [other:  (announcer -> an Announcer)]
		borderWidth: 	0
		borderColor: 	(Color r: 0.7839687194525904 g: 0.7839687194525904 b: 0.7839687194...etc...
		model: 	a SettingBrowser
		scrollBar: 	a ScrollBar(127310592)
		scroller: 	a MorphTreeTransformMorph(84387328)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(816481792)
		columns: 	an OrderedCollection(a MorphTreeColumn a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	6
		columnInset: 	6
		columnResizers: 	an OrderedCollection(a MorphTreeResizerMorph(130752000))
		withHLines: 	nil
		preferedPaneColor: 	nil
		indentGap: 	nil
		expandedToggleImage: 	nil
		notExpandedToggleImage: 	nil
		resizerWidth: 	3
		gapAfterToggle: 	nil
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(676318976)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{(Color r: 0.9413489736070382 g: 0.9413489736070382 b: 0.94134897360...etc...
		nodeList: 	nil
		iconBlock: 	nil
		treeLineWidth: 	nil
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	nil
		maxNodeWidth: 	nil
		enabled: 	nil


SettingBrowser>>treeMorphIn:
	Receiver: a SettingBrowser
	Arguments and temporary variables: 
		aMorph: 	a StandardWindow(565622272) named: Settings Browser
		treeMorph: 	a MorphTreeMorph(580384512
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(565622272) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


SettingBrowser>>buildWindowIn:
	Receiver: a SettingBrowser
	Arguments and temporary variables: 
		aWindow: 	a StandardWindow(565622272) named: Settings Browser
		statusView: 	nil
		toolBar: 	nil
		treeMorph: 	nil
		toolBarY: 	nil
		gap: 	nil
		packageListView: 	nil
		statusViewHeight: 	ni
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(565622272) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


[ | window |window := StandardWindow new model: self.
			window title: self windowTitle.
			self buildWindowIn: window.
			window themeChanged.
			window openInWorld.
			(window findDeeplyA: self treeMorphClass)  takeKeyboardFocus. 
			^ window] in SettingBrowser>>open
	Receiver: a SettingBrowser
	Arguments and temporary variables: 
		window: 	a StandardWindow(565622272) named: Settings Browse
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(565622272) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | window |window := StandardWindow new model: self.
			window title: self windowTitle.
	...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	SettingBrowser>>open
		startpc: 	a CompiledBlock: [ | window |window := StandardWindow new model: self....etc...
		numArgs: 	0
		receiver: 	a SettingBrowser


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r111111111111110000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | window |window := StandardWindow new model: self.
			window title: ...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc..
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SettingBrowser>>open
	Receiver: a SettingBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(565622272) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


SettingBrowser class>>open
	Receiver: SettingBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MorphTreeModel
		methodDict: 	a MethodDictionary(#about->SettingBrowser>>#about #acceptableKeywor...etc...
		format: 	65551
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SettingBrowser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Settings-Browser'
		searchedTextList: 	nil
		regexpSearch: 	nil


[ SettingBrowser open ] in SettingBrowser class>>menuCommandOn:
	Receiver: SettingBrowser
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistratio
	Receiver's instance variables: 
		superclass: 	MorphTreeModel
		methodDict: 	a MethodDictionary(#about->SettingBrowser>>#about #acceptableKeywor...etc...
		format: 	65551
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SettingBrowser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Settings-Browser'
		searchedTextList: 	nil
		regexpSearch: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ SettingBrowser open ]
	Arguments and temporary variables: 
		anArg: 	a WorldStat
	Receiver's instance variables: 
		outerContext: 	SettingBrowser class>>menuCommandOn:
		startpc: 	a CompiledBlock: [ SettingBrowser open ]
		numArgs: 	0
		receiver: 	SettingBrowser


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		evt: 	[(48@36) mouseUp 265142 nil]
		w: 	a WorldMorph(838144) [world]
		selArgCount: 	
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(188268288)'Settings'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc..
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		evt: 	[(48@36) mouseUp 265142 nil]
		w: 	a WorldMorph(838144) [world
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		evt: 	[(48@36) mouseUp 265142 nil
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		anEvent: 	[(48@36) mouseUp 265142 nil
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(48@36) mouseUp 265142 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(188268288)'Settings
	Receiver's instance variables: 
		timeStamp: 	265142
		source: 	a HandMorph(498002432)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(48@36)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		anEvent: 	[(48@36) mouseUp 265142 nil
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(48@36) mouseUp 265142 nil]
		aMorph: 	a ToggleMenuItemMorph(188268288)'Settings'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	tru
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(188268288)'Settings'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(48@36) mouseUp 265142 nil
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(188268288)'Settings'



--- The full stack ---
GRAnsiBooleansRule class(Object)>>doesNotUnderstand: #enabledSettingID
[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] in [ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
OrderedCollection>>do:
[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
SettingTreeBuilder>>parent:while:
SettingNodeBuilder>>asParentWhile:
SettingNodeBuilder>>with:
ReRuleManager class>>ruleToggleSettingsOn:
SettingTreeBuilder>>systemsettings
SettingTreeBuilder>>buildPragma:
[:p | builder buildPragma: p] in SettingTree>>nodeList
OrderedCollection>>do:
PragmaCollector>>do:
SettingTree>>pragmasDo:
SettingTree>>nodeList
SettingTree>>settingTreeRoots
SettingBrowser>>rootNodes
MorphTreeMorph>>getList
MorphTreeMorph>>nodeList
MorphTreeMorph>>buildContents
SettingBrowser>>treeMorphIn:
SettingBrowser>>buildWindowIn:
[ | window |window := StandardWindow new model: self.
			window title: self windowTitle.
			self buildWindowIn: window.
			window themeChanged.
			window openInWorld.
			(window findDeeplyA: self treeMorphClass)  takeKeyboardFocus. 
			^ window] in SettingBrowser>>open
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SettingBrowser>>open
SettingBrowser class>>open
[ SettingBrowser open ] in SettingBrowser class>>menuCommandOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: 
			(anEvent transformedBy: (focusHolder transformedFrom: self)).
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[:h |
		self activeHand: h.
		h processEvents.
		self activeHand: nil.
	] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of GRAnsiBooleansRule class did not understand #enabledSettingID
25 August 2020 5:26:33.39485 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.536.sha.d59067fc469a97960a339dcc45d9ed85f6d85791 (64 Bit)]

GRAnsiBooleansRule class(Object)>>doesNotUnderstand: #enabledSettingID
	Receiver: GRAnsiBooleansRule
	Arguments and temporary variables: 
		aMessage: 	enabledSettingID
		exception: 	MessageNotUnderstood: GRAnsiBooleansRule class>> #enabledSettingID
		resumeValue: 	ni
	Receiver's instance variables: 
		superclass: 	GRSlimeTransformationRule
		methodDict: 	a MethodDictionary(#group->GRAnsiBooleansRule>>#group #initialize->...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GRAnsiBooleansRule
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Grease-Pharo40-Slime'


[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] in [ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilder
		rule: 	GRAnsiBooleansRule
		inst: 	a GRAnsiBooleansRule name: 'Booleans
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


OrderedCollection>>do:
	Receiver: an OrderedCollection(FloatReferencesRule GRAnsiBooleansRule GRAnsiCharactersRule GRAnsiCol...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting:...etc...
		index: 	
	Receiver's instance variables: 
		array: 	{FloatReferencesRule. GRAnsiBooleansRule. GRAnsiCharactersRule. GRAnsiCo...etc...
		firstIndex: 	1
		lastIndex: 	175


[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


SettingTreeBuilder>>parent:while:
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 
		aNode: 	a SettingNodeBuilder
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc...
		oldParent: 	ni
	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


SettingNodeBuilder>>asParentWhile:
	Receiver: a SettingNodeBuilder
	Arguments and temporary variables: 
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc..
	Receiver's instance variables: 
		node: 	Node(a PragmaSetting)
		builder: 	a SettingTreeBuilder


SettingNodeBuilder>>with:
	Receiver: a SettingNodeBuilder
	Arguments and temporary variables: 
		aBlock: 	[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
			...etc..
	Receiver's instance variables: 
		node: 	Node(a PragmaSetting)
		builder: 	a SettingTreeBuilder


ReRuleManager class>>ruleToggleSettingsOn:
	Receiver: ReRuleManager
	Arguments and temporary variables: 
		aBuilder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allRules->ReRuleManager>>#allRules #classRules-...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReRuleManager
		classPool: 	a Dictionary(#RulesProfile->#setDefaultProfile )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		default: 	a ReRuleManager
		managers: 	a WeakKeyDictionary(a RPackage(BaselineOfMagritte)->a ReRuleManager )...etc...


SettingTreeBuilder>>systemsettings
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


SettingTreeBuilder>>buildPragma:
	Receiver: a SettingTreeBuilder
	Arguments and temporary variables: 
		aPragma: 	<systemsettings
	Receiver's instance variables: 
		nodeList: 	an OrderedCollection(Node(a SettingDeclaration) Node(a PragmaSetting)...etc...
		currentParent: 	a SettingNodeBuilder
		currentPragma: 	<systemsettings>


[:p | builder buildPragma: p] in SettingTree>>nodeList
	Receiver: a SettingTree
	Arguments and temporary variables: 
		builder: 	a SettingTreeBuilder
		p: 	<systemsettings
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(<systemsettings> <systemsettings> <systemsettings> <systemsettings> <...etc...
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p]
		index: 	7
	Receiver's instance variables: 
		array: 	an Array(<systemsettings> <systemsettings> <systemsettings> <systemsetti...etc...
		firstIndex: 	1
		lastIndex: 	104


PragmaCollector>>do:
	Receiver: a PragmaCollector
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	an Announcer
		collected: 	an OrderedCollection(<systemsettings> <systemsettings> <systemsettin...etc...
		filter: 	[:prg | prg methodClass isMeta and: [keywords includes: prg selector]]
		announcing: 	true


SettingTree>>pragmasDo:
	Receiver: a SettingTree
	Arguments and temporary variables: 
		aBlock: 	[:p | builder buildPragma: p
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SettingTree>>nodeList
	Receiver: a SettingTree
	Arguments and temporary variables: 
		builder: 	a SettingTreeBuilde
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SettingTree>>settingTreeRoots
	Receiver: a SettingTree
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		collector: 	a PragmaCollector
		nodeList: 	nil
		persistence: 	nil


SettingBrowser>>rootNodes
	Receiver: a SettingBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(725040896) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


MorphTreeMorph>>getList
	Receiver: a MorphTreeMorph(941195776)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (150@120)
		owner: 	nil
		submorphs: 	an Array(a MorphTreeResizerMorph(316082944) a Morph(606311936) a Mor...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (478025472) [other:  (announcer -> an Announcer)]
		borderWidth: 	0
		borderColor: 	(Color r: 0.7839687194525904 g: 0.7839687194525904 b: 0.7839687194...etc...
		model: 	a SettingBrowser
		scrollBar: 	a ScrollBar(438856192)
		scroller: 	a MorphTreeTransformMorph(597948928)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(326656768)
		columns: 	an OrderedCollection(a MorphTreeColumn a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	6
		columnInset: 	6
		columnResizers: 	an OrderedCollection(a MorphTreeResizerMorph(316082944))
		withHLines: 	nil
		preferedPaneColor: 	nil
		indentGap: 	nil
		expandedToggleImage: 	nil
		notExpandedToggleImage: 	nil
		resizerWidth: 	3
		gapAfterToggle: 	nil
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(606311936)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{(Color r: 0.9413489736070382 g: 0.9413489736070382 b: 0.94134897360...etc...
		nodeList: 	nil
		iconBlock: 	nil
		treeLineWidth: 	nil
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	nil
		maxNodeWidth: 	nil
		enabled: 	nil


MorphTreeMorph>>nodeList
	Receiver: a MorphTreeMorph(941195776)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (150@120)
		owner: 	nil
		submorphs: 	an Array(a MorphTreeResizerMorph(316082944) a Morph(606311936) a Mor...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (478025472) [other:  (announcer -> an Announcer)]
		borderWidth: 	0
		borderColor: 	(Color r: 0.7839687194525904 g: 0.7839687194525904 b: 0.7839687194...etc...
		model: 	a SettingBrowser
		scrollBar: 	a ScrollBar(438856192)
		scroller: 	a MorphTreeTransformMorph(597948928)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(326656768)
		columns: 	an OrderedCollection(a MorphTreeColumn a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	6
		columnInset: 	6
		columnResizers: 	an OrderedCollection(a MorphTreeResizerMorph(316082944))
		withHLines: 	nil
		preferedPaneColor: 	nil
		indentGap: 	nil
		expandedToggleImage: 	nil
		notExpandedToggleImage: 	nil
		resizerWidth: 	3
		gapAfterToggle: 	nil
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(606311936)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{(Color r: 0.9413489736070382 g: 0.9413489736070382 b: 0.94134897360...etc...
		nodeList: 	nil
		iconBlock: 	nil
		treeLineWidth: 	nil
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	nil
		maxNodeWidth: 	nil
		enabled: 	nil


MorphTreeMorph>>buildContents
	Receiver: a MorphTreeMorph(941195776)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (150@120)
		owner: 	nil
		submorphs: 	an Array(a MorphTreeResizerMorph(316082944) a Morph(606311936) a Mor...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (478025472) [other:  (announcer -> an Announcer)]
		borderWidth: 	0
		borderColor: 	(Color r: 0.7839687194525904 g: 0.7839687194525904 b: 0.7839687194...etc...
		model: 	a SettingBrowser
		scrollBar: 	a ScrollBar(438856192)
		scroller: 	a MorphTreeTransformMorph(597948928)
		getMenuSelector: 	#menu:shifted:
		getMenuTitleSelector: 	nil
		hasFocus: 	false
		hScrollBar: 	a ScrollBar(326656768)
		columns: 	an OrderedCollection(a MorphTreeColumn a MorphTreeColumn)
		potentialDropMorph: 	nil
		rowInset: 	6
		columnInset: 	6
		columnResizers: 	an OrderedCollection(a MorphTreeResizerMorph(316082944))
		withHLines: 	nil
		preferedPaneColor: 	nil
		indentGap: 	nil
		expandedToggleImage: 	nil
		notExpandedToggleImage: 	nil
		resizerWidth: 	3
		gapAfterToggle: 	nil
		hasToggleAtRoot: 	nil
		topHeader: 	a Morph(606311936)
		topHeaderBackground: 	Color transparent
		unboundLastColumn: 	true
		columnDropUnabled: 	nil
		columnColors: 	{Color transparent. Color transparent}
		rowColors: 	{(Color r: 0.9413489736070382 g: 0.9413489736070382 b: 0.94134897360...etc...
		nodeList: 	nil
		iconBlock: 	nil
		treeLineWidth: 	nil
		lineColorBlock: 	nil
		treeLineDashes: 	nil
		listManager: 	a MorphTreeListManager
		mouseOverAllowed: 	nil
		maxNodeWidth: 	nil
		enabled: 	nil


SettingBrowser>>treeMorphIn:
	Receiver: a SettingBrowser
	Arguments and temporary variables: 
		aMorph: 	a StandardWindow(725040896) named: Settings Browser
		treeMorph: 	a MorphTreeMorph(941195776
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(725040896) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


SettingBrowser>>buildWindowIn:
	Receiver: a SettingBrowser
	Arguments and temporary variables: 
		aWindow: 	a StandardWindow(725040896) named: Settings Browser
		statusView: 	nil
		toolBar: 	nil
		treeMorph: 	nil
		toolBarY: 	nil
		gap: 	nil
		packageListView: 	nil
		statusViewHeight: 	ni
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(725040896) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


[ | window |window := StandardWindow new model: self.
			window title: self windowTitle.
			self buildWindowIn: window.
			window themeChanged.
			window openInWorld.
			(window findDeeplyA: self treeMorphClass)  takeKeyboardFocus. 
			^ window] in SettingBrowser>>open
	Receiver: a SettingBrowser
	Arguments and temporary variables: 
		window: 	a StandardWindow(725040896) named: Settings Browse
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(725040896) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | window |window := StandardWindow new model: self.
			window title: self windowTitle.
	...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	SettingBrowser>>open
		startpc: 	a CompiledBlock: [ | window |window := StandardWindow new model: self....etc...
		numArgs: 	0
		receiver: 	a SettingBrowser


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r111111111111110000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | window |window := StandardWindow new model: self.
			window title: ...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc..
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SettingBrowser>>open
	Receiver: a SettingBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a StandardWindow(725040896) named: Settings Brows...etc...
		announcer: 	an Announcer
		selection: 	nil
		rootItems: 	nil
		autoMultiSelection: 	nil
		headerLabel: 	nil
		multiSelection: 	nil
		wrapBlockOrSelector: 	nil
		isCheckList: 	nil
		enabled: 	nil
		viewedPackages: 	nil
		roots: 	nil
		status: 	nil
		searchedText: 	nil
		treeHolder: 	a SettingTree


SettingBrowser class>>open
	Receiver: SettingBrowser
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	MorphTreeModel
		methodDict: 	a MethodDictionary(#about->SettingBrowser>>#about #acceptableKeywor...etc...
		format: 	65551
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SettingBrowser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Settings-Browser'
		searchedTextList: 	nil
		regexpSearch: 	nil


[ SettingBrowser open ] in SettingBrowser class>>menuCommandOn:
	Receiver: SettingBrowser
	Arguments and temporary variables: 
		aBuilder: 	a PragmaMenuAndShortcutRegistratio
	Receiver's instance variables: 
		superclass: 	MorphTreeModel
		methodDict: 	a MethodDictionary(#about->SettingBrowser>>#about #acceptableKeywor...etc...
		format: 	65551
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SettingBrowser
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Settings-Browser'
		searchedTextList: 	nil
		regexpSearch: 	nil


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ SettingBrowser open ]
	Arguments and temporary variables: 
		anArg: 	a WorldStat
	Receiver's instance variables: 
		outerContext: 	SettingBrowser class>>menuCommandOn:
		startpc: 	a CompiledBlock: [ SettingBrowser open ]
		numArgs: 	0
		receiver: 	SettingBrowser


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		evt: 	[(53@32) mouseUp 274045 nil]
		w: 	a WorldMorph(838144) [world]
		selArgCount: 	
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(188268288)'Settings'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc..
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		evt: 	[(53@32) mouseUp 274045 nil]
		w: 	a WorldMorph(838144) [world
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		evt: 	[(53@32) mouseUp 274045 nil
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		anEvent: 	[(53@32) mouseUp 274045 nil
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(53@32) mouseUp 274045 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(188268288)'Settings
	Receiver's instance variables: 
		timeStamp: 	274045
		source: 	a HandMorph(498002432)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(53@32)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(188268288)'Settings'
	Arguments and temporary variables: 
		anEvent: 	[(53@32) mouseUp 274045 nil
	Receiver's instance variables: 
		bounds: 	(5.0@22.0) corner: (149.0@40.0)
		owner: 	a MenubarMenuMorph(727232000)
		submorphs: 	#()
		fullBounds: 	(5.0@22.0) corner: (149.0@40.0)
		color: 	Color black
		extension: 	a MorphExtension (490560256) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Settings'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	[ SettingBrowser open ]
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(16x16x32)
		keyText: 	'o, s'
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(53@32) mouseUp 274045 nil]
		aMorph: 	a ToggleMenuItemMorph(188268288)'Settings'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	tru
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(188268288)'Settings'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(53@32) mouseUp 274045 nil
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(188268288)'Settings'



--- The full stack ---
GRAnsiBooleansRule class(Object)>>doesNotUnderstand: #enabledSettingID
[ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] in [ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
OrderedCollection>>do:
[ 
			(self visibleRuleClasses sorted: [ :a :b | a name < b name ])
				do: [ :rule | 
					| inst |
					inst := rule new.
					(aBuilder setting: rule enabledSettingID)
					selector: #enabled;
					target: rule;
					default: rule enabled;
					label: inst name;
					description: inst rationale ] ] in ReRuleManager class>>ruleToggleSettingsOn:
SettingTreeBuilder>>parent:while:
SettingNodeBuilder>>asParentWhile:
SettingNodeBuilder>>with:
ReRuleManager class>>ruleToggleSettingsOn:
SettingTreeBuilder>>systemsettings
SettingTreeBuilder>>buildPragma:
[:p | builder buildPragma: p] in SettingTree>>nodeList
OrderedCollection>>do:
PragmaCollector>>do:
SettingTree>>pragmasDo:
SettingTree>>nodeList
SettingTree>>settingTreeRoots
SettingBrowser>>rootNodes
MorphTreeMorph>>getList
MorphTreeMorph>>nodeList
MorphTreeMorph>>buildContents
SettingBrowser>>treeMorphIn:
SettingBrowser>>buildWindowIn:
[ | window |window := StandardWindow new model: self.
			window title: self windowTitle.
			self buildWindowIn: window.
			window themeChanged.
			window openInWorld.
			(window findDeeplyA: self treeMorphClass)  takeKeyboardFocus. 
			^ window] in SettingBrowser>>open
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SettingBrowser>>open
SettingBrowser class>>open
[ SettingBrowser open ] in SettingBrowser class>>menuCommandOn:
FullBlockClosure(BlockClosure)>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: 
			(anEvent transformedBy: (focusHolder transformedFrom: self)).
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[:h |
		self activeHand: h.
		h processEvents.
		self activeHand: nil.
	] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Method protocol '*magritte-pharo-model' for the method 'magrittePharoModel' in class 'GRPackage' is inconsistent with the package name '*magritte-pharo20-model'
25 August 2020 5:27:19.24857 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

IceLibgitFiletreeReader(Object)>>error:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aString: 	'Method protocol ''*magritte-pharo-model'' for the method ''magrittePh...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateExtensionMethodCategory:for:selector:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		categoryName: 	'*magritte-pharo-model'
		className: 	'GRPackage'
		selector: 	#magrittePharoModel
		prefix: 	'*magritte-pharo20-model
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :fileStream | 
| category source timestamp selector |
category := fileStream nextLine.
source := fileStream upToEnd.
selector := self methodSelectorFor: source.
timestamp := methodProperties
	at:
		(classIsMeta
			ifTrue: [ 'class' ]
			ifFalse: [ 'instance' ])
	ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
timestamp
	ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
			, self info time print24 ].
extensionMethod
	ifTrue: [ self
			validateExtensionMethodCategory: category
			for: className
			selector: selector ].
definitions
	add:
		(MCMethodDefinition
			className: className
			classIsMeta: classIsMeta
			selector: selector
			category: category
			timeStamp: timestamp
			source: source) ] in [ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st')
		fileStream: 	a ReadStream
		category: 	'*magritte-pharo-model'
		source: 	'magrittePharoModel
	^ self new
		name: ''Magritte-Pharo-Model'';
		add...etc...
		timestamp: 	'CompatibleUserName 8/6/2020 03:30:13'
		selector: 	#magrittePharoMode
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


LGitTreeEntry>>readStreamDo:
	Receiver: a LGitTreeEntry ('magrittePharoModel.st')
	Arguments and temporary variables: 
		aBlock: 	[ :fileStream | 
| category source timestamp selector |
category := fil...etc..
	Receiver's instance variables: 
		handle: 	(void*)@ 16r7FFD8A656AD0
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		parent: 	a LGitTree (number of entries: 1)


[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('magrittePharoModel.st'))
	Arguments and temporary variables: 
		aBlock: 	[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| categ...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('magrittePharoModel.st'))

[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addExtensionClassAndMethodDefinitionsFromEntry:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		methodPropertiesDict: 	a Dictionary()
		classPropertiesDict: 	a Dictionary('name'->'GRPackage' )
		classEntry: 	a LGitTreeEntry ('GRPackage.extension')
		classDirectory: 	a LGitTree (number of entries: 2)
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.class')
	ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.extension')
	ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		entry: 	a LGitTreeEntry ('GRPackage.extension'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAnd...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		entries: 	an Array(a LGitTreeEntry ('categories.st') a LGitTreeEntry ('initializ...etc...
		directory: 	a LGitTreeEntry ('monticello.meta'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>definitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>snapshot
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>version
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)
		commit: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 83%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ IceVersionDoesNotExist new
	version: iceVersion;
	signal 
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>mcVersionFor:
		startpc: 	126
		numArgs: 	0


IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 83%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitCommit(IceCommitish)>>mcVersionFor:
	Receiver: IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
	Arguments and temporary variables: 
		anIceSavedPackageVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		id: 	'6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1'
		author: 	'Sean DeNigris'
		datetime: 	2020-08-06T03:30:13+02:00
		ancestorIds: 	#('1724c2e0707db8f940c1c9db85df56ae6f2bbf78' 'd40ec27103e85535214a...etc...
		comment: 	'Merge pull request #154 from seandenigris/bug_metacello-invert-depend...etc...


IceSavedPackageVersion>>mcVersion
	Receiver: IceSavedPackageVersion(Magritte-Pharo20-Model)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		entry: 	nil
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


IceConvertFormatAction>>migratePackage:commit:
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		packageName: 	IcePackage(Magritte-Pharo20-Model, not loaded)
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		filetreePackage: 	nil
		srcDir: 	File @ /Users/norbert/work/projects/magritte/source
		subDirWithDelim: 	'source/'
		mcVersion: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


[ :each | self migratePackage: each commit: commit ] in IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		each: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self migratePackage: each commit: commit ]
		index: 	2
	Receiver's instance variables: 
an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...

IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


IceConvertFormatAction>>execute
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		oldBranch: 	IceGitLocalBranch(migrate-sources-to-tonel)
		newBranch: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


IceTipFiletreeToTonelDialog>>doAccept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-1'
		repository: 	IceLibgitRepository(magritte)


[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-1'
		repository: 	IceLibgitRepository(magritte)


[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


BlockClosure>>cull:
	Receiver: [ :bar | aBlock value: bar ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		startpc: 	58
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ activeProcess psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ activeProcess psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	79
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil



--- The full stack ---
IceLibgitFiletreeReader(Object)>>error:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateExtensionMethodCategory:for:selector:
[ :fileStream | 
| category source timestamp selector |
category := fileStream nextLine.
source := fileStream upToEnd.
selector := self methodSelectorFor: source.
timestamp := methodProperties
	at:
		(classIsMeta
			ifTrue: [ 'class' ]
			ifFalse: [ 'instance' ])
	ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
timestamp
	ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
			, self info time print24 ].
extensionMethod
	ifTrue: [ self
			validateExtensionMethodCategory: category
			for: className
			selector: selector ].
definitions
	add:
		(MCMethodDefinition
			className: className
			classIsMeta: classIsMeta
			selector: selector
			category: category
			timeStamp: timestamp
			source: source) ] in [ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
LGitTreeEntry>>readStreamDo:
[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
Array(SequenceableCollection)>>do:
[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
Array(SequenceableCollection)>>do:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addExtensionClassAndMethodDefinitionsFromEntry:
[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.class')
	ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.extension')
	ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
Array(SequenceableCollection)>>do:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
IceLibgitFiletreeReader(MCVersionReader)>>definitions
IceLibgitFiletreeReader(MCVersionReader)>>snapshot
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
IceLibgitFiletreeReader(MCVersionReader)>>version
[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
BlockClosure>>on:do:
IceLibgitRepository>>mcVersionFor:
IceGitCommit(IceCommitish)>>mcVersionFor:
IceSavedPackageVersion>>mcVersion
IceConvertFormatAction>>migratePackage:commit:
[ :each | self migratePackage: each commit: commit ] in IceConvertFormatAction>>migrateSources
Array(SequenceableCollection)>>do:
IceConvertFormatAction>>migrateSources
IceConvertFormatAction>>execute
IceTipFiletreeToTonelDialog>>doAccept
[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipFiletreeToTonelDialog>>accept
[ self accept ] in IceTipFiletreeToTonelDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Class category name 'Magritte-Pharo-Model' for the class 'MAExternalFileModel' is inconsistent with the package name 'Magritte-Pharo20-Model'
25 August 2020 5:29:07.496789 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

IceLibgitFiletreeReader(Object)>>error:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aString: 	'Class category name ''Magritte-Pharo-Model'' for the class ''MAExtern...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateClassCategory:for:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		categoryName: 	'Magritte-Pharo-Model'
		className: 	'MAExternalFileModel'
		prefix: 	'Magritte-Pharo20-Model
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassDefinitionFrom:comment:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		classPropertiesDict: 	a Dictionary('category'->'Magritte-Pharo-Model' 'classinst...etc...
		classComment: 	'I manage the file-data I represent on the file-system. From the ...etc...
		categoryName: 	'Magritte-Pharo-Model'
		className: 	'MAExternalFileModel
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromEntry:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		methodPropertiesDict: 	a Dictionary()
		classComment: 	'I manage the file-data I represent on the file-system. From the ...etc...
		classPropertiesDict: 	a Dictionary('category'->'Magritte-Pharo-Model' 'classinst...etc...
		classEntry: 	a LGitTreeEntry ('MAExternalFileModel.class')
		classDirectory: 	a LGitTree (number of entries: 4)
		entries: 	an Array(a LGitTreeEntry ('README.md') a LGitTreeEntry ('class') a LGi...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.class')
	ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.extension')
	ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		entry: 	a LGitTreeEntry ('MAExternalFileModel.class'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAnd...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		entries: 	an Array(a LGitTreeEntry ('categories.st') a LGitTreeEntry ('initializ...etc...
		directory: 	a LGitTreeEntry ('monticello.meta'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>definitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>snapshot
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>version
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)
		commit: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 83%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ IceVersionDoesNotExist new
	version: iceVersion;
	signal 
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>mcVersionFor:
		startpc: 	126
		numArgs: 	0


IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 83%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitCommit(IceCommitish)>>mcVersionFor:
	Receiver: IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
	Arguments and temporary variables: 
		anIceSavedPackageVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		id: 	'6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1'
		author: 	'Sean DeNigris'
		datetime: 	2020-08-06T03:30:13+02:00
		ancestorIds: 	#('1724c2e0707db8f940c1c9db85df56ae6f2bbf78' 'd40ec27103e85535214a...etc...
		comment: 	'Merge pull request #154 from seandenigris/bug_metacello-invert-depend...etc...


IceSavedPackageVersion>>mcVersion
	Receiver: IceSavedPackageVersion(Magritte-Pharo20-Model)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		entry: 	nil
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


IceConvertFormatAction>>migratePackage:commit:
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		packageName: 	IcePackage(Magritte-Pharo20-Model, not loaded)
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		filetreePackage: 	nil
		srcDir: 	File @ /Users/norbert/work/projects/magritte/source
		subDirWithDelim: 	'source/'
		mcVersion: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


[ :each | self migratePackage: each commit: commit ] in IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		each: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


Array(SequenceableCollection)>>do:
	Receiver: an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self migratePackage: each commit: commit ]
		index: 	2
	Receiver's instance variables: 
an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...

IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


IceConvertFormatAction>>execute
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		oldBranch: 	IceGitLocalBranch(migrate-sources-to-tonel)
		newBranch: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	true


IceTipFiletreeToTonelDialog>>doAccept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-1'
		repository: 	IceLibgitRepository(magritte)


[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-1'
		repository: 	IceLibgitRepository(magritte)


[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


BlockClosure>>cull:
	Receiver: [ :bar | aBlock value: bar ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		startpc: 	58
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ activeProcess psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ activeProcess psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	79
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	77
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	true
		parent: 	nil
		process: 	a Process in nil


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[ :bar | aBlock value: bar 
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value 
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept 
	Receiver's instance variables: 
		activeTranscript: 	nil


IceTipStandardAction>>basicExecute
	Receiver: an IceTipStandardAction
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		successBlock: 	[ UIManager default inform: 'Sources migrated!' ]
		message: 	'Migrating magritte sources to tonel'
		successAnnounceBlock: 	[ IceRepositoryModified for: self repository ]
		actionBlock: 	[ self doAccept ]



--- The full stack ---
IceLibgitFiletreeReader(Object)>>error:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateClassCategory:for:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassDefinitionFrom:comment:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromEntry:
[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.class')
	ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.extension')
	ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
Array(SequenceableCollection)>>do:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
IceLibgitFiletreeReader(MCVersionReader)>>definitions
IceLibgitFiletreeReader(MCVersionReader)>>snapshot
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
IceLibgitFiletreeReader(MCVersionReader)>>version
[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
BlockClosure>>on:do:
IceLibgitRepository>>mcVersionFor:
IceGitCommit(IceCommitish)>>mcVersionFor:
IceSavedPackageVersion>>mcVersion
IceConvertFormatAction>>migratePackage:commit:
[ :each | self migratePackage: each commit: commit ] in IceConvertFormatAction>>migrateSources
Array(SequenceableCollection)>>do:
IceConvertFormatAction>>migrateSources
IceConvertFormatAction>>execute
IceTipFiletreeToTonelDialog>>doAccept
[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipFiletreeToTonelDialog>>accept
[ self accept ] in IceTipFiletreeToTonelDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Module not found.
25 August 2020 5:32:18.06464 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

LGitLibrary(Object)>>error:
	Receiver: a LGitLibrary
	Arguments and temporary variables: 
		aString: 	'Module not found.
	Receiver's instance variables: 
		initialized: 	true


LGitLibrary>>macModuleName
	Receiver: a LGitLibrary
	Arguments and temporary variables: 
		pluginDir: 	{vmBinary}//Users/norbert/work/projects/magritte/pharo-vm/Pharo.app/...etc..
	Receiver's instance variables: 
		initialized: 	true


LGitLibrary(FFILibrary)>>macLibraryName
	Receiver: a LGitLibrary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		initialized: 	true


MacOSXPlatform(MacOSPlatform)>>ffiLibraryName:
	Receiver: a MacOSXPlatform
	Arguments and temporary variables: 
		aLibrary: 	a LGitLibrar
	Receiver's instance variables: 
a MacOSXPlatform

LGitLibrary(FFILibrary)>>libraryName
	Receiver: a LGitLibrary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		initialized: 	true


LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>libraryName
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>createFFICalloutLiteralFromSpec:
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 
		functionSpec: 	a FFIFunctionSpec
		externalFunction: 	ni
	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generateFFICallout:spec:
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 
		builder: 	an IRBuilder
		functionSpec: 	a FFIFunctionSpec
		properties: 	an AdditionalMethodState (51044608
	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


LGitSafeFFICalloutMethodBuilder>>generateFFICallout:spec:
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 
		builder: 	an IRBuilder
		functionSpec: 	a FFIFunctionSpe
	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


[ :builder | self generateFFICallout: builder spec: functionSpec ] in LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generateMethodFromSpec:
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 
		functionSpec: 	a FFIFunctionSpec
		ir: 	nil
		builder: 	an IRBuilde
	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


IRBuilder class>>buildIR:
	Receiver: IRBuilder
	Arguments and temporary variables: 
		aBlock: 	[ :builder | self generateFFICallout: builder spec: functionSpec 
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#add:->IRBuilder>>#add: #addBlockReturnTopIfRequ...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{IRReconstructor}
		name: 	#IRBuilder
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-IR-Manipulation'


LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generateMethodFromSpec:
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 
		functionSpec: 	a FFIFunctionSpec
		ir: 	ni
	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generate
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>build:
	Receiver: a LGitSafeFFICalloutMethodBuilder
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	signature: functionSignature;
	sender: sender;
	...etc..
	Receiver's instance variables: 
		calloutAPI: 	a LGitSafeFFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		signature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallba...etc...
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	LGitLibrary


LGitSafeFFICalloutAPI(FFICalloutAPI)>>function:library:
	Receiver: a LGitSafeFFICalloutAPI
	Arguments and temporary variables: 
		functionSignature: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemo...etc...
		moduleNameOrLibrary: 	LGitLibrary
		sender: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		ffiMethod: 	nil
		ffiMethodSelector: 	#call:options
	Receiver's instance variables: 
		options: 	#()
		callingConvention: 	#cdecl
		senderContext: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		uFFIEntryPointContext: 	nil


LGitSafeFFICalloutAPI(FFICalloutAPI)>>function:module:
	Receiver: a LGitSafeFFICalloutAPI
	Arguments and temporary variables: 
		aCollection: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCall...etc...
		aClass: 	LGitLibrar
	Receiver's instance variables: 
		options: 	#()
		callingConvention: 	#cdecl
		senderContext: 	LGitRemoteCallbacks>>remote_init_callbacks:version:
		uFFIEntryPointContext: 	nil


LGitRemoteCallbacks(LGitExternalStructure)>>call:options:
	Receiver: a LGitRemoteCallbacks ()
	Arguments and temporary variables: 
		fnSpec: 	#(#LGitReturnCodeEnum #git_remote_init_callbacks #(#LGitRemoteCallbacks...etc...
		options: 	#(
	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF3C0
		credentialsCallback: 	nil
		certificateCheckCallback: 	nil
		transferProgressCallback: 	nil
		pushTransferProgress: 	nil


LGitRemoteCallbacks>>remote_init_callbacks:version:
	Receiver: a LGitRemoteCallbacks ()
	Arguments and temporary variables: 
		opts: 	a LGitRemoteCallbacks ()
		version: 	a LGitStructVersionsEnum(#git_remote_callbacks_version_1 [1]
	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF3C0
		credentialsCallback: 	nil
		certificateCheckCallback: 	nil
		transferProgressCallback: 	nil
		pushTransferProgress: 	nil


[ self
	remote_init_callbacks: self
	version: LGitStructVersionsEnum git_remote_callbacks_version_1 ] in LGitRemoteCallbacks>>initializeWithDefaults
	Receiver: a LGitRemoteCallbacks ()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF3C0
		credentialsCallback: 	nil
		certificateCheckCallback: 	nil
		transferProgressCallback: 	nil
		pushTransferProgress: 	nil


LGitRemoteCallbacks(LGitExternalStructure)>>withReturnHandlerDo:
	Receiver: a LGitRemoteCallbacks ()
	Arguments and temporary variables: 
		callBlock: 	[ self
	remote_init_callbacks: self
	version: LGitStructVersionsEnum...etc..
	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF3C0
		credentialsCallback: 	nil
		certificateCheckCallback: 	nil
		transferProgressCallback: 	nil
		pushTransferProgress: 	nil


LGitRemoteCallbacks>>initializeWithDefaults
	Receiver: a LGitRemoteCallbacks ()
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF3C0
		credentialsCallback: 	nil
		certificateCheckCallback: 	nil
		transferProgressCallback: 	nil
		pushTransferProgress: 	nil


LGitRemoteCallbacks class(LGitStructWithDefaults class)>>defaults
	Receiver: LGitRemoteCallbacks
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	LGitStructWithDefaults
		methodDict: 	a MethodDictionary(#certificateCheck:->LGitRemoteCallbacks>>#certif...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#LGitRemoteCallbacks
		classPool: 	a Dictionary(#OFFSET_PRIM_CERTIFICATE_CHECK->33 #OFFSET_PRIM_COMPLET...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-FFI-Structs'
		compiledSpec: 	a WordArray(65640 100925444 393224 393224 393224 393224 393224 39...etc...
		externalStructureAlignment: 	8


LGitRemoteCallbacks class>>defaults
	Receiver: LGitRemoteCallbacks
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	LGitStructWithDefaults
		methodDict: 	a MethodDictionary(#certificateCheck:->LGitRemoteCallbacks>>#certif...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#LGitRemoteCallbacks
		classPool: 	a Dictionary(#OFFSET_PRIM_CERTIFICATE_CHECK->33 #OFFSET_PRIM_COMPLET...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-FFI-Structs'
		compiledSpec: 	a WordArray(65640 100925444 393224 393224 393224 393224 393224 39...etc...
		externalStructureAlignment: 	8


LGitRemoteCallbacks class>>withProvider:
	Receiver: LGitRemoteCallbacks
	Arguments and temporary variables: 
		provider: 	an IceTipInteractiveCredentialsProvide
	Receiver's instance variables: 
		superclass: 	LGitStructWithDefaults
		methodDict: 	a MethodDictionary(#certificateCheck:->LGitRemoteCallbacks>>#certif...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#LGitRemoteCallbacks
		classPool: 	a Dictionary(#OFFSET_PRIM_CERTIFICATE_CHECK->33 #OFFSET_PRIM_COMPLET...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-FFI-Structs'
		compiledSpec: 	a WordArray(65640 100925444 393224 393224 393224 393224 393224 39...etc...
		externalStructureAlignment: 	8


[ callbacks := LGitRemoteCallbacks withProvider: aCredentialsProvider.
progressCallback
	ifNotNil: [ callbacks transferProgress: progressCallback ].
self
	remote_fetch: self
	refspecs: refSpecs
	opts:
		(LGitFetchOptions defaults
			callbacks: callbacks;
			yourself)
	reflog_message: nil ] in LGitRemote>>fetchWithCredentials:andProgressCallback:refSpec:
	Receiver: a LGitRemote (origin)
	Arguments and temporary variables: 
		aCredentialsProvider: 	an IceTipInteractiveCredentialsProvider
		progressCallback: 	an IceGitTransferProgress
		aRefSpec: 	nil
		refSpecs: 	nil
		callbacks: 	ni
	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF1C0
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		remoteName: 	'origin'
		url: 	'git@github.com:magritte-metamodel/magritte.git'
		fetchSpec: 	nil


LGitRemote(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitRemote (origin)
	Arguments and temporary variables: 
		callBlock: 	[ callbacks := LGitRemoteCallbacks withProvider: aCredentialsProvide...etc..
	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF1C0
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		remoteName: 	'origin'
		url: 	'git@github.com:magritte-metamodel/magritte.git'
		fetchSpec: 	nil


LGitRemote>>fetchWithCredentials:andProgressCallback:refSpec:
	Receiver: a LGitRemote (origin)
	Arguments and temporary variables: 
		callbacks: 	nil
		aCredentialsProvider: 	an IceTipInteractiveCredentialsProvider
		progressCallback: 	an IceGitTransferProgress
		aRefSpec: 	nil
		refSpecs: 	ni
	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF1C0
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		remoteName: 	'origin'
		url: 	'git@github.com:magritte-metamodel/magritte.git'
		fetchSpec: 	nil


LGitRemote>>fetchWithCredentials:andProgressCallback:
	Receiver: a LGitRemote (origin)
	Arguments and temporary variables: 
		aCredentialsProvider: 	an IceTipInteractiveCredentialsProvider
		progressCallback: 	an IceGitTransferProgres
	Receiver's instance variables: 
		handle: 	@ 16r7FFD8A9BF1C0
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		remoteName: 	'origin'
		url: 	'git@github.com:magritte-metamodel/magritte.git'
		fetchSpec: 	nil


[ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self)
		andProgressCallback: IceGitTransferProgress new ] in [ [ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self)
		andProgressCallback: IceGitTransferProgress new ]
	on: LGitAbstractError
	do: [ :e | e acceptError: (IceLibgitErrorVisitor onContext: self) ].

"Call post fetch to fix unknown commits"
localRepository postFetch ] in IceGitScpRemote(IceGitRemote)>>fetch
	Receiver: origin (git@github.com:magritte-metamodel/magritte.git)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		url: 	'git@github.com:magritte-metamodel/magritte.git'
		projectName: 	'magritte'
		name: 	'origin'
		localRepository: 	IceLibgitRepository(magritte)
		user: 	'git'
		host: 	'github.com'
		port: 	nil
		path: 	#()
		owner: 	'magritte-metamodel'


BlockClosure>>on:do:
	Receiver: [ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials: ...etc...
	Arguments and temporary variables: 
		exception: 	LGitAbstractError
		handlerAction: 	[ :e | e acceptError: (IceLibgitErrorVisitor onContext: self) 
	Receiver's instance variables: 
		outerContext: 	[ [ (LGitRemote of: self repositoryHandle named: self name)
	look...etc...
		startpc: 	162
		numArgs: 	0


[ [ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self)
		andProgressCallback: IceGitTransferProgress new ]
	on: LGitAbstractError
	do: [ :e | e acceptError: (IceLibgitErrorVisitor onContext: self) ].

"Call post fetch to fix unknown commits"
localRepository postFetch ] in IceGitScpRemote(IceGitRemote)>>fetch
	Receiver: origin (git@github.com:magritte-metamodel/magritte.git)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		url: 	'git@github.com:magritte-metamodel/magritte.git'
		projectName: 	'magritte'
		name: 	'origin'
		localRepository: 	IceLibgitRepository(magritte)
		user: 	'git'
		host: 	'github.com'
		port: 	nil
		path: 	#()
		owner: 	'magritte-metamodel'


BlockClosure>>on:do:
	Receiver: [ [ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials...etc...
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc..
	Receiver's instance variables: 
		outerContext: 	IceGitScpRemote(IceGitRemote)>>fetch
		startpc: 	158
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ [ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	f...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 0%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 94%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitScpRemote(IceGitRemote)>>fetch
	Receiver: origin (git@github.com:magritte-metamodel/magritte.git)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		url: 	'git@github.com:magritte-metamodel/magritte.git'
		projectName: 	'magritte'
		name: 	'origin'
		localRepository: 	IceLibgitRepository(magritte)
		user: 	'git'
		host: 	'github.com'
		port: 	nil
		path: 	#()
		owner: 	'magritte-metamodel'


[ :each | each fetch ] in IceLibgitRepository(IceRepository)>>fetch
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		each: 	origin (git@github.com:magritte-metamodel/magritte.git
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 0%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 94%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


[ :each | 
| newLabel |
"Special handling for first and last element"
(count = 0
	or: [ count + 1 = size
			or: [ (Time millisecondsSince: lastUpdate) >= msecs ] ])
	ifTrue: [ bar current: count.
		oldLabel = (newLabel := (labelBlock cull: each) ifNil: [ oldLabel ])
			ifFalse: [ bar label: newLabel.
				oldLabel := newLabel ].
		lastUpdate := Time millisecondClockValue ].
aBlock value: each.
count := count + 1 ] in [ :bar | 
labelBlock := aStringOrBlock isString
	ifTrue: [ bar label: aStringOrBlock.
		[ :dummyItem | aStringOrBlock ] ]
	ifFalse: [ aStringOrBlock ].
self
	do: [ :each | 
		| newLabel |
		"Special handling for first and last element"
		(count = 0
			or: [ count + 1 = size
					or: [ (Time millisecondsSince: lastUpdate) >= msecs ] ])
			ifTrue: [ bar current: count.
				oldLabel
					= (newLabel := (labelBlock cull: each) ifNil: [ oldLabel ])
					ifFalse: [ bar label: newLabel.
						oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
		aBlock value: each.
		count := count + 1 ] ] in Array(Collection)>>do:displayingProgress:every:
	Receiver: an Array(origin (git@github.com:magritte-metamodel/magritte.git))
	Arguments and temporary variables: 
		aBlock: 	[ :each | each fetch ]
		aStringOrBlock: 	[ :each | 'Remote: ' , each name asString ]
		msecs: 	20
		size: 	1
		bar: 	a Job
		count: 	0
		labelBlock: 	[ :each | 'Remote: ' , each name asString ]
		oldLabel: 	'Remote: origin'
		lastUpdate: 	330046
		each: 	origin (git@github.com:magritte-metamodel/magritte.git)
		newLabel: 	'Remote: origin
	Receiver's instance variables: 
an Array(origin (git@github.com:magritte-metamodel/magritte.git))

Array(SequenceableCollection)>>do:
	Receiver: an Array(origin (git@github.com:magritte-metamodel/magritte.git))
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
| newLabel |
"Special handling for first and last element"
(...etc...
		index: 	
	Receiver's instance variables: 
an Array(origin (git@github.com:magritte-metamodel/magritte.git))

[ :bar | 
labelBlock := aStringOrBlock isString
	ifTrue: [ bar label: aStringOrBlock.
		[ :dummyItem | aStringOrBlock ] ]
	ifFalse: [ aStringOrBlock ].
self
	do: [ :each | 
		| newLabel |
		"Special handling for first and last element"
		(count = 0
			or: [ count + 1 = size
					or: [ (Time millisecondsSince: lastUpdate) >= msecs ] ])
			ifTrue: [ bar current: count.
				oldLabel
					= (newLabel := (labelBlock cull: each) ifNil: [ oldLabel ])
					ifFalse: [ bar label: newLabel.
						oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
		aBlock value: each.
		count := count + 1 ] ] in Array(Collection)>>do:displayingProgress:every:
	Receiver: an Array(origin (git@github.com:magritte-metamodel/magritte.git))
	Arguments and temporary variables: 
		aBlock: 	[ :each | each fetch ]
		aStringOrBlock: 	[ :each | 'Remote: ' , each name asString ]
		msecs: 	20
		size: 	1
		count: 	0
		labelBlock: 	[ :each | 'Remote: ' , each name asString ]
		oldLabel: 	'Remote: origin'
		lastUpdate: 	330046
		bar: 	a Jo
	Receiver's instance variables: 
an Array(origin (git@github.com:magritte-metamodel/magritte.git))

BlockClosure>>cull:
	Receiver: [ :bar | 
labelBlock := aStringOrBlock isString
	ifTrue: [ bar label: aStringOrBlock.
		[ ...etc...
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	Array(Collection)>>do:displayingProgress:every:
		startpc: 	178
		numArgs: 	1



--- The full stack ---
LGitLibrary(Object)>>error:
LGitLibrary>>macModuleName
LGitLibrary(FFILibrary)>>macLibraryName
MacOSXPlatform(MacOSPlatform)>>ffiLibraryName:
LGitLibrary(FFILibrary)>>libraryName
LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>libraryName
LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>createFFICalloutLiteralFromSpec:
LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generateFFICallout:spec:
LGitSafeFFICalloutMethodBuilder>>generateFFICallout:spec:
[ :builder | self generateFFICallout: builder spec: functionSpec ] in LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generateMethodFromSpec:
IRBuilder class>>buildIR:
LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generateMethodFromSpec:
LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>generate
LGitSafeFFICalloutMethodBuilder(FFICalloutMethodBuilder)>>build:
LGitSafeFFICalloutAPI(FFICalloutAPI)>>function:library:
LGitSafeFFICalloutAPI(FFICalloutAPI)>>function:module:
LGitRemoteCallbacks(LGitExternalStructure)>>call:options:
LGitRemoteCallbacks>>remote_init_callbacks:version:
[ self
	remote_init_callbacks: self
	version: LGitStructVersionsEnum git_remote_callbacks_version_1 ] in LGitRemoteCallbacks>>initializeWithDefaults
LGitRemoteCallbacks(LGitExternalStructure)>>withReturnHandlerDo:
LGitRemoteCallbacks>>initializeWithDefaults
LGitRemoteCallbacks class(LGitStructWithDefaults class)>>defaults
LGitRemoteCallbacks class>>defaults
LGitRemoteCallbacks class>>withProvider:
[ callbacks := LGitRemoteCallbacks withProvider: aCredentialsProvider.
progressCallback
	ifNotNil: [ callbacks transferProgress: progressCallback ].
self
	remote_fetch: self
	refspecs: refSpecs
	opts:
		(LGitFetchOptions defaults
			callbacks: callbacks;
			yourself)
	reflog_message: nil ] in LGitRemote>>fetchWithCredentials:andProgressCallback:refSpec:
LGitRemote(LGitExternalObject)>>withReturnHandlerDo:
LGitRemote>>fetchWithCredentials:andProgressCallback:refSpec:
LGitRemote>>fetchWithCredentials:andProgressCallback:
[ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self)
		andProgressCallback: IceGitTransferProgress new ] in [ [ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self)
		andProgressCallback: IceGitTransferProgress new ]
	on: LGitAbstractError
	do: [ :e | e acceptError: (IceLibgitErrorVisitor onContext: self) ].

"Call post fetch to fix unknown commits"
localRepository postFetch ] in IceGitScpRemote(IceGitRemote)>>fetch
BlockClosure>>on:do:
[ [ (LGitRemote of: self repositoryHandle named: self name)
	lookup;
	fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self)
		andProgressCallback: IceGitTransferProgress new ]
	on: LGitAbstractError
	do: [ :e | e acceptError: (IceLibgitErrorVisitor onContext: self) ].

"Call post fetch to fix unknown commits"
localRepository postFetch ] in IceGitScpRemote(IceGitRemote)>>fetch
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitScpRemote(IceGitRemote)>>fetch
[ :each | each fetch ] in IceLibgitRepository(IceRepository)>>fetch
[ :each | 
| newLabel |
"Special handling for first and last element"
(count = 0
	or: [ count + 1 = size
			or: [ (Time millisecondsSince: lastUpdate) >= msecs ] ])
	ifTrue: [ bar current: count.
		oldLabel = (newLabel := (labelBlock cull: each) ifNil: [ oldLabel ])
			ifFalse: [ bar label: newLabel.
				oldLabel := newLabel ].
		lastUpdate := Time millisecondClockValue ].
aBlock value: each.
count := count + 1 ] in [ :bar | 
labelBlock := aStringOrBlock isString
	ifTrue: [ bar label: aStringOrBlock.
		[ :dummyItem | aStringOrBlock ] ]
	ifFalse: [ aStringOrBlock ].
self
	do: [ :each | 
		| newLabel |
		"Special handling for first and last element"
		(count = 0
			or: [ count + 1 = size
					or: [ (Time millisecondsSince: lastUpdate) >= msecs ] ])
			ifTrue: [ bar current: count.
				oldLabel
					= (newLabel := (labelBlock cull: each) ifNil: [ oldLabel ])
					ifFalse: [ bar label: newLabel.
						oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
		aBlock value: each.
		count := count + 1 ] ] in Array(Collection)>>do:displayingProgress:every:
Array(SequenceableCollection)>>do:
[ :bar | 
labelBlock := aStringOrBlock isString
	ifTrue: [ bar label: aStringOrBlock.
		[ :dummyItem | aStringOrBlock ] ]
	ifFalse: [ aStringOrBlock ].
self
	do: [ :each | 
		| newLabel |
		"Special handling for first and last element"
		(count = 0
			or: [ count + 1 = size
					or: [ (Time millisecondsSince: lastUpdate) >= msecs ] ])
			ifTrue: [ bar current: count.
				oldLabel
					= (newLabel := (labelBlock cull: each) ifNil: [ oldLabel ])
					ifFalse: [ bar label: newLabel.
						oldLabel := newLabel ].
				lastUpdate := Time millisecondClockValue ].
		aBlock value: each.
		count := count + 1 ] ] in Array(Collection)>>do:displayingProgress:every:
BlockClosure>>cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
ByteString(String)>>displayProgressFrom:to:during:
Array(Collection)>>do:displayingProgress:every:
Array(Collection)>>do:displayingProgress:
IceLibgitRepository(IceRepository)>>fetch
[ self entity fetch ] in IceTipRepositoryModel>>fetch
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipRepositoryModel>>fetch
IceTipCachedModel>>forwardMessage:
IceTipCachedModel>>doesNotUnderstand: #fetch
IceTipFetchCommand>>execute
IceTipWorkingCopyContext(CmdToolContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ self executeCommand ] in CmdCommandActivator>>buildIceToolbarItem
BlockClosure>>cull:
IceTipToolbarItem>>execute
IceTipToolbarItemButtonMorph(PluggableButtonMorph)>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in IceTipToolbarItemButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
IceTipToolbarItemButtonMorph(PluggableButtonMorph)>>mouseUp:
IceTipToolbarItemButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IceTipToolbarItemButtonMorph(Morph)>>handleEvent:
IceTipToolbarItemButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Module not found.
25 August 2020 5:32:28.732295 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

LGitLibrary(Object)>>error:
	Receiver: a LGitLibrary
	Arguments and temporary variables: 
		aString: 	'Module not found.
	Receiver's instance variables: 
		initialized: 	true


LGitLibrary>>macModuleName
	Receiver: a LGitLibrary
	Arguments and temporary variables: 
		pluginDir: 	{vmBinary}//Users/norbert/work/projects/magritte/pharo-vm/Pharo.app/...etc..
	Receiver's instance variables: 
		initialized: 	true


LGitLibrary(FFILibrary)>>macLibraryName
	Receiver: a LGitLibrary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		initialized: 	true


MacOSXPlatform(MacOSPlatform)>>ffiLibraryName:
	Receiver: a MacOSXPlatform
	Arguments and temporary variables: 
		aLibrary: 	a LGitLibrar
	Receiver's instance variables: 
a MacOSXPlatform

LGitLibrary(FFILibrary)>>libraryName
	Receiver: a LGitLibrary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		initialized: 	true


FFICalloutMethodBuilder>>libraryName
	Receiver: a FFICalloutMethodBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		calloutAPI: 	a FFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitLibrary>>libgit2_shutdown
		signature: 	#(#int #git_libgit2_shutdown #())
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	a LGitLibrary


FFICalloutMethodBuilder>>createFFICalloutLiteralFromSpec:
	Receiver: a FFICalloutMethodBuilder
	Arguments and temporary variables: 
		functionSpec: 	a FFIFunctionSpec
		externalFunction: 	ni
	Receiver's instance variables: 
		calloutAPI: 	a FFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitLibrary>>libgit2_shutdown
		signature: 	#(#int #git_libgit2_shutdown #())
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	a LGitLibrary


FFICalloutMethodBuilder>>generateFFICallout:spec:
	Receiver: a FFICalloutMethodBuilder
	Arguments and temporary variables: 
		builder: 	an IRBuilder
		functionSpec: 	a FFIFunctionSpec
		properties: 	an AdditionalMethodState (569130240
	Receiver's instance variables: 
		calloutAPI: 	a FFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitLibrary>>libgit2_shutdown
		signature: 	#(#int #git_libgit2_shutdown #())
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	a LGitLibrary


[ :builder | self generateFFICallout: builder spec: functionSpec ] in FFICalloutMethodBuilder>>generateMethodFromSpec:
	Receiver: a FFICalloutMethodBuilder
	Arguments and temporary variables: 
		functionSpec: 	a FFIFunctionSpec
		ir: 	nil
		builder: 	an IRBuilde
	Receiver's instance variables: 
		calloutAPI: 	a FFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitLibrary>>libgit2_shutdown
		signature: 	#(#int #git_libgit2_shutdown #())
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	a LGitLibrary


IRBuilder class>>buildIR:
	Receiver: IRBuilder
	Arguments and temporary variables: 
		aBlock: 	[ :builder | self generateFFICallout: builder spec: functionSpec 
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#add:->IRBuilder>>#add: #addBlockReturnTopIfRequ...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{IRReconstructor}
		name: 	#IRBuilder
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OpalCompiler-Core-IR-Manipulation'


FFICalloutMethodBuilder>>generateMethodFromSpec:
	Receiver: a FFICalloutMethodBuilder
	Arguments and temporary variables: 
		functionSpec: 	a FFIFunctionSpec
		ir: 	ni
	Receiver's instance variables: 
		calloutAPI: 	a FFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitLibrary>>libgit2_shutdown
		signature: 	#(#int #git_libgit2_shutdown #())
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	a LGitLibrary


FFICalloutMethodBuilder>>generate
	Receiver: a FFICalloutMethodBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		calloutAPI: 	a FFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitLibrary>>libgit2_shutdown
		signature: 	#(#int #git_libgit2_shutdown #())
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	a LGitLibrary


FFICalloutMethodBuilder>>build:
	Receiver: a FFICalloutMethodBuilder
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	signature: functionSignature;
	sender: sender;
	...etc..
	Receiver's instance variables: 
		calloutAPI: 	a FFICalloutAPI
		requestor: 	a FFICallout
		sender: 	LGitLibrary>>libgit2_shutdown
		signature: 	#(#int #git_libgit2_shutdown #())
		functionResolutionStrategies: 	an OrderedCollection(a FFICallbackFunctionResolut...etc...
		library: 	a LGitLibrary


FFICalloutAPI>>function:library:
	Receiver: a FFICalloutAPI
	Arguments and temporary variables: 
		functionSignature: 	#(#int #git_libgit2_shutdown #())
		moduleNameOrLibrary: 	a LGitLibrary
		sender: 	LGitLibrary>>libgit2_shutdown
		ffiMethod: 	nil
		ffiMethodSelector: 	#ffiCall
	Receiver's instance variables: 
		options: 	#()
		callingConvention: 	#cdecl
		senderContext: 	nil
		uFFIEntryPointContext: 	LGitLibrary(Object)>>ffiCall:library:options:


LGitLibrary(Object)>>ffiCall:library:options:
	Receiver: a LGitLibrary
	Arguments and temporary variables: 
		fnSpec: 	#(#int #git_libgit2_shutdown #())
		aLibrary: 	a LGitLibrary
		callOptions: 	#()
		ffiLibrary: 	a LGitLibrar
	Receiver's instance variables: 
		initialized: 	true


LGitLibrary(Object)>>ffiCall:library:
	Receiver: a LGitLibrary
	Arguments and temporary variables: 
		fnSpec: 	#(#int #git_libgit2_shutdown #())
		aLibrary: 	a LGitLibrar
	Receiver's instance variables: 
		initialized: 	true


LGitLibrary(Object)>>ffiCall:
	Receiver: a LGitLibrary
	Arguments and temporary variables: 
		fnSpec: 	#(#int #git_libgit2_shutdown #()
	Receiver's instance variables: 
		initialized: 	true


LGitLibrary>>libgit2_shutdown
	Receiver: a LGitLibrary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		initialized: 	true


[ self isInitialized
	ifTrue: [ self libgit2_shutdown ] ] in LGitLibrary>>shutdownLibGit2
	Receiver: a LGitLibrary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		initialized: 	true


BlockClosure>>ensure:
	Receiver: [ self isInitialized
	ifTrue: [ self libgit2_shutdown ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self forgetInitializationState ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	LGitLibrary>>shutdownLibGit2
		startpc: 	69
		numArgs: 	0


LGitLibrary>>shutdownLibGit2
	Receiver: a LGitLibrary
	Arguments and temporary variables: 

	Receiver's instance variables: 
		initialized: 	true


LGitLibrary class>>shutDown:
	Receiver: LGitLibrary
	Arguments and temporary variables: 
		quitting: 	tru
	Receiver's instance variables: 
		superclass: 	FFILibrary
		methodDict: 	a MethodDictionary(#forgetInitializationState->LGitLibrary>>#forget...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitLibrary
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-FFI-Handling'
		uniqueInstance: 	a LGitLibrary


ClassSessionHandler>>shutdown:
	Receiver: a ClassSessionHandler(LGitLibrary)
	Arguments and temporary variables: 
		isImageQuitting: 	tru
	Receiver's instance variables: 
		registeredClassName: 	#LGitLibrary


[ :each | each shutdown: isImageQuitting ] in WorkingSession>>runShutdown:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageQuitting: 	true
		each: 	a ClassSessionHandler(LGitLibrary
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2020-08-25T17:26:48.817117+02:00
		properties: 	a Dictionary(#accessMode->#readWrite )


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(an UIManagerSessionHandler(UIManagerSessionHandler) a ClassSess...etc...
		aBlock: 	[ :each | each shutdown: isImageQuitting ]
		each: 	a ClassSessionHandler(LGitLibrary
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2020-08-25T17:26:48.817117+02:00
		properties: 	a Dictionary(#accessMode->#readWrite )


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error 
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	69
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(an UIManagerSessionHandler(UIManagerSessionHandler) a ClassSess...etc...
		aBlock: 	[ :each | each shutdown: isImageQuitting ]
		each: 	a ClassSessionHandler(LGitLibrary
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2020-08-25T17:26:48.817117+02:00
		properties: 	a Dictionary(#accessMode->#readWrite )


Array(SequenceableCollection)>>do:
	Receiver: an Array(an UIManagerSessionHandler(UIManagerSessionHandler) a ClassSessionHandler(LGitLib...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	
	Receiver's instance variables: 
an Array(an UIManagerSessionHandler(UIManagerSessionHandler) a ClassSessionHandler(LGitLib...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(an UIManagerSessionHandler(UIManagerSessionHandler) a ClassSess...etc...
		aBlock: 	[ :each | each shutdown: isImageQuitting 
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2020-08-25T17:26:48.817117+02:00
		properties: 	a Dictionary(#accessMode->#readWrite )


WorkingSession>>runShutdown:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageQuitting: 	tru
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2020-08-25T17:26:48.817117+02:00
		properties: 	a Dictionary(#accessMode->#readWrite )


WorkingSession>>stop:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageQuitting: 	tru
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2020-08-25T17:26:48.817117+02:00
		properties: 	a Dictionary(#accessMode->#readWrite )


SessionManager>>launchSnapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		isImageStarting: 	nil
		snapshotResult: 	ni
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ isImageStarting := self launchSnapshot: save andQuit: quit.
wait signal ] in SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	false
		quit: 	true
		wait: 	a Semaphore()
		isImageStarting: 	ni
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ isImageStarting := self launchSnapshot: save andQuit: quit.
wait signal ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	SessionManager>>snapshot:andQuit:
		startpc: 	135
		numArgs: 	0



--- The full stack ---
LGitLibrary(Object)>>error:
LGitLibrary>>macModuleName
LGitLibrary(FFILibrary)>>macLibraryName
MacOSXPlatform(MacOSPlatform)>>ffiLibraryName:
LGitLibrary(FFILibrary)>>libraryName
FFICalloutMethodBuilder>>libraryName
FFICalloutMethodBuilder>>createFFICalloutLiteralFromSpec:
FFICalloutMethodBuilder>>generateFFICallout:spec:
[ :builder | self generateFFICallout: builder spec: functionSpec ] in FFICalloutMethodBuilder>>generateMethodFromSpec:
IRBuilder class>>buildIR:
FFICalloutMethodBuilder>>generateMethodFromSpec:
FFICalloutMethodBuilder>>generate
FFICalloutMethodBuilder>>build:
FFICalloutAPI>>function:library:
LGitLibrary(Object)>>ffiCall:library:options:
LGitLibrary(Object)>>ffiCall:library:
LGitLibrary(Object)>>ffiCall:
LGitLibrary>>libgit2_shutdown
[ self isInitialized
	ifTrue: [ self libgit2_shutdown ] ] in LGitLibrary>>shutdownLibGit2
BlockClosure>>ensure:
LGitLibrary>>shutdownLibGit2
LGitLibrary class>>shutDown:
ClassSessionHandler>>shutdown:
[ :each | each shutdown: isImageQuitting ] in WorkingSession>>runShutdown:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runShutdown:
WorkingSession>>stop:
SessionManager>>launchSnapshot:andQuit:
[ isImageStarting := self launchSnapshot: save andQuit: quit.
wait signal ] in SessionManager>>snapshot:andQuit:
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Method protocol '*magritte-pharo-model' for the method 'magrittePharoModel' in class 'GRPackage' is inconsistent with the package name '*magritte-pharo20-model'
25 August 2020 5:34:43.864693 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

IceLibgitFiletreeReader(Object)>>error:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aString: 	'Method protocol ''*magritte-pharo-model'' for the method ''magrittePh...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateExtensionMethodCategory:for:selector:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		categoryName: 	'*magritte-pharo-model'
		className: 	'GRPackage'
		selector: 	#magrittePharoModel
		prefix: 	'*magritte-pharo20-model
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :fileStream | 
| category source timestamp selector |
category := fileStream nextLine.
source := fileStream upToEnd.
selector := self methodSelectorFor: source.
timestamp := methodProperties
	at:
		(classIsMeta
			ifTrue: [ 'class' ]
			ifFalse: [ 'instance' ])
	ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
timestamp
	ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
			, self info time print24 ].
extensionMethod
	ifTrue: [ self
			validateExtensionMethodCategory: category
			for: className
			selector: selector ].
definitions
	add:
		(MCMethodDefinition
			className: className
			classIsMeta: classIsMeta
			selector: selector
			category: category
			timeStamp: timestamp
			source: source) ] in [ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st')
		fileStream: 	a ReadStream
		category: 	'*magritte-pharo-model'
		source: 	'magrittePharoModel
	^ self new
		name: ''Magritte-Pharo-Model'';
		add...etc...
		timestamp: 	'CompatibleUserName 8/6/2020 03:30:13'
		selector: 	#magrittePharoMode
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


LGitTreeEntry>>readStreamDo:
	Receiver: a LGitTreeEntry ('magrittePharoModel.st')
	Arguments and temporary variables: 
		aBlock: 	[ :fileStream | 
| category source timestamp selector |
category := fil...etc..
	Receiver's instance variables: 
		handle: 	(void*)@ 16r7FFB22CFD120
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		parent: 	a LGitTree (number of entries: 1)


[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('magrittePharoModel.st'))
	Arguments and temporary variables: 
		aBlock: 	[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| categ...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('magrittePharoModel.st'))

[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addExtensionClassAndMethodDefinitionsFromEntry:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		methodPropertiesDict: 	a Dictionary()
		classPropertiesDict: 	a Dictionary('name'->'GRPackage' )
		classEntry: 	a LGitTreeEntry ('GRPackage.extension')
		classDirectory: 	a LGitTree (number of entries: 2)
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.class')
	ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.extension')
	ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		entry: 	a LGitTreeEntry ('GRPackage.extension'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAnd...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		entries: 	an Array(a LGitTreeEntry ('categories.st') a LGitTreeEntry ('initializ...etc...
		directory: 	a LGitTreeEntry ('monticello.meta'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>definitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>snapshot
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>version
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)
		commit: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 93%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 99%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ IceVersionDoesNotExist new
	version: iceVersion;
	signal 
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>mcVersionFor:
		startpc: 	126
		numArgs: 	0


IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 93%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 99%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitLocalBranch(IceCommitish)>>mcVersionFor:
	Receiver: IceGitLocalBranch(master)
	Arguments and temporary variables: 
		anIceSavedPackageVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		name: 	'refs/heads/master'


[ (self mcVersionFor: (self versionFor: anIceSavedPackage)) snapshot ] in IceGitLocalBranch(IceCommitish)>>snapshotForPackage:
	Receiver: IceGitLocalBranch(master)
	Arguments and temporary variables: 
		anIceSavedPackage: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		name: 	'refs/heads/master'


BlockClosure>>on:do:
	Receiver: [ (self mcVersionFor: (self versionFor: anIceSavedPackage)) snapshot ]
	Arguments and temporary variables: 
		exception: 	IceVersionDoesNotExist
		handlerAction: 	[ MCSnapshot empty 
	Receiver's instance variables: 
		outerContext: 	IceGitLocalBranch(IceCommitish)>>snapshotForPackage:
		startpc: 	86
		numArgs: 	0


IceGitLocalBranch(IceCommitish)>>snapshotForPackage:
	Receiver: IceGitLocalBranch(master)
	Arguments and temporary variables: 
		anIceSavedPackage: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		name: 	'refs/heads/master'


IceMCPackageImporter>>snapshot
	Receiver: an IceMCPackageImporter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		version: 	IceGitLocalBranch(master)
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


IceMCPackageImporter>>importOn:
	Receiver: an IceMCPackageImporter
	Arguments and temporary variables: 
		aNode: 	IceNode(source)
		packageNode: 	IceNode(Magritte-Pharo20-Model)
		snapshot: 	nil
		definition: 	an IcePackageDefinitio
	Receiver's instance variables: 
		version: 	IceGitLocalBranch(master)
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


IceGitChangeImporter>>ensurePackageFromDirectory:inParentNode:
	Receiver: an IceGitChangeImporter
	Arguments and temporary variables: 
		aFileReference: 	git:///source/Magritte-Pharo20-Model.package
		aParentNode: 	IceNode(source)
		importer: 	an IceMCPackageImporter
		packageName: 	'Magritte-Pharo20-Model'
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		path: 	Path * 'Magritte-Pharo20-Model.package' / 'MAExternalFileModel.class' / '...etc...
		diff: 	an IceDiff
		version: 	IceGitLocalBranch(master)


IceGitChangeImporter>>importOn:
	Receiver: an IceGitChangeImporter
	Arguments and temporary variables: 
		aNode: 	IceNode(source)
		currentSegment: 	'Magritte-Pharo20-Model.package'
		fileReference: 	git:///source/Magritte-Pharo20-Model.package
		filePath: 	Path * 'source' / 'Magritte-Pharo20-Model.package
	Receiver's instance variables: 
		path: 	Path * 'Magritte-Pharo20-Model.package' / 'MAExternalFileModel.class' / '...etc...
		diff: 	an IceDiff
		version: 	IceGitLocalBranch(master)


IceGitChangeImporter>>importOn:
	Receiver: an IceGitChangeImporter
	Arguments and temporary variables: 
		aNode: 	IceNode()
		currentSegment: 	'source'
		fileReference: 	git:///source
		filePath: 	Path * 'source'
		directoryReference: 	git:///source
		directoryPath: 	Path * 'source
	Receiver's instance variables: 
		path: 	Path * 'source' / 'Magritte-Pharo20-Model.package' / 'MAExternalFileModel...etc...
		diff: 	an IceDiff
		version: 	IceGitLocalBranch(master)


IceChangeImporter>>visitGitChange:
	Receiver: an IceChangeImporter
	Arguments and temporary variables: 
		anIceGitChange: 	gitChange(source/Magritte-Pharo20-Model.package/MAExternalFileM...etc...
		importer: 	an IceGitChangeImporte
	Receiver's instance variables: 
		parentNode: 	IceNode()
		diff: 	an IceDiff
		version: 	IceGitLocalBranch(master)


IceGitChange>>accept:
	Receiver: gitChange(source/Magritte-Pharo20-Model.package/MAExternalFileModel.class/class/baseDirect...etc...
	Arguments and temporary variables: 
		aVisitor: 	an IceChangeImporte
	Receiver's instance variables: 
		filePathString: 	'source/Magritte-Pharo20-Model.package/MAExternalFileModel.clas...etc...


[ :change | 
change
	accept:
		(IceChangeImporter new
			version: source;
			diff: self;
			parentNode: leftTree;
			yourself).
change
	accept:
		(IceChangeImporter new
			version: target;
			diff: self;
			parentNode: rightTree;
			yourself) ] in IceDiff>>build
	Receiver: an IceDiff
	Arguments and temporary variables: 
		leftTree: 	IceNode()
		rightTree: 	IceNode()
		change: 	gitChange(source/Magritte-Pharo20-Model.package/MAExternalFileModel.cla...etc..
	Receiver's instance variables: 
		tree: 	nil
		source: 	IceGitLocalBranch(master)
		target: 	an IceWorkingCopy
		writerClass: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(gitChange(source/Magritte-Model.package/MACheckedMemento.class/instance/setOrigin...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :change | 
change
	accept:
		(IceChangeImporter new
			version: sourc...etc...
		index: 	6
	Receiver's instance variables: 
an Array(gitChange(source/Magritte-Model.package/MACheckedMemento.class/instance/setOrigin...etc...

IceDiff>>build
	Receiver: an IceDiff
	Arguments and temporary variables: 
		leftTree: 	IceNode()
		rightTree: 	IceNode(
	Receiver's instance variables: 
		tree: 	nil
		source: 	IceGitLocalBranch(master)
		target: 	an IceWorkingCopy
		writerClass: 	nil


IceDiff class>>from:to:
	Receiver: IceDiff
	Arguments and temporary variables: 
		sourceCommitish: 	IceGitLocalBranch(master)
		targetCommitish: 	an IceWorkingCop
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#accept:->IceDiff>>#accept: #build->IceDiff>>#bu...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IceDiff
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Changes'


IceGitLocalBranch(IceCommitish)>>diffTo:
	Receiver: IceGitLocalBranch(master)
	Arguments and temporary variables: 
		aCommitish: 	an IceWorkingCop
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		name: 	'refs/heads/master'


IceTipCheckoutModel(IceTipDiffPreviewModel)>>calculateDiff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[master]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackages an...etc...


[ diff := self calculateDiff ] in IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
	Receiver: an IceTipCheckoutModel
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		commitish: 	an IceTipBranchModel[master]
		diffModel: 	nil
		checkoutStrategy: 	an IceCheckoutAlreadyLoadedPackages
		checkoutStrategies: 	an OrderedCollection(an IceCheckoutAlreadyLoadedPackages an...etc...



--- The full stack ---
IceLibgitFiletreeReader(Object)>>error:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateExtensionMethodCategory:for:selector:
[ :fileStream | 
| category source timestamp selector |
category := fileStream nextLine.
source := fileStream upToEnd.
selector := self methodSelectorFor: source.
timestamp := methodProperties
	at:
		(classIsMeta
			ifTrue: [ 'class' ]
			ifFalse: [ 'instance' ])
	ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
timestamp
	ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
			, self info time print24 ].
extensionMethod
	ifTrue: [ self
			validateExtensionMethodCategory: category
			for: className
			selector: selector ].
definitions
	add:
		(MCMethodDefinition
			className: className
			classIsMeta: classIsMeta
			selector: selector
			category: category
			timeStamp: timestamp
			source: source) ] in [ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
LGitTreeEntry>>readStreamDo:
[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
Array(SequenceableCollection)>>do:
[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
Array(SequenceableCollection)>>do:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addExtensionClassAndMethodDefinitionsFromEntry:
[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.class')
	ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.extension')
	ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
Array(SequenceableCollection)>>do:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
IceLibgitFiletreeReader(MCVersionReader)>>definitions
IceLibgitFiletreeReader(MCVersionReader)>>snapshot
IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
IceLibgitFiletreeReader(MCVersionReader)>>version
[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
BlockClosure>>on:do:
IceLibgitRepository>>mcVersionFor:
IceGitLocalBranch(IceCommitish)>>mcVersionFor:
[ (self mcVersionFor: (self versionFor: anIceSavedPackage)) snapshot ] in IceGitLocalBranch(IceCommitish)>>snapshotForPackage:
BlockClosure>>on:do:
IceGitLocalBranch(IceCommitish)>>snapshotForPackage:
IceMCPackageImporter>>snapshot
IceMCPackageImporter>>importOn:
IceGitChangeImporter>>ensurePackageFromDirectory:inParentNode:
IceGitChangeImporter>>importOn:
IceGitChangeImporter>>importOn:
IceChangeImporter>>visitGitChange:
IceGitChange>>accept:
[ :change | 
change
	accept:
		(IceChangeImporter new
			version: source;
			diff: self;
			parentNode: leftTree;
			yourself).
change
	accept:
		(IceChangeImporter new
			version: target;
			diff: self;
			parentNode: rightTree;
			yourself) ] in IceDiff>>build
Array(SequenceableCollection)>>do:
IceDiff>>build
IceDiff class>>from:to:
IceGitLocalBranch(IceCommitish)>>diffTo:
IceTipCheckoutModel(IceTipDiffPreviewModel)>>calculateDiff
[ diff := self calculateDiff ] in IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipCheckoutModel(IceTipDiffPreviewModel)>>diff
IceTipCheckoutPreviewBrowser(IceTipPreviewBrowser)>>initializeWidgets
IceTipCheckoutPreviewBrowser>>initializeWidgets
IceTipCheckoutPreviewBrowser(ComposablePresenter)>>initializePrivateHooks
IceTipCheckoutPreviewBrowser(ComposablePresenter)>>initialize
IceTipCheckoutPreviewBrowser(IceTipBrowser)>>initialize
IceTipCheckoutPreviewBrowser class(ComposablePresenter class)>>on:
IceTipCheckoutPreviewBrowser class>>onBranch:
IceTipBranchModel>>previewCheckout
IceTipCachedModel>>forwardMessage:
IceTipCachedModel>>doesNotUnderstand: #previewCheckout
IceTipCheckoutBranchPanel>>doAccept
IceTipCheckoutBranchDialog>>doAccept
[ self doAccept.
true ] in IceTipCheckoutBranchDialog(IceTipOptionDialog)>>accept
BlockClosure>>on:do:
IceTipCheckoutBranchDialog(IceTipOptionDialog)>>accept
[ self accept ] in IceTipCheckoutBranchDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Method protocol '*magritte-pharo-model' for the method 'magrittePharoModel' in class 'GRPackage' is inconsistent with the package name '*magritte-pharo20-model'
25 August 2020 5:38:23.019575 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

IceLibgitFiletreeReader(Object)>>error:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aString: 	'Method protocol ''*magritte-pharo-model'' for the method ''magrittePh...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>validateExtensionMethodCategory:for:selector:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		categoryName: 	'*magritte-pharo-model'
		className: 	'GRPackage'
		selector: 	#magrittePharoModel
		prefix: 	'*magritte-pharo20-model
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :fileStream | 
| category source timestamp selector |
category := fileStream nextLine.
source := fileStream upToEnd.
selector := self methodSelectorFor: source.
timestamp := methodProperties
	at:
		(classIsMeta
			ifTrue: [ 'class' ]
			ifFalse: [ 'instance' ])
	ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
timestamp
	ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
			, self info time print24 ].
extensionMethod
	ifTrue: [ self
			validateExtensionMethodCategory: category
			for: className
			selector: selector ].
definitions
	add:
		(MCMethodDefinition
			className: className
			classIsMeta: classIsMeta
			selector: selector
			category: category
			timeStamp: timestamp
			source: source) ] in [ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st')
		fileStream: 	a ReadStream
		category: 	'*magritte-pharo-model'
		source: 	'magrittePharoModel
	^ self new
		name: ''Magritte-Pharo-Model'';
		add...etc...
		timestamp: 	'CompatibleUserName 8/6/2020 03:30:13'
		selector: 	#magrittePharoMode
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


LGitTreeEntry>>readStreamDo:
	Receiver: a LGitTreeEntry ('magrittePharoModel.st')
	Arguments and temporary variables: 
		aBlock: 	[ :fileStream | 
| category source timestamp selector |
category := fil...etc..
	Receiver's instance variables: 
		handle: 	(void*)@ 16r7FD834AADF20
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		parent: 	a LGitTree (number of entries: 1)


[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| category source timestamp selector |
		category := fileStream nextLine.
		source := fileStream upToEnd.
		selector := self methodSelectorFor: source.
		timestamp := methodProperties
			at:
				(classIsMeta
					ifTrue: [ 'class' ]
					ifFalse: [ 'instance' ])
			ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
		timestamp
			ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
					, self info time print24 ].
		extensionMethod
			ifTrue: [ self
					validateExtensionMethodCategory: category
					for: className
					selector: selector ].
		definitions
			add:
				(MCMethodDefinition
					className: className
					classIsMeta: classIsMeta
					selector: selector
					category: category
					timeStamp: timestamp
					source: source) ] ] in [ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	true
		methodEntry: 	a LGitTreeEntry ('magrittePharoModel.st'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('magrittePharoModel.st'))
	Arguments and temporary variables: 
		aBlock: 	[ :methodEntry | 
methodEntry
	readStreamDo: [ :fileStream | 
		| categ...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('magrittePharoModel.st'))

[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
	ifTrue: [ classIsMeta := true ].
(entry name = 'instance' or: [ entry name = 'class' ])
	ifTrue: [ (self
			loadableDefinitionsFrom: (self fileUtils directoryFromEntry: entry))
			do: [ :methodEntry | 
				methodEntry
					readStreamDo: [ :fileStream | 
						| category source timestamp selector |
						category := fileStream nextLine.
						source := fileStream upToEnd.
						selector := self methodSelectorFor: source.
						timestamp := methodProperties
							at:
								(classIsMeta
									ifTrue: [ 'class' ]
									ifFalse: [ 'instance' ])
							ifPresent: [ :map | map at: selector asString ifAbsent: [  ] ].	"Issue 33: https://github.com/dalehenrich/filetree/issues/33"
						timestamp
							ifNil: [ timestamp := self info author , ' ' , self info date mmddyyyy , ' '
									, self info time print24 ].
						extensionMethod
							ifTrue: [ self
									validateExtensionMethodCategory: category
									for: className
									selector: selector ].
						definitions
							add:
								(MCMethodDefinition
									className: className
									classIsMeta: classIsMeta
									selector: selector
									category: category
									timeStamp: timestamp
									source: source) ] ] ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	true
		entry: 	a LGitTreeEntry ('class')
		classIsMeta: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
| classIsMeta |
classIsMeta := false.
entry name = 'class'
...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json'))

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addMethodDefinitionsForClass:methodProperties:in:extensionMethod:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		className: 	'GRPackage'
		methodProperties: 	a Dictionary()
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc...
		extensionMethod: 	tru
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addExtensionClassAndMethodDefinitionsFromEntry:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		methodPropertiesDict: 	a Dictionary()
		classPropertiesDict: 	a Dictionary('name'->'GRPackage' )
		classEntry: 	a LGitTreeEntry ('GRPackage.extension')
		classDirectory: 	a LGitTree (number of entries: 2)
		entries: 	an Array(a LGitTreeEntry ('class') a LGitTreeEntry ('properties.json')...etc..
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.class')
	ifTrue: [ self addClassAndMethodDefinitionsFromEntry: entry ].
(entry name endsWith: '.extension')
	ifTrue: [ self addExtensionClassAndMethodDefinitionsFromEntry: entry ] ] in IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		entry: 	a LGitTreeEntry ('GRPackage.extension'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


Array(SequenceableCollection)>>do:
	Receiver: an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
(entry name endsWith: '.trait')
	ifTrue: [ self addTraitAnd...etc...
		index: 	
	Receiver's instance variables: 
an Array(a LGitTreeEntry ('.filetree') a LGitTreeEntry ('GRPackage.extension') a LGitTreeE...etc...

IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>addClassAndMethodDefinitionsFromDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>loadDefinitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		entries: 	an Array(a LGitTreeEntry ('categories.st') a LGitTreeEntry ('initializ...etc...
		directory: 	a LGitTreeEntry ('monticello.meta'
	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>definitions
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>snapshot
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCFileTreeStCypressReader)>>basicVersion
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


IceLibgitFiletreeReader(MCVersionReader)>>version
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 

	Receiver's instance variables: 
		stream: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc...
		package: 	a MCPackage(Magritte-Pharo20-Model)
		info: 	an IceMCVersionInfo(Magritte-Pharo20-Model-CompatibleUserName.1596677413)...etc...
		definitions: 	an OrderedCollection(a MCOrganizationDefinition(#(#'Magritte-Pharo...etc...
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	a LGitTreeEntry ('Magritte-Pharo20-Model.package')
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)


[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model)
		commit: 	a LGitCommit (6bd2f90...1e624f1, 'Merge pull request #154 from seandeni...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 50%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ IceVersionDoesNotExist new
	version: iceVersion;
	signal 
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>mcVersionFor:
		startpc: 	126
		numArgs: 	0


IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 50%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitCommit(IceCommitish)>>mcVersionFor:
	Receiver: IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
	Arguments and temporary variables: 
		anIceSavedPackageVersion: 	IceSavedPackageVersion(Magritte-Pharo20-Model
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		id: 	'6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1'
		author: 	'Sean DeNigris'
		datetime: 	2020-08-06T03:30:13+02:00
		ancestorIds: 	#('1724c2e0707db8f940c1c9db85df56ae6f2bbf78' 'd40ec27103e85535214a...etc...
		comment: 	'Merge pull request #154 from seandenigris/bug_metacello-invert-depend...etc...


[ (self mcVersionFor: (self versionFor: anIceSavedPackage)) snapshot ] in IceGitCommit(IceCommitish)>>snapshotForPackage:
	Receiver: IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
	Arguments and temporary variables: 
		anIceSavedPackage: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		id: 	'6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1'
		author: 	'Sean DeNigris'
		datetime: 	2020-08-06T03:30:13+02:00
		ancestorIds: 	#('1724c2e0707db8f940c1c9db85df56ae6f2bbf78' 'd40ec27103e85535214a...etc...
		comment: 	'Merge pull request #154 from seandenigris/bug_metacello-invert-depend...etc...


BlockClosure>>on:do:
	Receiver: [ (self mcVersionFor: (self versionFor: anIceSavedPackage)) snapshot ]
	Arguments and temporary variables: 
		exception: 	IceVersionDoesNotExist
		handlerAction: 	[ MCSnapshot empty 
	Receiver's instance variables: 
		outerContext: 	IceGitCommit(IceCommitish)>>snapshotForPackage:
		startpc: 	86
		numArgs: 	0


IceGitCommit(IceCommitish)>>snapshotForPackage:
	Receiver: IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
	Arguments and temporary variables: 
		anIceSavedPackage: 	IcePackage(Magritte-Pharo20-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		id: 	'6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1'
		author: 	'Sean DeNigris'
		datetime: 	2020-08-06T03:30:13+02:00
		ancestorIds: 	#('1724c2e0707db8f940c1c9db85df56ae6f2bbf78' 'd40ec27103e85535214a...etc...
		comment: 	'Merge pull request #154 from seandenigris/bug_metacello-invert-depend...etc...


IceMCPackageImporter>>snapshot
	Receiver: an IceMCPackageImporter
	Arguments and temporary variables: 

	Receiver's instance variables: 
		version: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


IceMCPackageImporter>>importOn:
	Receiver: an IceMCPackageImporter
	Arguments and temporary variables: 
		aNode: 	IceNode(source)
		packageNode: 	IceNode(Magritte-Pharo20-Model)
		snapshot: 	nil
		definition: 	an IcePackageDefinitio
	Receiver's instance variables: 
		version: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


IceChangeImporter>>visitImageChange:
	Receiver: an IceChangeImporter
	Arguments and temporary variables: 
		anIceImageChange: 	an IceImageChange
		importer: 	an IceMCPackageImporte
	Receiver's instance variables: 
		parentNode: 	IceNode()
		diff: 	an IceDiff
		version: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)


IceImageChange>>accept:
	Receiver: an IceImageChange
	Arguments and temporary variables: 
		aVisitor: 	an IceChangeImporte
	Receiver's instance variables: 
		package: 	IcePackage(Magritte-Pharo20-Model, not loaded)


[ :change | 
change
	accept:
		(IceChangeImporter new
			version: source;
			diff: self;
			parentNode: leftTree;
			yourself).
change
	accept:
		(IceChangeImporter new
			version: target;
			diff: self;
			parentNode: rightTree;
			yourself) ] in IceDiff>>build
	Receiver: an IceDiff
	Arguments and temporary variables: 
		leftTree: 	IceNode()
		rightTree: 	IceNode()
		change: 	an IceImageChang
	Receiver's instance variables: 
		tree: 	nil
		source: 	an IceWorkingCopy
		target: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		writerClass: 	nil


Set>>do:
	Receiver: a Set(an IceImageChange)
	Arguments and temporary variables: 
		aBlock: 	[ :change | 
change
	accept:
		(IceChangeImporter new
			version: sourc...etc...
		index: 	1
		each: 	an IceImageChang
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(an IceImageChange nil nil nil nil)


IceDiff>>build
	Receiver: an IceDiff
	Arguments and temporary variables: 
		leftTree: 	IceNode()
		rightTree: 	IceNode(
	Receiver's instance variables: 
		tree: 	nil
		source: 	an IceWorkingCopy
		target: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		writerClass: 	nil


IceDiff class>>from:to:
	Receiver: IceDiff
	Arguments and temporary variables: 
		sourceCommitish: 	an IceWorkingCopy
		targetCommitish: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#accept:->IceDiff>>#accept: #build->IceDiff>>#bu...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IceDiff
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Changes'


IceWorkingCopy>>diffTo:
	Receiver: an IceWorkingCopy
	Arguments and temporary variables: 
		aCommitish: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		packages: 	a Dictionary('BaselineOfMagritte'->IcePackage(BaselineOfMagritte, not...etc...
		referenceCommit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		shouldIgnoreNotifications: 	false
		project: 	an IceBasicProject
		properties: 	an IceRepositoryProperties


IceWorkingCopy>>diffToReferenceCommit
	Receiver: an IceWorkingCopy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		packages: 	a Dictionary('BaselineOfMagritte'->IcePackage(BaselineOfMagritte, not...etc...
		referenceCommit: 	IceGitCommit(6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1)
		shouldIgnoreNotifications: 	false
		project: 	an IceBasicProject
		properties: 	an IceRepositoryProperties


IceLibgitRepository(IceRepository)>>workingCopyDiff
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 50%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceTipWorkingCopyDiffModel>>newDiff
	Receiver: an IceTipWorkingCopyDiffModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
		entity: 	IceLibgitRepository(magritte)
		repositoryModel: 	an IceTipRepositoryModel
		diff: 	nil


IceTipWorkingCopyDiffModel>>diff
	Receiver: an IceTipWorkingCopyDiffModel
	Arguments and temporary variables: 

	Receiver's instance variables: 
THERE_BE_DRAGONS_HERE
IceGenericError: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
25 August 2020 5:46:27.807805 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

IceLibgitErrorVisitor>>visitGenericError:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-...etc..
	Receiver's instance variables: 
		context: 	IceLibgitRepository(magritte)


IceLibgitErrorVisitor>>visitERROR:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-...etc..
	Receiver's instance variables: 
		context: 	IceLibgitRepository(magritte)


LGit_GIT_ERROR>>acceptError:
	Receiver: LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisito
	Receiver's instance variables: 
		messageText: 	'invalid path: ''pharo-local/iceberg/seandenigris/Pharo-Enhancemen...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_index [10])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAl...etc...
		error: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-En...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-En...etc..
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	71
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Phar...etc...
		value: 	ni
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	add...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Phar...etc..
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	add...etc...


LGit_GIT_ERROR(Exception)>>signal
	Receiver: LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'invalid path: ''pharo-local/iceberg/seandenigris/Pharo-Enhancemen...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_index [10])


LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ERROR
	Arguments and temporary variables: 
		anError: 	a LGitError (
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ERROR>>#acceptError: )
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ERROR
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_error [-1])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ERRO
	Receiver's instance variables: 
		value: 	-1


LGitIndex(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitIndex ()
	Arguments and temporary variables: 
		callBlock: 	[ self
	index_add_all: self
	pathspec: pathspec
	flags: 0
	callback:...etc..
	Receiver's instance variables: 
		handle: 	@ 16r7FB7305F9E50
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)


LGitIndex>>addAll:
	Receiver: a LGitIndex ()
	Arguments and temporary variables: 
		pathSpecs: 	#()
		pathspec: 	a LGitStringArray (
	Receiver's instance variables: 
		handle: 	@ 16r7FB7305F9E50
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)


[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
			collect: [ :each | 
				self assert: each asFileReference isRelative.
				"self assert: (self location resolve: each) exists."
				each asFileReference path pathString ]
			as: Array).
gitIndex
	writeToDisk;
	free ] in IceLibgitRepository>>addFilesToIndex:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aCollection: 	a Set()
		gitIndex: 	a LGitIndex (
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
	...etc...
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc..
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>addFilesToIndex:
		startpc: 	135
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAl...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceLibgitRepository>>addFilesToIndex:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aCollection: 	a Set(
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitIndex>>addToGitIndex
	Receiver: an IceGitIndex
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHandle defaultSignature ]
	on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR
	do: [ :e | IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].
index := self repositoryHandle index.
indexTreeId := index writeTreeAndReturnOid.
index free.
commitId := (LGitCommitBuilder of: self repositoryHandle)
	tree: (LGitTree of: self repositoryHandle fromId: indexTreeId);
	message: message withUnixLineEndings utf8Encoded asString;
	parents:
		(self repositoryHandle isUnborn
			ifTrue: [ #() ]
			ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: parentCommits ]);
	"'HEAD' branch could not exist yet. No problem, libgit will create it, 
				but we have to remember it to notify the frontend."
		updateReference:
		([ self repositoryHandle head name ]
			on: LGit_GIT_EUNBORNBRANCH
			do: [ repository branch gitRef ]);
	author: signature;
	committer: signature;
	writeCommit;
	commitId.	"FFI is expecting an string"
^ repository
	commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: commitId) ] in IceGitIndex>>commitWithMessage:andParents:
	Receiver: an IceGitIndex
	Arguments and temporary variables: 
		message: 	'sources migrated'
		parentCommits: 	an Array(IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5))...etc...
		index: 	nil
		signature: 	nil
		commitId: 	nil
		indexTreeId: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


BlockClosure>>on:do:
	Receiver: [ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHan...etc...
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc..
	Receiver's instance variables: 
		outerContext: 	IceGitIndex>>commitWithMessage:andParents:
		startpc: 	356
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature :=...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitIndex>>commitWithMessage:andParents:
	Receiver: an IceGitIndex
	Arguments and temporary variables: 
		index: 	nil
		message: 	'sources migrated'
		parentCommits: 	an Array(IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5))...etc..
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


IceLibgitRepository(IceRepository)>>commitIndexWithMessage:andParents:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		message: 	'sources migrated'
		parentCommitishList: 	an Array(IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf81...etc...
		newCommit: 	ni
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	nil
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceConvertFormatAction>>execute
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		oldBranch: 	IceGitLocalBranch(cleanup)
		newBranch: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-1'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceTipFiletreeToTonelDialog>>doAccept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-1'
		repository: 	IceLibgitRepository(magritte)


[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-1'
		repository: 	IceLibgitRepository(magritte)


[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


BlockClosure>>cull:
	Receiver: [ :bar | aBlock value: bar ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		startpc: 	58
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ activeProcess psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ activeProcess psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	79
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	77
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[ :bar | aBlock value: bar 
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value 
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceLibgitErrorVisitor>>visitGenericError:
IceLibgitErrorVisitor>>visitERROR:
LGit_GIT_ERROR>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ERROR(Exception)>>signal
LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitIndex(LGitExternalObject)>>withReturnHandlerDo:
LGitIndex>>addAll:
[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
			collect: [ :each | 
				self assert: each asFileReference isRelative.
				"self assert: (self location resolve: each) exists."
				each asFileReference path pathString ]
			as: Array).
gitIndex
	writeToDisk;
	free ] in IceLibgitRepository>>addFilesToIndex:
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceLibgitRepository>>addFilesToIndex:
IceGitIndex>>addToGitIndex
[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHandle defaultSignature ]
	on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR
	do: [ :e | IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].
index := self repositoryHandle index.
indexTreeId := index writeTreeAndReturnOid.
index free.
commitId := (LGitCommitBuilder of: self repositoryHandle)
	tree: (LGitTree of: self repositoryHandle fromId: indexTreeId);
	message: message withUnixLineEndings utf8Encoded asString;
	parents:
		(self repositoryHandle isUnborn
			ifTrue: [ #() ]
			ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: parentCommits ]);
	"'HEAD' branch could not exist yet. No problem, libgit will create it, 
				but we have to remember it to notify the frontend."
		updateReference:
		([ self repositoryHandle head name ]
			on: LGit_GIT_EUNBORNBRANCH
			do: [ repository branch gitRef ]);
	author: signature;
	committer: signature;
	writeCommit;
	commitId.	"FFI is expecting an string"
^ repository
	commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: commitId) ] in IceGitIndex>>commitWithMessage:andParents:
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitIndex>>commitWithMessage:andParents:
IceLibgitRepository(IceRepository)>>commitIndexWithMessage:andParents:
IceConvertFormatAction>>migrateSources
IceConvertFormatAction>>execute
IceTipFiletreeToTonelDialog>>doAccept
[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipFiletreeToTonelDialog>>accept
[ self accept ] in IceTipFiletreeToTonelDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
IceGenericError: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
25 August 2020 5:48:11.901013 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

IceLibgitErrorVisitor>>visitGenericError:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-...etc..
	Receiver's instance variables: 
		context: 	IceLibgitRepository(magritte)


IceLibgitErrorVisitor>>visitERROR:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-...etc..
	Receiver's instance variables: 
		context: 	IceLibgitRepository(magritte)


LGit_GIT_ERROR>>acceptError:
	Receiver: LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisito
	Receiver's instance variables: 
		messageText: 	'invalid path: ''pharo-local/iceberg/seandenigris/Pharo-Enhancemen...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_index [10])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAl...etc...
		error: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-En...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-En...etc..
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	71
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Phar...etc...
		value: 	ni
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	add...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Phar...etc..
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	add...etc...


LGit_GIT_ERROR(Exception)>>signal
	Receiver: LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'invalid path: ''pharo-local/iceberg/seandenigris/Pharo-Enhancemen...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_index [10])


LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ERROR
	Arguments and temporary variables: 
		anError: 	a LGitError (
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ERROR>>#acceptError: )
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ERROR
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_error [-1])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ERRO
	Receiver's instance variables: 
		value: 	-1


LGitIndex(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitIndex ()
	Arguments and temporary variables: 
		callBlock: 	[ self
	index_add_all: self
	pathspec: pathspec
	flags: 0
	callback:...etc..
	Receiver's instance variables: 
		handle: 	@ 16r7FC6282D0E50
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)


LGitIndex>>addAll:
	Receiver: a LGitIndex ()
	Arguments and temporary variables: 
		pathSpecs: 	#()
		pathspec: 	a LGitStringArray (
	Receiver's instance variables: 
		handle: 	@ 16r7FC6282D0E50
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)


[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
			collect: [ :each | 
				self assert: each asFileReference isRelative.
				"self assert: (self location resolve: each) exists."
				each asFileReference path pathString ]
			as: Array).
gitIndex
	writeToDisk;
	free ] in IceLibgitRepository>>addFilesToIndex:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aCollection: 	a Set()
		gitIndex: 	a LGitIndex (
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
	...etc...
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc..
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>addFilesToIndex:
		startpc: 	135
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAl...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceLibgitRepository>>addFilesToIndex:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aCollection: 	a Set(
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitIndex>>addToGitIndex
	Receiver: an IceGitIndex
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHandle defaultSignature ]
	on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR
	do: [ :e | IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].
index := self repositoryHandle index.
indexTreeId := index writeTreeAndReturnOid.
index free.
commitId := (LGitCommitBuilder of: self repositoryHandle)
	tree: (LGitTree of: self repositoryHandle fromId: indexTreeId);
	message: message withUnixLineEndings utf8Encoded asString;
	parents:
		(self repositoryHandle isUnborn
			ifTrue: [ #() ]
			ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: parentCommits ]);
	"'HEAD' branch could not exist yet. No problem, libgit will create it, 
				but we have to remember it to notify the frontend."
		updateReference:
		([ self repositoryHandle head name ]
			on: LGit_GIT_EUNBORNBRANCH
			do: [ repository branch gitRef ]);
	author: signature;
	committer: signature;
	writeCommit;
	commitId.	"FFI is expecting an string"
^ repository
	commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: commitId) ] in IceGitIndex>>commitWithMessage:andParents:
	Receiver: an IceGitIndex
	Arguments and temporary variables: 
		message: 	'sources migrated'
		parentCommits: 	an Array(IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5))...etc...
		index: 	nil
		signature: 	nil
		commitId: 	nil
		indexTreeId: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


BlockClosure>>on:do:
	Receiver: [ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHan...etc...
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc..
	Receiver's instance variables: 
		outerContext: 	IceGitIndex>>commitWithMessage:andParents:
		startpc: 	356
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature :=...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitIndex>>commitWithMessage:andParents:
	Receiver: an IceGitIndex
	Arguments and temporary variables: 
		index: 	nil
		message: 	'sources migrated'
		parentCommits: 	an Array(IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5))...etc..
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


IceLibgitRepository(IceRepository)>>commitIndexWithMessage:andParents:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		message: 	'sources migrated'
		parentCommitishList: 	an Array(IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf81...etc...
		newCommit: 	ni
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-2'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceConvertFormatAction>>execute
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		oldBranch: 	IceGitLocalBranch(migrate-sources-to-tonel-1)
		newBranch: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-2'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceTipFiletreeToTonelDialog>>doAccept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-2'
		repository: 	IceLibgitRepository(magritte)


[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-2'
		repository: 	IceLibgitRepository(magritte)


[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


BlockClosure>>cull:
	Receiver: [ :bar | aBlock value: bar ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		startpc: 	58
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ activeProcess psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ activeProcess psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	79
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	77
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[ :bar | aBlock value: bar 
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value 
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceLibgitErrorVisitor>>visitGenericError:
IceLibgitErrorVisitor>>visitERROR:
LGit_GIT_ERROR>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ERROR(Exception)>>signal
LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitIndex(LGitExternalObject)>>withReturnHandlerDo:
LGitIndex>>addAll:
[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
			collect: [ :each | 
				self assert: each asFileReference isRelative.
				"self assert: (self location resolve: each) exists."
				each asFileReference path pathString ]
			as: Array).
gitIndex
	writeToDisk;
	free ] in IceLibgitRepository>>addFilesToIndex:
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceLibgitRepository>>addFilesToIndex:
IceGitIndex>>addToGitIndex
[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHandle defaultSignature ]
	on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR
	do: [ :e | IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].
index := self repositoryHandle index.
indexTreeId := index writeTreeAndReturnOid.
index free.
commitId := (LGitCommitBuilder of: self repositoryHandle)
	tree: (LGitTree of: self repositoryHandle fromId: indexTreeId);
	message: message withUnixLineEndings utf8Encoded asString;
	parents:
		(self repositoryHandle isUnborn
			ifTrue: [ #() ]
			ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: parentCommits ]);
	"'HEAD' branch could not exist yet. No problem, libgit will create it, 
				but we have to remember it to notify the frontend."
		updateReference:
		([ self repositoryHandle head name ]
			on: LGit_GIT_EUNBORNBRANCH
			do: [ repository branch gitRef ]);
	author: signature;
	committer: signature;
	writeCommit;
	commitId.	"FFI is expecting an string"
^ repository
	commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: commitId) ] in IceGitIndex>>commitWithMessage:andParents:
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitIndex>>commitWithMessage:andParents:
IceLibgitRepository(IceRepository)>>commitIndexWithMessage:andParents:
IceConvertFormatAction>>migrateSources
IceConvertFormatAction>>execute
IceTipFiletreeToTonelDialog>>doAccept
[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipFiletreeToTonelDialog>>accept
[ self accept ] in IceTipFiletreeToTonelDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MetacelloNameNotDefinedError: project group, or package named: 'PharoEnhancements' not found when used in requires: or includes: field of package: 'Magritte-Developer' for version: baseline of BaselineOfMagritte.
25 August 2020 5:49:14.995545 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

[ MetacelloNameNotDefinedError
	signal:
		'project group, or package named: ' , specName printString
			, ' not found when used in requires: or includes: field of package: '
			, self name printString , ' for version: '
			, aVersionSpec versionString , ' of ' , aVersionSpec projectLabel
			, '.'.
nil	"return nil if resumed" ] in [ :specName | 
| spec |
"get project/group/package specs"
spec := aVersionSpec
	packageNamed: specName
	ifAbsent: [ MetacelloNameNotDefinedError
			signal:
				'project group, or package named: ' , specName printString
					, ' not found when used in requires: or includes: field of package: '
					, self name printString , ' for version: '
					, aVersionSpec versionString , ' of ' , aVersionSpec projectLabel
					, '.'.
		nil	"return nil if resumed" ].
spec
	ifNotNil: [ packageOrProjectSpecs
			addAll: (spec resolveSpecsForPackageOrdering: aVersionSpec) ] ] in MetacelloPackageSpec(MetacelloAbstractPackageSpec)>>specs:forPackageOrdering:
	Receiver: spec 
	name: 'Magritte-Developer';
	requires: #('PharoEnhancements' ).
	Arguments and temporary variables: 
		specNames: 	#('PharoEnhancements')
		aVersionSpec: 	spec description: 'For pharo4.x, add Magritte-GT package and add ...etc...
		packageOrProjectSpecs: 	a Set()
		specName: 	'PharoEnhancements'
		spec: 	ni
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	nil
		mutable: 	nil
		name: 	'Magritte-Developer'
		requires: 	#('PharoEnhancements')
		includes: 	#()
		answers: 	#()
		file: 	nil
		repositories: 	spec

		goferPackage: 	nil
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil


[ (self importArray notNil or: [ self import notNil ])
	ifTrue:
		[ "expect the 'missing' name to be satisfied within context of imported project"
		importArray
			ifNotNil: [ importArray
					do: [ :assoc | 
						((assoc value includes: aString) and: [ map includesKey: assoc key ])
							ifTrue: [ importSpec := (map at: assoc key)
									mergeImportLoads: {aString};
									yourself ] ].
				importSpec ifNotNil: [ ^ importSpec ] ].
		(importSpec isNil and: [ self import notNil ])
			ifTrue: [ ^ (map at: self import ifAbsent: absentBlock)
					mergeImportLoads: {aString};
					yourself ] ].
(aString = 'default' or: [ aString = 'ALL' ])
	ifTrue: [ self project groupSpec
			name: aString;
			includes: self packageNames;
			yourself ]
	ifFalse: [ absentBlock value ] ] in MetacelloMCVersionSpec(MetacelloVersionSpec)>>packageNamed:forLoad:forMap:ifAbsent:
	Receiver: spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'....etc...
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements'
		ignored: 	true
		map: 	a Dictionary('Core'->spec 
	name: 'Core';
	includes: #('Magritte-Model' )....etc...
		absentBlock: 	[ MetacelloNameNotDefinedError
	signal:
		'project group, or packa...etc...
		importSpec: 	ni
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	a MetacelloLoadingMCSpecLoader
		mutable: 	nil
		versionString: 	'baseline'
		blessing: 	nil
		description: 	spec value: 'For pharo4.x, add Magritte-GT package and add it to t...etc...
		author: 	spec value: 'SeanDeNigris'
		timestamp: 	spec value: '2015-04-05'
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil
		packageList: 	spec	add: [
		spec 
			name: 'Magritte-Tests-Pharo-Model';
			requ...etc...
		importName: 	nil
		importArray: 	nil
		repositories: 	spec
repository: 'gitlocal:///Users/norbert/work/projects/magritt...etc...
		packages: 	nil


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary('Core'->spec 
	name: 'Core';
	includes: #('Magritte-Model' ). 'Deprecated'->s...etc...
	Arguments and temporary variables: 
		key: 	'PharoEnhancements'
		aBlock: 	[ (self importArray notNil or: [ self import notNil ])
	ifTrue:
		[ "ex...etc..
	Receiver's instance variables: 
		tally: 	25
		array: 	an Array('Magritte-Tests-Pharo-Model'->spec 
	name: 'Magritte-Tests-Phar...etc...


MetacelloMCVersionSpec(MetacelloVersionSpec)>>packageNamed:forLoad:forMap:ifAbsent:
	Receiver: spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'....etc...
	Arguments and temporary variables: 
		importSpec: 	nil
		aString: 	'PharoEnhancements'
		ignored: 	true
		map: 	a Dictionary('Core'->spec 
	name: 'Core';
	includes: #('Magritte-Model' )....etc...
		absentBlock: 	[ MetacelloNameNotDefinedError
	signal:
		'project group, or packa...etc..
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	a MetacelloLoadingMCSpecLoader
		mutable: 	nil
		versionString: 	'baseline'
		blessing: 	nil
		description: 	spec value: 'For pharo4.x, add Magritte-GT package and add it to t...etc...
		author: 	spec value: 'SeanDeNigris'
		timestamp: 	spec value: '2015-04-05'
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil
		packageList: 	spec	add: [
		spec 
			name: 'Magritte-Tests-Pharo-Model';
			requ...etc...
		importName: 	nil
		importArray: 	nil
		repositories: 	spec
repository: 'gitlocal:///Users/norbert/work/projects/magritt...etc...
		packages: 	nil


MetacelloMCVersionSpec(MetacelloVersionSpec)>>packageNamed:forMap:ifAbsent:
	Receiver: spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'....etc...
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements'
		map: 	a Dictionary('Core'->spec 
	name: 'Core';
	includes: #('Magritte-Model' )....etc...
		absentBlock: 	[ MetacelloNameNotDefinedError
	signal:
		'project group, or packa...etc..
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	a MetacelloLoadingMCSpecLoader
		mutable: 	nil
		versionString: 	'baseline'
		blessing: 	nil
		description: 	spec value: 'For pharo4.x, add Magritte-GT package and add it to t...etc...
		author: 	spec value: 'SeanDeNigris'
		timestamp: 	spec value: '2015-04-05'
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil
		packageList: 	spec	add: [
		spec 
			name: 'Magritte-Tests-Pharo-Model';
			requ...etc...
		importName: 	nil
		importArray: 	nil
		repositories: 	spec
repository: 'gitlocal:///Users/norbert/work/projects/magritt...etc...
		packages: 	nil


MetacelloMCVersionSpec(MetacelloVersionSpec)>>packageNamed:ifAbsent:
	Receiver: spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'....etc...
	Arguments and temporary variables: 
		aString: 	'PharoEnhancements'
		aBlock: 	[ MetacelloNameNotDefinedError
	signal:
		'project group, or package na...etc..
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	a MetacelloLoadingMCSpecLoader
		mutable: 	nil
		versionString: 	'baseline'
		blessing: 	nil
		description: 	spec value: 'For pharo4.x, add Magritte-GT package and add it to t...etc...
		author: 	spec value: 'SeanDeNigris'
		timestamp: 	spec value: '2015-04-05'
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil
		packageList: 	spec	add: [
		spec 
			name: 'Magritte-Tests-Pharo-Model';
			requ...etc...
		importName: 	nil
		importArray: 	nil
		repositories: 	spec
repository: 'gitlocal:///Users/norbert/work/projects/magritt...etc...
		packages: 	nil


[ :specName | 
| spec |
"get project/group/package specs"
spec := aVersionSpec
	packageNamed: specName
	ifAbsent: [ MetacelloNameNotDefinedError
			signal:
				'project group, or package named: ' , specName printString
					, ' not found when used in requires: or includes: field of package: '
					, self name printString , ' for version: '
					, aVersionSpec versionString , ' of ' , aVersionSpec projectLabel
					, '.'.
		nil	"return nil if resumed" ].
spec
	ifNotNil: [ packageOrProjectSpecs
			addAll: (spec resolveSpecsForPackageOrdering: aVersionSpec) ] ] in MetacelloPackageSpec(MetacelloAbstractPackageSpec)>>specs:forPackageOrdering:
	Receiver: spec 
	name: 'Magritte-Developer';
	requires: #('PharoEnhancements' ).
	Arguments and temporary variables: 
		specNames: 	#('PharoEnhancements')
		aVersionSpec: 	spec description: 'For pharo4.x, add Magritte-GT package and add ...etc...
		packageOrProjectSpecs: 	a Set()
		specName: 	'PharoEnhancements'
		spec: 	ni
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	nil
		mutable: 	nil
		name: 	'Magritte-Developer'
		requires: 	#('PharoEnhancements')
		includes: 	#()
		answers: 	#()
		file: 	nil
		repositories: 	spec

		goferPackage: 	nil
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil


Array(SequenceableCollection)>>do:
	Receiver: #('PharoEnhancements')
	Arguments and temporary variables: 
		aBlock: 	[ :specName | 
| spec |
"get project/group/package specs"
spec := aVers...etc...
		index: 	
	Receiver's instance variables: 
#('PharoEnhancements')

MetacelloPackageSpec(MetacelloAbstractPackageSpec)>>specs:forPackageOrdering:
	Receiver: spec 
	name: 'Magritte-Developer';
	requires: #('PharoEnhancements' ).
	Arguments and temporary variables: 
		specNames: 	#('PharoEnhancements')
		aVersionSpec: 	spec description: 'For pharo4.x, add Magritte-GT package and add ...etc...
		packageOrProjectSpecs: 	a Set(
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	nil
		mutable: 	nil
		name: 	'Magritte-Developer'
		requires: 	#('PharoEnhancements')
		includes: 	#()
		answers: 	#()
		file: 	nil
		repositories: 	spec

		goferPackage: 	nil
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil


MetacelloPackageSpec(MetacelloAbstractPackageSpec)>>requiredSpecsForPackageOrdering:
	Receiver: spec 
	name: 'Magritte-Developer';
	requires: #('PharoEnhancements' ).
	Arguments and temporary variables: 
		aVersionSpec: 	spec description: 'For pharo4.x, add Magritte-GT package and add ...etc..
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	nil
		mutable: 	nil
		name: 	'Magritte-Developer'
		requires: 	#('PharoEnhancements')
		includes: 	#()
		answers: 	#()
		file: 	nil
		repositories: 	spec

		goferPackage: 	nil
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil


MetacelloPackageSpec(MetacelloAbstractPackageSpec)>>requiredSpecNamesForPackageOrdering:
	Receiver: spec 
	name: 'Magritte-Developer';
	requires: #('PharoEnhancements' ).
	Arguments and temporary variables: 
		aVersionSpec: 	spec description: 'For pharo4.x, add Magritte-GT package and add ...etc..
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	nil
		mutable: 	nil
		name: 	'Magritte-Developer'
		requires: 	#('PharoEnhancements')
		includes: 	#()
		answers: 	#()
		file: 	nil
		repositories: 	spec

		goferPackage: 	nil
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil


MetacelloPackagesSpec>>sortPackageSpecs:packageSpec:groupLoops:for:
	Receiver: spec	add: [
		spec 
			name: 'Magritte-Tests-Pharo-Model';
			requires: #('Magritte-Pharo7...etc...
	Arguments and temporary variables: 
		movePackage: 	false
		targetSpecNames: 	nil
		targetIndex: 	nil
		groupLoopDetected: 	nil
		targetPackage: 	nil
		orderedSpecs: 	an OrderedCollection(spec 
	name: 'Grease';
	projectReference: [
...etc...
		packageSpec: 	spec 
	name: 'Magritte-Developer';
	requires: #('PharoEnhancements...etc...
		groupLoops: 	an IdentitySet()
		aVersionSpec: 	spec description: 'For pharo4.x, add Magritte-GT package and add ...etc...
		packageIndex: 	18
		moved: 	fals
	Receiver's instance variables: 
		project: 	BaselineOfMagritte(baseline [BaselineOfMagritte], )
		loader: 	nil
		mutable: 	nil
		list: 	an OrderedCollection(MetacelloMergeMemberSpec member: (spec 
	name: 'Grea...etc...
		memberMap: 	a Dictionary('Core'->spec 
	name: 'Core';
	includes: #('Magritte-Mod...etc...


[ :packageSpec | 
moved := moved
	or: [ self
			sortPackageSpecs: orderedPackageSpecs
			packageSpec: packageSpec
			groupLoops: groupLoops
			for: aVersionSpec ] ] in MetacelloPackagesSpec>>packageSpecsInLoadOrderFor:
	Receiver: spec	add: [
		spec 
			name: 'Magritte-Tests-Pharo-Model';
			requires: #('Magritte-Pharo7...etc...
	Arguments and temporary variables: 
THERE_BE_DRAGONS_HERE
IceVersionDoesNotExist: There is no version for package: Magritte-Tests-Pharo-Model in  commit 064b5b8ca9a087763d32d568142d5abbaf8139e5
25 August 2020 5:50:04.728771 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

[ IceVersionDoesNotExist new
	version: iceVersion;
	signal ] in IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>cull:
	Receiver: [ IceVersionDoesNotExist new
	version: iceVersion;
	signal ]
	Arguments and temporary variables: 
		anArg: 	IceMissingRepositoryEntry: source/Magritte-Tests-Pharo-Mode
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>mcVersionFor:
		startpc: 	147
		numArgs: 	0


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	IceMissingRepositoryEntry: source/Magritte-Tests-Pharo-Model
		value: 	ni
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion ...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	IceMissingRepositoryEntry: source/Magritte-Tests-Pharo-Mode
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion ...etc...


IceMissingRepositoryEntry(Exception)>>signal
	Receiver: IceMissingRepositoryEntry: source/Magritte-Tests-Pharo-Model
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	IceLibgitFiletreeFileUtils
		signalContext: 	IceMissingRepositoryEntry(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		name: 	'source/Magritte-Tests-Pharo-Model'
		owner: 	a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
')


[ IceMissingRepositoryEntry new
	name: aString;
	owner: aCommitOrTree;
	signal ] in IceLibgitFiletreeFileUtils class>>directoryFromPath:relativeTo:
	Receiver: IceLibgitFiletreeFileUtils
	Arguments and temporary variables: 
		aString: 	'source/Magritte-Tests-Pharo-Model'
		aCommitOrTree: 	a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
...etc..
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IceLibgitFiletreeFileUtils
		classPool: 	a Dictionary(#Current->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Libgit-Filetree'


LGitTree>>entryByRelativePath:ifAbsent:
	Receiver: a LGitTree (number of entries: 7)
	Arguments and temporary variables: 
		aString: 	'source/Magritte-Tests-Pharo-Model'
		aBlock: 	[ IceMissingRepositoryEntry new
	name: aString;
	owner: aCommitOrTree;
...etc...
		entry: 	a LGitTreeEntry (<not initialized>
	Receiver's instance variables: 
		handle: 	@ 16r7FC626D57C60
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		id: 	nil


LGitTree>>entryByPath:ifAbsent:
	Receiver: a LGitTree (number of entries: 7)
	Arguments and temporary variables: 
		aString: 	'source/Magritte-Tests-Pharo-Model'
		aBlock: 	[ IceMissingRepositoryEntry new
	name: aString;
	owner: aCommitOrTree;
...etc..
	Receiver's instance variables: 
		handle: 	@ 16r7FC626D57C60
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		id: 	nil


LGitCommit>>entryByPath:ifAbsent:
	Receiver: a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
')
	Arguments and temporary variables: 
		aString: 	'source/Magritte-Tests-Pharo-Model'
		aBlock: 	[ IceMissingRepositoryEntry new
	name: aString;
	owner: aCommitOrTree;
...etc..
	Receiver's instance variables: 
		handle: 	@ 16r7FC628279970
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)
		id: 	a LGitId ('064b5b8ca9a087763d32d568142d5abbaf8139e5')


IceLibgitFiletreeFileUtils class>>directoryFromPath:relativeTo:
	Receiver: IceLibgitFiletreeFileUtils
	Arguments and temporary variables: 
		aString: 	'source/Magritte-Tests-Pharo-Model'
		aCommitOrTree: 	a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
...etc..
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IceLibgitFiletreeFileUtils
		classPool: 	a Dictionary(#Current->nil )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Libgit-Filetree'


IceLibgitFiletreeReader(MCFileTreeAbstractReader)>>packageDirectory:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aDirectoryName: 	'source/Magritte-Tests-Pharo-Model
	Receiver's instance variables: 
		stream: 	a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
')
		package: 	nil
		info: 	nil
		definitions: 	nil
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	nil
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model)


IceLibgitFiletreeReader>>iceVersion:
	Receiver: an IceLibgitFiletreeReader
	Arguments and temporary variables: 
		anObject: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model
	Receiver's instance variables: 
		stream: 	a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
')
		package: 	nil
		info: 	nil
		definitions: 	nil
		dependencies: 	nil
		zip: 	nil
		infoCache: 	nil
		filename: 	nil
		packageDirectory: 	nil
		packageProperties: 	nil
		iceVersion: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model)


IceLibgitFiletreeReader class>>on:iceVersion:
	Receiver: IceLibgitFiletreeReader
	Arguments and temporary variables: 
		aCommitOrTree: 	a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
...etc...
		iceVersion: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model
	Receiver's instance variables: 
		superclass: 	MCFileTreeStCypressReader
		methodDict: 	a MethodDictionary(#commit->IceLibgitFiletreeReader>>#commit #fileU...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{IceLibgitFiletreeLogReader}
		name: 	#IceLibgitFiletreeReader
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Libgit-Filetree'


[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model)
		commit: 	a LGitCommit (064b5b8...f8139e5, 'removed pharo20 model package
'
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ IceVersionDoesNotExist new
	version: iceVersion;
	signal 
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>mcVersionFor:
		startpc: 	126
		numArgs: 	0


IceLibgitRepository>>mcVersionFor:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		iceVersion: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 89%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#2 2/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitCommit(IceCommitish)>>mcVersionFor:
	Receiver: IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5)
	Arguments and temporary variables: 
		anIceSavedPackageVersion: 	IceSavedPackageVersion(Magritte-Tests-Pharo-Model
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		id: 	'064b5b8ca9a087763d32d568142d5abbaf8139e5'
		author: 	'Norbert Hartl'
		datetime: 	2020-08-25T17:41:10+02:00
		ancestorIds: 	#('6bd2f901cacf4d6d2e5e5f57efa700ad81e624f1')
		comment: 	'removed pharo20 model package
'


IceSavedPackageVersion>>mcVersion
	Receiver: IceSavedPackageVersion(Magritte-Tests-Pharo-Model)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		entry: 	nil
		info: 	nil
		commit: 	IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5)
		package: 	IcePackage(Magritte-Tests-Pharo-Model, not loaded)


IceConvertFormatAction>>migratePackage:commit:
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		packageName: 	IcePackage(Magritte-Tests-Pharo-Model, not loaded)
		commit: 	IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5)
		filetreePackage: 	nil
		srcDir: 	File @ /Users/norbert/work/projects/magritte/source
		subDirWithDelim: 	'source/'
		mcVersion: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-3'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


[ :each | self migratePackage: each commit: commit ] in IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5)
		each: 	IcePackage(Magritte-Tests-Pharo-Model, not loaded
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-3'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | self migratePackage: each commit: commit ]
		index: 	
	Receiver's instance variables: 
an Array(IcePackage(Magritte-Tests-Pharo-Model, not loaded) IcePackage(Magritte-Developer,...etc...

IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(064b5b8ca9a087763d32d568142d5abbaf8139e5
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-3'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceConvertFormatAction>>execute
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		oldBranch: 	IceGitLocalBranch(migrate-sources-to-tonel-2)
		newBranch: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-3'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceTipFiletreeToTonelDialog>>doAccept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-3'
		repository: 	IceLibgitRepository(magritte)


[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-3'
		repository: 	IceLibgitRepository(magritte)


[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


BlockClosure>>cull:
	Receiver: [ :bar | aBlock value: bar ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		startpc: 	58
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ activeProcess psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ activeProcess psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	79
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	77
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[ :bar | aBlock value: bar 
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value 
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept 
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
[ IceVersionDoesNotExist new
	version: iceVersion;
	signal ] in IceLibgitRepository>>mcVersionFor:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
IceMissingRepositoryEntry(Exception)>>signal
[ IceMissingRepositoryEntry new
	name: aString;
	owner: aCommitOrTree;
	signal ] in IceLibgitFiletreeFileUtils class>>directoryFromPath:relativeTo:
LGitTree>>entryByRelativePath:ifAbsent:
LGitTree>>entryByPath:ifAbsent:
LGitCommit>>entryByPath:ifAbsent:
IceLibgitFiletreeFileUtils class>>directoryFromPath:relativeTo:
IceLibgitFiletreeReader(MCFileTreeAbstractReader)>>packageDirectory:
IceLibgitFiletreeReader>>iceVersion:
IceLibgitFiletreeReader class>>on:iceVersion:
[ | commit |
commit := iceVersion commit libgitCommit.
^ (iceVersion commit readerClass on: commit iceVersion: iceVersion)
	version ] in IceLibgitRepository>>mcVersionFor:
BlockClosure>>on:do:
IceLibgitRepository>>mcVersionFor:
IceGitCommit(IceCommitish)>>mcVersionFor:
IceSavedPackageVersion>>mcVersion
IceConvertFormatAction>>migratePackage:commit:
[ :each | self migratePackage: each commit: commit ] in IceConvertFormatAction>>migrateSources
Array(SequenceableCollection)>>do:
IceConvertFormatAction>>migrateSources
IceConvertFormatAction>>execute
IceTipFiletreeToTonelDialog>>doAccept
[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipFiletreeToTonelDialog>>accept
[ self accept ] in IceTipFiletreeToTonelDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
IceGenericError: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
25 August 2020 5:53:18.97883 pm

VM: Mac OS - x64 - 1015.6 - CoInterpreter * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
StackToRegisterMappingCogit * VMMaker-CompatibleUserName.1580983506 uuid: 7aff73cb-5a2e-5002-a356-37de4e762a49 Feb 12 2020
VM: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git Date: Wed Feb 12 11:07:12 2020 CommitHash: 2bd9e39 Plugins: 202002121007 https://github.com/pharo-project/opensmalltalk-vm.git

Image: Pharo8.0.0 [Build information: Pharo-8.0.0+build.1141.sha.1b7a8d8203fce2a57794451f555bba4222614081 (64 Bit)]

IceLibgitErrorVisitor>>visitGenericError:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-...etc..
	Receiver's instance variables: 
		context: 	IceLibgitRepository(magritte)


IceLibgitErrorVisitor>>visitERROR:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-...etc..
	Receiver's instance variables: 
		context: 	IceLibgitRepository(magritte)


LGit_GIT_ERROR>>acceptError:
	Receiver: LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisito
	Receiver's instance variables: 
		messageText: 	'invalid path: ''pharo-local/iceberg/seandenigris/Pharo-Enhancemen...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_index [10])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAl...etc...
		error: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-En...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 90%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-En...etc..
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	71
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Phar...etc...
		value: 	ni
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	add...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Phar...etc..
	Receiver's instance variables: 
		sender: 	nil
		pc: 	nil
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	add...etc...


LGit_GIT_ERROR(Exception)>>signal
	Receiver: LGit_GIT_ERROR: invalid path: 'pharo-local/iceberg/seandenigris/Pharo-Enhancements/'
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'invalid path: ''pharo-local/iceberg/seandenigris/Pharo-Enhancemen...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_error [-1])
		signalContext: 	LGit_GIT_ERROR(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_index [10])


LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ERROR
	Arguments and temporary variables: 
		anError: 	a LGitError (
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ERROR>>#acceptError: )
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ERROR
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_error [-1])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ERRO
	Receiver's instance variables: 
		value: 	-1


LGitIndex(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitIndex ()
	Arguments and temporary variables: 
		callBlock: 	[ self
	index_add_all: self
	pathspec: pathspec
	flags: 0
	callback:...etc..
	Receiver's instance variables: 
		handle: 	@ 16r7FE501B54190
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)


LGitIndex>>addAll:
	Receiver: a LGitIndex ()
	Arguments and temporary variables: 
		pathSpecs: 	#()
		pathspec: 	a LGitStringArray (
	Receiver's instance variables: 
		handle: 	@ 16r7FE501B54190
		repository: 	a LGitRepository (/Users/norbert/work/projects/magritte)


[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
			collect: [ :each | 
				self assert: each asFileReference isRelative.
				"self assert: (self location resolve: each) exists."
				each asFileReference path pathString ]
			as: Array).
gitIndex
	writeToDisk;
	free ] in IceLibgitRepository>>addFilesToIndex:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aCollection: 	a Set()
		gitIndex: 	a LGitIndex (
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 90%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


BlockClosure>>on:do:
	Receiver: [ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
	...etc...
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc..
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>addFilesToIndex:
		startpc: 	135
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAl...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 90%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceLibgitRepository>>addFilesToIndex:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aCollection: 	a Set(
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 90%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitIndex>>addToGitIndex
	Receiver: an IceGitIndex
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHandle defaultSignature ]
	on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR
	do: [ :e | IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].
index := self repositoryHandle index.
indexTreeId := index writeTreeAndReturnOid.
index free.
commitId := (LGitCommitBuilder of: self repositoryHandle)
	tree: (LGitTree of: self repositoryHandle fromId: indexTreeId);
	message: message withUnixLineEndings utf8Encoded asString;
	parents:
		(self repositoryHandle isUnborn
			ifTrue: [ #() ]
			ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: parentCommits ]);
	"'HEAD' branch could not exist yet. No problem, libgit will create it, 
				but we have to remember it to notify the frontend."
		updateReference:
		([ self repositoryHandle head name ]
			on: LGit_GIT_EUNBORNBRANCH
			do: [ repository branch gitRef ]);
	author: signature;
	committer: signature;
	writeCommit;
	commitId.	"FFI is expecting an string"
^ repository
	commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: commitId) ] in IceGitIndex>>commitWithMessage:andParents:
	Receiver: an IceGitIndex
	Arguments and temporary variables: 
		message: 	'sources migrated'
		parentCommits: 	an Array(IceGitCommit(1cb3f3a25fece4ef5f0becd396e2394ea40147e2))...etc...
		index: 	nil
		signature: 	nil
		commitId: 	nil
		indexTreeId: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


BlockClosure>>on:do:
	Receiver: [ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHan...etc...
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc..
	Receiver's instance variables: 
		outerContext: 	IceGitIndex>>commitWithMessage:andParents:
		startpc: 	356
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		aBlock: 	[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature :=...etc..
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 90%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceGitIndex>>commitWithMessage:andParents:
	Receiver: an IceGitIndex
	Arguments and temporary variables: 
		index: 	nil
		message: 	'sources migrated'
		parentCommits: 	an Array(IceGitCommit(1cb3f3a25fece4ef5f0becd396e2394ea40147e2))...etc..
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		modifiedFilePaths: 	a Set()


IceLibgitRepository(IceRepository)>>commitIndexWithMessage:andParents:
	Receiver: IceLibgitRepository(magritte)
	Arguments and temporary variables: 
		message: 	'sources migrated'
		parentCommitishList: 	an Array(IceGitCommit(1cb3f3a25fece4ef5f0becd396e2394ea401...etc...
		newCommit: 	ni
	Receiver's instance variables: 
		name: 	'magritte'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		commitsInPackageCache: 	a LRUCache(#1 1/30 [ 1 ] 90%)
		location: 	File @ /Users/norbert/work/projects/magritte
		commitCache: 	a LRUCache(#3 3/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/norbert/work/projects/magritte)


IceConvertFormatAction>>migrateSources
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		commit: 	IceGitCommit(1cb3f3a25fece4ef5f0becd396e2394ea40147e2
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-5'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceConvertFormatAction>>execute
	Receiver: an IceConvertFormatAction
	Arguments and temporary variables: 
		oldBranch: 	IceGitLocalBranch(cleanup)
		newBranch: 	ni
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(magritte)
		branchName: 	'migrate-sources-to-tonel-5'
		format: 	#tonel
		mergeWithCurrentBranch: 	false


IceTipFiletreeToTonelDialog>>doAccept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-5'
		repository: 	IceLibgitRepository(magritte)


[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
	Receiver: an IceTipFiletreeToTonelDialog
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	a DependentsArray(a MorphicContainerAdapter a MorphicContainerAdapt...etc...
		announcer: 	an Announcer
		focusOrder: 	an OrderedCollection(a CheckBoxPresenter an OkCancelToolbar)
		owner: 	nil
		window: 	a NewValueHolder[ a DialogWindowPresenter ]
		spec: 	a SpecWrapper
		extentHolder: 	a NewValueHolder[ nil ]
		needRebuild: 	a NewValueHolder[ true ]
		additionalKeyBindings: 	a Dictionary()
		keyStrokesForNextFocusHolder: 	a CollectionValueHolder[ an Array() ]
		keyStrokesForPreviousFocusHolder: 	a CollectionValueHolder[ an Array() ]
		windowIcon: 	a NewValueHolder[ nil ]
		aboutText: 	a NewValueHolder[ nil ]
		askOkToClose: 	a NewValueHolder[ false ]
		titleHolder: 	a CollectionValueHolder[ 'Convert sources to tonel' ]
		acceptButton: 	a ButtonPresenter
		cancelButton: 	a ButtonPresenter
		iconPanel: 	a MorphicGenericAdapter
		confirmLabel: 	a MorphicGenericAdapter
		mergeWithMasterCheckbox: 	a CheckBoxPresenter
		branchName: 	'migrate-sources-to-tonel-5'
		repository: 	IceLibgitRepository(magritte)


[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aString: 	'Migrating magritte sources to tonel'
		aBlock: 	[ self doAccept ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value ]
		bar: 	a Jo
	Receiver's instance variables: 
		activeTranscript: 	nil


BlockClosure>>cull:
	Receiver: [ :bar | aBlock value: bar ]
	Arguments and temporary variables: 
		anArg: 	a Jo
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>informUserDuring:
		startpc: 	58
		numArgs: 	1


[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


BlockClosure>>ensure:
	Receiver: [ activeProcess psValueAt: index put: anObject.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ activeProcess psValueAt: index put: oldValue ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	CurrentJob(DynamicVariable)>>value:during:
		startpc: 	79
		numArgs: 	0


CurrentJob(DynamicVariable)>>value:during:
	Receiver: a CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self ]
		activeProcess: 	a Process in nil
		oldValue: 	ni
	Receiver's instance variables: 
		index: 	2


CurrentJob class(DynamicVariable class)>>value:during:
	Receiver: CurrentJob
	Arguments and temporary variables: 
		anObject: 	a Job
		aBlock: 	[ ^ block cull: self 
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentJob
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Jobs-Base'
		soleInstance: 	a CurrentJob


[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


BlockClosure>>ensure:
	Receiver: [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ]
	Arguments and temporary variables: 
		aBlock: 	[ self cleanupAfterRunning ]
		complete: 	nil
		returnValue: 	ni
	Receiver's instance variables: 
		outerContext: 	Job>>run
		startpc: 	77
		numArgs: 	0


Job>>run
	Receiver: a Job
	Arguments and temporary variables: 

	Receiver's instance variables: 
		block: 	[ :bar | aBlock value: bar ]
		currentValue: 	1
		min: 	1
		max: 	100
		title: 	'Migrating magritte sources to tonel'
		children: 	an OrderedCollection()
		isRunning: 	false
		parent: 	nil
		process: 	nil


MorphicUIManager(UIManager)>>displayProgress:from:to:during:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		titleString: 	''
		minVal: 	1
		maxVal: 	100
		workBlock: 	[ :bar | aBlock value: bar 
	Receiver's instance variables: 
		activeTranscript: 	nil


MorphicUIManager>>informUserDuring:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		aBlock: 	[ :bar | 
bar label: aString.
aBlock value 
	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceLibgitErrorVisitor>>visitGenericError:
IceLibgitErrorVisitor>>visitERROR:
LGit_GIT_ERROR>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ERROR(Exception)>>signal
LGit_GIT_ERROR class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitIndex(LGitExternalObject)>>withReturnHandlerDo:
LGitIndex>>addAll:
[ | gitIndex |
gitIndex := self repositoryHandle index.
gitIndex
	addAll:
		(aCollection
			collect: [ :each | 
				self assert: each asFileReference isRelative.
				"self assert: (self location resolve: each) exists."
				each asFileReference path pathString ]
			as: Array).
gitIndex
	writeToDisk;
	free ] in IceLibgitRepository>>addFilesToIndex:
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceLibgitRepository>>addFilesToIndex:
IceGitIndex>>addToGitIndex
[ | signature commitId indexTreeId |
self addToGitIndex.
[ signature := self repositoryHandle defaultSignature ]
	on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR
	do: [ :e | IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].
index := self repositoryHandle index.
indexTreeId := index writeTreeAndReturnOid.
index free.
commitId := (LGitCommitBuilder of: self repositoryHandle)
	tree: (LGitTree of: self repositoryHandle fromId: indexTreeId);
	message: message withUnixLineEndings utf8Encoded asString;
	parents:
		(self repositoryHandle isUnborn
			ifTrue: [ #() ]
			ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: parentCommits ]);
	"'HEAD' branch could not exist yet. No problem, libgit will create it, 
				but we have to remember it to notify the frontend."
		updateReference:
		([ self repositoryHandle head name ]
			on: LGit_GIT_EUNBORNBRANCH
			do: [ repository branch gitRef ]);
	author: signature;
	committer: signature;
	writeCommit;
	commitId.	"FFI is expecting an string"
^ repository
	commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: commitId) ] in IceGitIndex>>commitWithMessage:andParents:
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitIndex>>commitWithMessage:andParents:
IceLibgitRepository(IceRepository)>>commitIndexWithMessage:andParents:
IceConvertFormatAction>>migrateSources
IceConvertFormatAction>>execute
IceTipFiletreeToTonelDialog>>doAccept
[ self doAccept ] in IceTipFiletreeToTonelDialog>>accept
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipFiletreeToTonelDialog>>accept
[ self accept ] in IceTipFiletreeToTonelDialog(IceTipDialog)>>openDialogWithSpec
[ okAction value value == false
	ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ] in OkCancelToolbar(OkToolbar)>>okActionBlock
ButtonPresenter>>performAction
MorphicButtonAdapter>>action
PluggableButtonMorph>>performAction:
[ :m | 
(m containsPoint: evt cursorPoint)
	ifTrue: [ m enabled
			ifTrue: [ m performAction: evt ] ] ] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

