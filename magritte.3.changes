----QUIT----2020-08-09T09:11:15.942155+02:00 Pharo8.0-SNAPSHOT-32bit-1b7a8d8.image priorSource: 0!----QUIT----2020-08-09T09:11:39.059314+02:00 Pharo8.0-SNAPSHOT-32bit-1b7a8d8.image priorSource: 0!----End fileIn----!----SNAPSHOT----2020-08-25T17:32:31.17906+02:00 magritte.image priorSource: 100!----SNAPSHOT----2020-08-25T17:33:33.268266+02:00 magritte.2.image priorSource: 221!----QUIT----2020-08-25T17:33:35.236794+02:00 magritte.2.image priorSource: 303!!IceTipRepositoryBrowser methodsFor: 'event handling' stamp: 'AutoDeprecationRefactoring 8/25/2020 17:35' prior: 31220318!commitishSelected: ann	| selection |	ann newSelectedIndexes		ifNotEmpty: [ :indexes | 			selection := sidebarTree widget dataSource elementAt: indexes first.			(selection depth = 0 or: [ selection hasChildren ])				ifTrue: [ ^ self	"just refresh on leafs" ].			historyPanel model: selection data model ]! !----QUIT/NOSAVE----2020-08-25T17:36:05.17328+02:00 magritte.2.image priorSource: 388!!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline300ForGemStone: spec	spec		for: #gemstone		do: [ 			spec				project: 'GsCore'				with: [ 					spec						className: 'ConfigurationOfGsCore';						versionString: #bleedingEdge;						repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].			spec				package: 'Magritte-Model'					with: [ 							spec								requires: #('GsCore');								includes: #('Magritte-GemStone-Model') ];				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-GemStone-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-GemStone-Seaside') ];				package: 'Magritte-GemStone-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-GemStone-Model' with: [ spec requires: #('Magritte-GemStone-Model') ];				package: 'Magritte-GemStone-Seaside' with: [ spec requires: #('Magritte-Seaside') ] ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline310CommonExtDeps: spec	"Common external dependencies for baseline 3.1.0"	spec		baseline: 'Grease' with: [ spec repository: 'github://SeasideSt/Grease:v1.5.x/repository' ];		baseline: 'Seaside3'			with: [ "note: we do not want to depend on Zinc, since this is not present in Squeak. Currently no adapter is loaded"			spec				repository: 'github://SeasideSt/Seaside:master/repository';				loads: #('Core') ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330: spec	<baseline>	spec		for: #common		do: [ 			spec author: 'SeanDeNigris'.			spec timestamp: '2015-04-05'.			spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'.			self baseline310CommonExtDeps: spec.			spec				package: 'Magritte-Model' with: [ 					spec 						requires: #('Grease');						includes: #('Magritte-Deprecated3dot7') ];				package: 'Magritte-Deprecated3dot7' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Seaside' with: [ spec requires: #('Magritte-Model' 'Seaside3') ];				package: 'Magritte-Bootstrap' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Deprecated' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Merging' with: [ spec requires: #('Magritte-Model') ].			spec				group: 'Core' with: #('Magritte-Model');				group: 'Tests' with: #('Magritte-Tests-Model');				group: 'Seaside' with: #('Magritte-Seaside');				group: 'Deprecated' with: #('Magritte-Deprecated') ].	self baseline330ForPharo: spec.	self baseline300ForGemStone: spec! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ].			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ spec requires: #('PharoEnhancements') ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !"BaselineOfMagritte"!!BaselineOfPharoEnhancements methodsFor: 'baseline'!baseline: spec	<baseline>	spec for: #common do: [ spec package: 'PharoEnhancements' ]! !"BaselineOfPharoEnhancements"!!ManifestPharoEnhancements commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!Object methodsFor: '*PharoEnhancements' prior: 54747038!fuelOut	| target |	target := FileLocator imageDirectory / self printString asFileName, 'fuel'.	self serializeToFileNamed: target nextVersion fullName! !!MailMessage methodsFor: '*PharoEnhancements'!timestamp	| dateField dateString isWeekdayPresent safeDateString |	dateField := self 		fieldNamed: 'date'		ifAbsent: [ ^ nil ].	"These header values seem to start with a weekday e.g. 'Thu, ' which breaks Pharo's DateAndTime parsing"	dateString := dateField mainValue.	isWeekdayPresent := dateString includes: $,.	safeDateString := isWeekdayPresent		ifTrue: [ 			| dateStringNoWeekday |			dateStringNoWeekday := dateString copyAfter: $,.			dateStringNoWeekday trimLeft ]		ifFalse: [ dateString ].	^ safeDateString asDateAndTime! !!FileLocator class methodsFor: '*PharoEnhancements'!dynabookData	^ self origin: #dynabookData! !!GTPlayBook class methodsFor: '*PharoEnhancements'!browseAll	<script>	GTPlayBook instance allFiles inspect! !!GTPlayBook class methodsFor: '*PharoEnhancements'!browseNamed	<script>	(GTPlayBook instance allFiles reject: [ :e | e basename prefixMatchesRegex: '\d\d\d\d-' ]) inspect! !!GTPlayBook class methodsFor: '*PharoEnhancements'!menuCommandOn: aBuilder	<worldMenu>	(aBuilder item: #'Play Pages')		parent: 'Tools';		with: [			(aBuilder item: #'Browse All')				action: [ self browseAll ]; 				icon: Smalltalk tools workspace taskbarIcon.			(aBuilder item: #'Browse Named')				action: [ self browseNamed ]; 				icon: Smalltalk tools workspace taskbarIcon. ]! !!String methodsFor: '*PharoEnhancements'!asEncodedUrl	"Send this instead of `#asUrl` if I potentially have characters not allowed by the URL spec, which Zinc enforces on input to its parser. Example: `'https://en.wikipedia.org/wiki/Česká republika' asEncodedUrl`"	| encodedString |	encodedString := String streamContents: [ :out | 		self do: [ :each | 			(each codePoint < 127 and: [ each ~= Character space ])				ifTrue: [ out nextPut: each ]				ifFalse: [ out nextPutAll: each asString urlEncoded ] ] ].	^ encodedString asUrl! !!String methodsFor: '*PharoEnhancements'!asFilename	"`#asFileName` leaves in $: which mac doesn't like"	| result |	result := self asFileName copyReplaceAll: ':' with: '#'.	self assert: (#('' '/' '..' '.' '\') includes: result) not. "Agressively protect against wonky FS resolution of special strings"	^ result! !!String methodsFor: '*PharoEnhancements'!surroundedByDoubleQuotes	^ self surroundedBy: '"'! !!RPackage methodsFor: '*PharoEnhancements'!createBaselineOf	"Example:		(RPackage named: 'MyCoolPackage') createBaselineOf	"	(MetacelloToolBox baselineNamed: self name)		createBaselineOfMethod: 'baseline:' inCategory: 'baseline';		addBaselineOfSection: #common			requiredProjects: #() "This means Configs, not Baselines, so will usually be empty"			packages: { self name }			repositories: #()			dependencies: #() "Could calculate from Dependency Analyzer?"			groups: #()			versionSpecsDo: [ :versionSpec |  ];		commitBaselineOfMethod! !!DateAndTime methodsFor: '*PharoEnhancements'!printUS	^ self asDate mmddyyyy, ' @ ', self asTime printMinutes.! !!ConfigurationOf class methodsFor: '*PharoEnhancements'!createBaselineFrom: selector	| projectName baselineName baseline methodTree commonBlockBody |		"Create new class"	projectName := self name allButFirst: self superclass name size.	baselineName := 'BaselineOf', projectName.	baseline := BaselineOf subclass: baselineName asSymbol	instanceVariableNames: ''	classVariableNames: ''	category: baselineName.		"Convert baseline##: method"	methodTree := (self methodNamed: selector) parseTree.	methodTree selector: #baseline:.	methodTree pragmas at: 1 put: (RBPragmaNode selector: #baseline arguments: #()).	commonBlockBody := methodTree statements first arguments last body.	commonBlockBody statements		detect: [ :e | e selector = #repository: ]		ifFound: [ :repoSetter | commonBlockBody removeNode: repoSetter ].		"Compile baseline method"	baseline compile: methodTree newSource classified: 'baseline'! !!Date methodsFor: '*PharoEnhancements'!addYears: anInteger	| targetYear isLeapDay |	targetYear := self year + anInteger.		isLeapDay := self monthIndex = 2 and: [ self dayOfMonth = 29 ].	isLeapDay		ifTrue: [ 			^ self class 					year: targetYear					day: self start dayOfYear ].		^ self class 			year: targetYear			month: self monthIndex			day: self dayOfMonth! !!Date methodsFor: '*PharoEnhancements'!subtractYears: anInteger	^ self addYears: anInteger negated! !!Date methodsFor: '*PharoEnhancements'!yearsSince: aDate	"Returns aNumber whose fractional part = fraction of the year from last to next anniversary rounded to the day"	| fullYears lastAnniversary nextAnniversary partialYear |	fullYears := 0.	self year = aDate year ifTrue: [ fullYears := 0 ].	fullYears := self year - aDate year.	lastAnniversary := Date year: self year month: aDate monthIndex day: aDate dayOfMonth.	nextAnniversary := Date year: self year + 1 month: aDate monthIndex day: aDate dayOfMonth.	partialYear := (self - lastAnniversary) / (nextAnniversary - lastAnniversary).	^ (self monthIndex > aDate monthIndex or: [ self monthIndex = aDate monthIndex and: [ self dayOfMonth >= aDate dayOfMonth ] ])		ifTrue: [ fullYears + partialYear ]		ifFalse: [ fullYears - partialYear ]! !!EpCodeChange class methodsFor: '*PharoEnhancements'!allAffectingPackagesNamed: aBlock	| nodes entries filter filteredEntries groups |	"To see diffs on the changes, you could do:	events collect: [ :e | 		DiffModel new			showOptions: true;			leftText: (e accept: EpOldStateVisitor new);			rightText: (e accept: EpNewStateVisitor new);			contextClass: e class;			buildWithSpec ]"	nodes := EpFileLogNode fromAllLogsIn: EpMonitor current sessionStore baseLocator.	nodes do: [ :node | node populateReferencedNodesWith: nodes ].	entries := nodes flatCollect: [ :n | n log entries ].	filter := EpAndFilter		withAll:			{(EpImpactCodeChangeFilter new				environment: self class environment;				yourself).			(EpPluggableFilter new condition: [ :e | e content isCodeChange and: [ aBlock value: e content affectedPackageName ] ]).			EpPluggableFilter noTriggerFilter}.	filteredEntries := entries select: [ :e | filter accepts: e ].	filteredEntries sort: [ :a :b | (a tagAt: #time) > (b tagAt: #time) ].	groups := filteredEntries		groupedBy: [ :e | 			(e content respondsTo: #methodAffected)				ifFalse: [ '?' ]				ifTrue: [ e content methodAffected ] ].	^ groups collect: [ :col | col first content ] as: OrderedCollection.! !!HandMorph methodsFor: '*PharoEnhancements' prior: 29185119!generateKeyboardEvent: evtBuf	"Override to get horizontal scrolling"	| buttons modifiers type pressType stamp charCode keyValue keyEvent |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown		ifTrue: [			type := #keyDown.			lastKeyScanCode := evtBuf third].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [		type := #keystroke].	modifiers := evtBuf fifth.	buttons := modifiers bitShift: 3.	keyValue := evtBuf third. 	charCode := evtBuf sixth.	type = #keystroke		ifTrue: [combinedChar			ifNil: [				| peekedEvent |				peekedEvent := Sensor peekEvent.				(peekedEvent notNil					and: [peekedEvent fourth = EventKeyDown])					ifTrue: [						(CombinedChar isCompositionCharacter: charCode)							ifTrue: [								combinedChar := CombinedChar new.								combinedChar simpleAdd: charCode asCharacter.								(combinedChar combinesWith: peekedEvent third asCharacter)									ifTrue: [^nil].								]]]			ifNotNil: [				(combinedChar simpleAdd: charCode asCharacter)					ifTrue: [charCode := combinedChar combined charCode].				combinedChar := nil]].	self flag: #fixme.	"This piece of code handles the creation of scrolling events. When a scroll is done by the user, the VM forwards a keystroke event with the up/down key. So we reconvert it to a MouseWheelEvent in that case."	(type = #keystroke and: [(buttons anyMask: 16) and: [ charCode asCharacter isArrow ]])		ifTrue: [^ MouseWheelEvent					fromCharacter: charCode asCharacter					position: lastMouseEvent cursorPoint					buttons: buttons					hand: self					stamp: stamp].	keyEvent := KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: keyValue		charCode: charCode		hand: self		stamp: stamp.	keyEvent scanCode: lastKeyScanCode.	^keyEvent! !!ManifestPharoEnhancements class methodsFor: 'code-critics'!ruleGRUsesCurlyBraceArraysRuleV1FalsePositive	^ #(#(#(#RGPackage #(#PharoEnhancements)) #'2018-08-26T16:20:35.927752+00:00') )! !!PluggableTextFieldMorph methodsFor: '*PharoEnhancements' prior: 55785305!entryCompletion: anEntryCompletion	entryCompletion := anEntryCompletion.	entryCompletion ifNotNil: [ 		entryCompletion chooseBlock isNil			ifTrue: [ entryCompletion					chooseBlock: [ :v | 						self setText: v.						self acceptTextInModel ] ]			ifFalse: [ | blk |				blk := entryCompletion chooseBlock.				entryCompletion					chooseBlock: [ :v | 						(blk value: v) = true							ifTrue: [ 								self setText: v.								self acceptTextInModel ] ] ] ]! !!PeDateTest methodsFor: 'tests'!testAddYears	| start increment cases expected |	cases := { 		{ '3/1/2016'. 1. '3/1/2017' }.				"Leap year"		{ '2/29/2016'. 4. '2/29/2020' }.		{ '2/29/2016'. 1. '3/1/2017' }.	}.		cases do: [ :e |		start := e first asDate.		increment := e second.		expected := e third asDate.				self assert: (start addYears: increment) equals: expected ]! !!PeDateTest methodsFor: 'tests'!testSubtractYears	| start increment cases expected |	cases := { 		{ '3/1/2016'. 1. '3/1/2015' }.				"Leap year"		{ '2/29/2016'. 4. '2/29/2012' }.		{ '2/29/2016'. 1. '3/1/2015' }.	}.		cases do: [ :e |		start := e first asDate.		increment := e second.		expected := e third asDate.				self assert: (start subtractYears: increment) equals: expected ]! !!PeDateTest methodsFor: 'tests'!testYearsSince	| start end cases expected |	"See #yearsSince: method comment for explanation of return value"	cases := { 		{ '1/1/2018'. '1/2/2018'. 1 / 365 }.		{ '1/1/2018'. '1/1/2019'. 1 }.		{ '1/1/2018'. '1/2/2019'. 1 + (1 / 365) }.				"Leap year"		{ '1/1/2016'. '1/1/2017'. 1 }.		{ '2/28/2016'. '3/1/2016'. 2 / 366 }.	}.		cases do: [ :e |		start := e first asDate.		end := e second asDate.		expected := e third.				self assert: (end yearsSince: start) equals: expected ]! !!SystemResolver methodsFor: '*PharoEnhancements'!dynabookData 	<origin>	^ (FileLocator home / 'Dynabook' / 'User Data') resolve! !!AbstractFileReference methodsFor: '*PharoEnhancements'!isMD5Equal: aReference	| sourceHash targetHash |	sourceHash := self binaryReadStreamDo: [ :str | MD5 hashStream: str ].	targetHash := aReference binaryReadStreamDo: [ :str | MD5 hashStream: str ].	^ sourceHash = targetHash! !!AbstractFileReference methodsFor: '*PharoEnhancements'!macLock: aBoolean	"Adapted from https://macosx.com/threads/lock-unlock-files-with-the-terminal.317350/"	| keyword commandTemplate command |	OSPlatform current isMacOSX ifFalse: [ ^ self ].	keyword := aBoolean		ifTrue: [ 'uchg' ]		ifFalse: [ 'nouchg' ].	commandTemplate := 'chflags {keyword} "{fileName}"'.	command := commandTemplate format: { 		#keyword -> keyword.		#fileName -> self fullName } asDictionary.	LibC system: command! !!AbstractFileReference methodsFor: '*PharoEnhancements'!open	LibC system: 'open "', self fullName, '"'! !!AbstractFileReference methodsFor: '*PharoEnhancements'!preview	"Reference: http://www.maclife.com/article/columns/easy_mac_hacks_using_quicklook_command_line"	LibC system: '/usr/bin/qlmanage -p "', self fullName, '" &'! !!AbstractFileReference methodsFor: '*PharoEnhancements'!showInFinder	LibC system: 'open --reveal ', (self fullName surroundedBy: '"')! !!AbstractFileReference methodsFor: '*PharoEnhancements'!verifiedCopyTo: aReference	| result |	result := self copyTo: aReference.	(self isMD5Equal: aReference) ifFalse: [ self error: 'Copy hash has changed!!' ].	^ result! !!AbstractFileReference methodsFor: '*PharoEnhancements'!verifiedMoveTo: aFileReference	self verifiedCopyTo: aFileReference.	self delete! !"PharoEnhancements"!----SNAPSHOT----2020-08-25T17:45:31.2062+02:00 magritte.3.image priorSource: 388!