----QUIT----2020-08-09T09:11:15.942155+02:00 Pharo8.0-SNAPSHOT-32bit-1b7a8d8.image priorSource: 0!----QUIT----2020-08-09T09:11:39.059314+02:00 Pharo8.0-SNAPSHOT-32bit-1b7a8d8.image priorSource: 0!----End fileIn----!----SNAPSHOT----2020-08-25T17:32:31.17906+02:00 magritte.image priorSource: 100!----SNAPSHOT----2020-08-25T17:33:33.268266+02:00 magritte.2.image priorSource: 221!----QUIT----2020-08-25T17:33:35.236794+02:00 magritte.2.image priorSource: 303!!IceTipRepositoryBrowser methodsFor: 'event handling' stamp: 'AutoDeprecationRefactoring 8/25/2020 17:35' prior: 31220318!commitishSelected: ann	| selection |	ann newSelectedIndexes		ifNotEmpty: [ :indexes | 			selection := sidebarTree widget dataSource elementAt: indexes first.			(selection depth = 0 or: [ selection hasChildren ])				ifTrue: [ ^ self	"just refresh on leafs" ].			historyPanel model: selection data model ]! !----QUIT/NOSAVE----2020-08-25T17:36:05.17328+02:00 magritte.2.image priorSource: 388!!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline300ForGemStone: spec	spec		for: #gemstone		do: [ 			spec				project: 'GsCore'				with: [ 					spec						className: 'ConfigurationOfGsCore';						versionString: #bleedingEdge;						repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].			spec				package: 'Magritte-Model'					with: [ 							spec								requires: #('GsCore');								includes: #('Magritte-GemStone-Model') ];				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-GemStone-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-GemStone-Seaside') ];				package: 'Magritte-GemStone-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-GemStone-Model' with: [ spec requires: #('Magritte-GemStone-Model') ];				package: 'Magritte-GemStone-Seaside' with: [ spec requires: #('Magritte-Seaside') ] ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline310CommonExtDeps: spec	"Common external dependencies for baseline 3.1.0"	spec		baseline: 'Grease' with: [ spec repository: 'github://SeasideSt/Grease:v1.5.x/repository' ];		baseline: 'Seaside3'			with: [ "note: we do not want to depend on Zinc, since this is not present in Squeak. Currently no adapter is loaded"			spec				repository: 'github://SeasideSt/Seaside:master/repository';				loads: #('Core') ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330: spec	<baseline>	spec		for: #common		do: [ 			spec author: 'SeanDeNigris'.			spec timestamp: '2015-04-05'.			spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'.			self baseline310CommonExtDeps: spec.			spec				package: 'Magritte-Model' with: [ 					spec 						requires: #('Grease');						includes: #('Magritte-Deprecated3dot7') ];				package: 'Magritte-Deprecated3dot7' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Seaside' with: [ spec requires: #('Magritte-Model' 'Seaside3') ];				package: 'Magritte-Bootstrap' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Deprecated' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Merging' with: [ spec requires: #('Magritte-Model') ].			spec				group: 'Core' with: #('Magritte-Model');				group: 'Tests' with: #('Magritte-Tests-Model');				group: 'Seaside' with: #('Magritte-Seaside');				group: 'Deprecated' with: #('Magritte-Deprecated') ].	self baseline330ForPharo: spec.	self baseline300ForGemStone: spec! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ].			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ spec requires: #('PharoEnhancements') ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !"BaselineOfMagritte"!!BaselineOfPharoEnhancements methodsFor: 'baseline'!baseline: spec	<baseline>	spec for: #common do: [ spec package: 'PharoEnhancements' ]! !"BaselineOfPharoEnhancements"!!ManifestPharoEnhancements commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!Object methodsFor: '*PharoEnhancements' prior: 54747038!fuelOut	| target |	target := FileLocator imageDirectory / self printString asFileName, 'fuel'.	self serializeToFileNamed: target nextVersion fullName! !!MailMessage methodsFor: '*PharoEnhancements'!timestamp	| dateField dateString isWeekdayPresent safeDateString |	dateField := self 		fieldNamed: 'date'		ifAbsent: [ ^ nil ].	"These header values seem to start with a weekday e.g. 'Thu, ' which breaks Pharo's DateAndTime parsing"	dateString := dateField mainValue.	isWeekdayPresent := dateString includes: $,.	safeDateString := isWeekdayPresent		ifTrue: [ 			| dateStringNoWeekday |			dateStringNoWeekday := dateString copyAfter: $,.			dateStringNoWeekday trimLeft ]		ifFalse: [ dateString ].	^ safeDateString asDateAndTime! !!FileLocator class methodsFor: '*PharoEnhancements'!dynabookData	^ self origin: #dynabookData! !!GTPlayBook class methodsFor: '*PharoEnhancements'!browseAll	<script>	GTPlayBook instance allFiles inspect! !!GTPlayBook class methodsFor: '*PharoEnhancements'!browseNamed	<script>	(GTPlayBook instance allFiles reject: [ :e | e basename prefixMatchesRegex: '\d\d\d\d-' ]) inspect! !!GTPlayBook class methodsFor: '*PharoEnhancements'!menuCommandOn: aBuilder	<worldMenu>	(aBuilder item: #'Play Pages')		parent: 'Tools';		with: [			(aBuilder item: #'Browse All')				action: [ self browseAll ]; 				icon: Smalltalk tools workspace taskbarIcon.			(aBuilder item: #'Browse Named')				action: [ self browseNamed ]; 				icon: Smalltalk tools workspace taskbarIcon. ]! !!String methodsFor: '*PharoEnhancements'!asEncodedUrl	"Send this instead of `#asUrl` if I potentially have characters not allowed by the URL spec, which Zinc enforces on input to its parser. Example: `'https://en.wikipedia.org/wiki/Česká republika' asEncodedUrl`"	| encodedString |	encodedString := String streamContents: [ :out | 		self do: [ :each | 			(each codePoint < 127 and: [ each ~= Character space ])				ifTrue: [ out nextPut: each ]				ifFalse: [ out nextPutAll: each asString urlEncoded ] ] ].	^ encodedString asUrl! !!String methodsFor: '*PharoEnhancements'!asFilename	"`#asFileName` leaves in $: which mac doesn't like"	| result |	result := self asFileName copyReplaceAll: ':' with: '#'.	self assert: (#('' '/' '..' '.' '\') includes: result) not. "Agressively protect against wonky FS resolution of special strings"	^ result! !!String methodsFor: '*PharoEnhancements'!surroundedByDoubleQuotes	^ self surroundedBy: '"'! !!RPackage methodsFor: '*PharoEnhancements'!createBaselineOf	"Example:		(RPackage named: 'MyCoolPackage') createBaselineOf	"	(MetacelloToolBox baselineNamed: self name)		createBaselineOfMethod: 'baseline:' inCategory: 'baseline';		addBaselineOfSection: #common			requiredProjects: #() "This means Configs, not Baselines, so will usually be empty"			packages: { self name }			repositories: #()			dependencies: #() "Could calculate from Dependency Analyzer?"			groups: #()			versionSpecsDo: [ :versionSpec |  ];		commitBaselineOfMethod! !!DateAndTime methodsFor: '*PharoEnhancements'!printUS	^ self asDate mmddyyyy, ' @ ', self asTime printMinutes.! !!ConfigurationOf class methodsFor: '*PharoEnhancements'!createBaselineFrom: selector	| projectName baselineName baseline methodTree commonBlockBody |		"Create new class"	projectName := self name allButFirst: self superclass name size.	baselineName := 'BaselineOf', projectName.	baseline := BaselineOf subclass: baselineName asSymbol	instanceVariableNames: ''	classVariableNames: ''	category: baselineName.		"Convert baseline##: method"	methodTree := (self methodNamed: selector) parseTree.	methodTree selector: #baseline:.	methodTree pragmas at: 1 put: (RBPragmaNode selector: #baseline arguments: #()).	commonBlockBody := methodTree statements first arguments last body.	commonBlockBody statements		detect: [ :e | e selector = #repository: ]		ifFound: [ :repoSetter | commonBlockBody removeNode: repoSetter ].		"Compile baseline method"	baseline compile: methodTree newSource classified: 'baseline'! !!Date methodsFor: '*PharoEnhancements'!addYears: anInteger	| targetYear isLeapDay |	targetYear := self year + anInteger.		isLeapDay := self monthIndex = 2 and: [ self dayOfMonth = 29 ].	isLeapDay		ifTrue: [ 			^ self class 					year: targetYear					day: self start dayOfYear ].		^ self class 			year: targetYear			month: self monthIndex			day: self dayOfMonth! !!Date methodsFor: '*PharoEnhancements'!subtractYears: anInteger	^ self addYears: anInteger negated! !!Date methodsFor: '*PharoEnhancements'!yearsSince: aDate	"Returns aNumber whose fractional part = fraction of the year from last to next anniversary rounded to the day"	| fullYears lastAnniversary nextAnniversary partialYear |	fullYears := 0.	self year = aDate year ifTrue: [ fullYears := 0 ].	fullYears := self year - aDate year.	lastAnniversary := Date year: self year month: aDate monthIndex day: aDate dayOfMonth.	nextAnniversary := Date year: self year + 1 month: aDate monthIndex day: aDate dayOfMonth.	partialYear := (self - lastAnniversary) / (nextAnniversary - lastAnniversary).	^ (self monthIndex > aDate monthIndex or: [ self monthIndex = aDate monthIndex and: [ self dayOfMonth >= aDate dayOfMonth ] ])		ifTrue: [ fullYears + partialYear ]		ifFalse: [ fullYears - partialYear ]! !!EpCodeChange class methodsFor: '*PharoEnhancements'!allAffectingPackagesNamed: aBlock	| nodes entries filter filteredEntries groups |	"To see diffs on the changes, you could do:	events collect: [ :e | 		DiffModel new			showOptions: true;			leftText: (e accept: EpOldStateVisitor new);			rightText: (e accept: EpNewStateVisitor new);			contextClass: e class;			buildWithSpec ]"	nodes := EpFileLogNode fromAllLogsIn: EpMonitor current sessionStore baseLocator.	nodes do: [ :node | node populateReferencedNodesWith: nodes ].	entries := nodes flatCollect: [ :n | n log entries ].	filter := EpAndFilter		withAll:			{(EpImpactCodeChangeFilter new				environment: self class environment;				yourself).			(EpPluggableFilter new condition: [ :e | e content isCodeChange and: [ aBlock value: e content affectedPackageName ] ]).			EpPluggableFilter noTriggerFilter}.	filteredEntries := entries select: [ :e | filter accepts: e ].	filteredEntries sort: [ :a :b | (a tagAt: #time) > (b tagAt: #time) ].	groups := filteredEntries		groupedBy: [ :e | 			(e content respondsTo: #methodAffected)				ifFalse: [ '?' ]				ifTrue: [ e content methodAffected ] ].	^ groups collect: [ :col | col first content ] as: OrderedCollection.! !!HandMorph methodsFor: '*PharoEnhancements' prior: 29185119!generateKeyboardEvent: evtBuf	"Override to get horizontal scrolling"	| buttons modifiers type pressType stamp charCode keyValue keyEvent |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown		ifTrue: [			type := #keyDown.			lastKeyScanCode := evtBuf third].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [		type := #keystroke].	modifiers := evtBuf fifth.	buttons := modifiers bitShift: 3.	keyValue := evtBuf third. 	charCode := evtBuf sixth.	type = #keystroke		ifTrue: [combinedChar			ifNil: [				| peekedEvent |				peekedEvent := Sensor peekEvent.				(peekedEvent notNil					and: [peekedEvent fourth = EventKeyDown])					ifTrue: [						(CombinedChar isCompositionCharacter: charCode)							ifTrue: [								combinedChar := CombinedChar new.								combinedChar simpleAdd: charCode asCharacter.								(combinedChar combinesWith: peekedEvent third asCharacter)									ifTrue: [^nil].								]]]			ifNotNil: [				(combinedChar simpleAdd: charCode asCharacter)					ifTrue: [charCode := combinedChar combined charCode].				combinedChar := nil]].	self flag: #fixme.	"This piece of code handles the creation of scrolling events. When a scroll is done by the user, the VM forwards a keystroke event with the up/down key. So we reconvert it to a MouseWheelEvent in that case."	(type = #keystroke and: [(buttons anyMask: 16) and: [ charCode asCharacter isArrow ]])		ifTrue: [^ MouseWheelEvent					fromCharacter: charCode asCharacter					position: lastMouseEvent cursorPoint					buttons: buttons					hand: self					stamp: stamp].	keyEvent := KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: keyValue		charCode: charCode		hand: self		stamp: stamp.	keyEvent scanCode: lastKeyScanCode.	^keyEvent! !!ManifestPharoEnhancements class methodsFor: 'code-critics'!ruleGRUsesCurlyBraceArraysRuleV1FalsePositive	^ #(#(#(#RGPackage #(#PharoEnhancements)) #'2018-08-26T16:20:35.927752+00:00') )! !!PluggableTextFieldMorph methodsFor: '*PharoEnhancements' prior: 55785305!entryCompletion: anEntryCompletion	entryCompletion := anEntryCompletion.	entryCompletion ifNotNil: [ 		entryCompletion chooseBlock isNil			ifTrue: [ entryCompletion					chooseBlock: [ :v | 						self setText: v.						self acceptTextInModel ] ]			ifFalse: [ | blk |				blk := entryCompletion chooseBlock.				entryCompletion					chooseBlock: [ :v | 						(blk value: v) = true							ifTrue: [ 								self setText: v.								self acceptTextInModel ] ] ] ]! !!PeDateTest methodsFor: 'tests'!testAddYears	| start increment cases expected |	cases := { 		{ '3/1/2016'. 1. '3/1/2017' }.				"Leap year"		{ '2/29/2016'. 4. '2/29/2020' }.		{ '2/29/2016'. 1. '3/1/2017' }.	}.		cases do: [ :e |		start := e first asDate.		increment := e second.		expected := e third asDate.				self assert: (start addYears: increment) equals: expected ]! !!PeDateTest methodsFor: 'tests'!testSubtractYears	| start increment cases expected |	cases := { 		{ '3/1/2016'. 1. '3/1/2015' }.				"Leap year"		{ '2/29/2016'. 4. '2/29/2012' }.		{ '2/29/2016'. 1. '3/1/2015' }.	}.		cases do: [ :e |		start := e first asDate.		increment := e second.		expected := e third asDate.				self assert: (start subtractYears: increment) equals: expected ]! !!PeDateTest methodsFor: 'tests'!testYearsSince	| start end cases expected |	"See #yearsSince: method comment for explanation of return value"	cases := { 		{ '1/1/2018'. '1/2/2018'. 1 / 365 }.		{ '1/1/2018'. '1/1/2019'. 1 }.		{ '1/1/2018'. '1/2/2019'. 1 + (1 / 365) }.				"Leap year"		{ '1/1/2016'. '1/1/2017'. 1 }.		{ '2/28/2016'. '3/1/2016'. 2 / 366 }.	}.		cases do: [ :e |		start := e first asDate.		end := e second asDate.		expected := e third.				self assert: (end yearsSince: start) equals: expected ]! !!SystemResolver methodsFor: '*PharoEnhancements'!dynabookData 	<origin>	^ (FileLocator home / 'Dynabook' / 'User Data') resolve! !!AbstractFileReference methodsFor: '*PharoEnhancements'!isMD5Equal: aReference	| sourceHash targetHash |	sourceHash := self binaryReadStreamDo: [ :str | MD5 hashStream: str ].	targetHash := aReference binaryReadStreamDo: [ :str | MD5 hashStream: str ].	^ sourceHash = targetHash! !!AbstractFileReference methodsFor: '*PharoEnhancements'!macLock: aBoolean	"Adapted from https://macosx.com/threads/lock-unlock-files-with-the-terminal.317350/"	| keyword commandTemplate command |	OSPlatform current isMacOSX ifFalse: [ ^ self ].	keyword := aBoolean		ifTrue: [ 'uchg' ]		ifFalse: [ 'nouchg' ].	commandTemplate := 'chflags {keyword} "{fileName}"'.	command := commandTemplate format: { 		#keyword -> keyword.		#fileName -> self fullName } asDictionary.	LibC system: command! !!AbstractFileReference methodsFor: '*PharoEnhancements'!open	LibC system: 'open "', self fullName, '"'! !!AbstractFileReference methodsFor: '*PharoEnhancements'!preview	"Reference: http://www.maclife.com/article/columns/easy_mac_hacks_using_quicklook_command_line"	LibC system: '/usr/bin/qlmanage -p "', self fullName, '" &'! !!AbstractFileReference methodsFor: '*PharoEnhancements'!showInFinder	LibC system: 'open --reveal ', (self fullName surroundedBy: '"')! !!AbstractFileReference methodsFor: '*PharoEnhancements'!verifiedCopyTo: aReference	| result |	result := self copyTo: aReference.	(self isMD5Equal: aReference) ifFalse: [ self error: 'Copy hash has changed!!' ].	^ result! !!AbstractFileReference methodsFor: '*PharoEnhancements'!verifiedMoveTo: aFileReference	self verifiedCopyTo: aFileReference.	self delete! !"PharoEnhancements"!----SNAPSHOT----2020-08-25T17:45:31.2062+02:00 magritte.3.image priorSource: 388!----SNAPSHOT----2020-08-25T17:45:55.107543+02:00 magritte.4.image priorSource: 19903!!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline300ForGemStone: spec	spec		for: #gemstone		do: [ 			spec				project: 'GsCore'				with: [ 					spec						className: 'ConfigurationOfGsCore';						versionString: #bleedingEdge;						repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].			spec				package: 'Magritte-Model'					with: [ 							spec								requires: #('GsCore');								includes: #('Magritte-GemStone-Model') ];				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-GemStone-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-GemStone-Seaside') ];				package: 'Magritte-GemStone-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-GemStone-Model' with: [ spec requires: #('Magritte-GemStone-Model') ];				package: 'Magritte-GemStone-Seaside' with: [ spec requires: #('Magritte-Seaside') ] ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline310CommonExtDeps: spec	"Common external dependencies for baseline 3.1.0"	spec		baseline: 'Grease' with: [ spec repository: 'github://SeasideSt/Grease:v1.5.x/repository' ];		baseline: 'Seaside3'			with: [ "note: we do not want to depend on Zinc, since this is not present in Squeak. Currently no adapter is loaded"			spec				repository: 'github://SeasideSt/Seaside:master/repository';				loads: #('Core') ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330: spec	<baseline>	spec		for: #common		do: [ 			spec author: 'SeanDeNigris'.			spec timestamp: '2015-04-05'.			spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'.			self baseline310CommonExtDeps: spec.			spec				package: 'Magritte-Model' with: [ 					spec 						requires: #('Grease');						includes: #('Magritte-Deprecated3dot7') ];				package: 'Magritte-Deprecated3dot7' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Seaside' with: [ spec requires: #('Magritte-Model' 'Seaside3') ];				package: 'Magritte-Bootstrap' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Deprecated' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Merging' with: [ spec requires: #('Magritte-Model') ].			spec				group: 'Core' with: #('Magritte-Model');				group: 'Tests' with: #('Magritte-Tests-Model');				group: 'Seaside' with: #('Magritte-Seaside');				group: 'Deprecated' with: #('Magritte-Deprecated') ].	self baseline330ForPharo: spec.	self baseline300ForGemStone: spec! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ].			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ spec requires: #('PharoEnhancements') ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !"BaselineOfMagritte"!!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baseline: spec	<baseline>	self baselineCommon: spec.	self baselineSqueak: spec.	self baselinePharo: spec.	self baselineGemStone: spec! !!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselineCommon: spec	spec		for: #common		do: [ spec blessing: #baseline.			spec				package: 'Grease-Core';				package: 'Grease-Tests-Core'					with: [ spec requires: #('Grease-Core') ].			spec				group: 'Core' with: #('Grease-Core');				group: 'Core Tests' with: #('Grease-Tests-Core');				group: 'Slime' with: #('Core');				group: 'Slime Tests' with: #('Core Tests');				group: 'Tests' with: #('Core Tests' 'Slime Tests');				group: 'default' with: #('Slime') ]! !!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselineGemStone: spec  spec    for: #'gemstone'    do: [       spec        project: 'GsCore'          with: [               spec                className: 'ConfigurationOfGsCore';                versionString: #'stable';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'UTF8'          with: [               spec                className: 'ConfigurationOfGsMisc';                versionString: #'stable';                loads: #('Utf8Encoding');                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'System-Digital-Signatures'          copyFrom: 'UTF8'          with: [ spec loads: #('System-Digital-Signatures') ];        project: 'SMTPMail'          copyFrom: 'UTF8'          with: [ spec loads: #('SMTPMail') ].      spec        package: 'Grease-Core'          with: [               spec                requires: #('GsCore');                includes: #('Grease-GemStone-Core') ];        package: 'Grease-Tests-Core'          with: [               spec                requires: #('Grease-GemStone-Core');                includes: #('Grease-Tests-GemStone-Core') ];        package: 'Grease-GemStone-Core'          with: [               spec                requires:                  #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];        package: 'Grease-Tests-GemStone-Core'          with: [ spec requires: #('Grease-Tests-Core') ] ].  spec    for: #'gs2.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone200-Core') ];        package: 'Grease-GemStone200-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #'gs2.3.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone230-Core') ];        package: 'Grease-GemStone230-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #'gs2.4.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone240-Core') ];        package: 'Grease-GemStone240-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #(#'gs3.0.x' #'gs3.1.x' #'gs3.2.x')    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone300-Core') ];        package: 'Grease-GemStone300-Core'          with: [               spec                requires: #('Grease-GemStone-Core');                postLoadDoIt: #'initializeLatin1ToUtf8Encodings' ] ].  spec    for: #(#'gs3.3.x' #'gs3.4.x' #'gs3.5.x' #'gs3.6.x')    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone330-Core') ];        package: 'Grease-GemStone330-Core'          with: [               spec                requires: #('Grease-GemStone-Core');                postLoadDoIt: #'initializeLatin1ToUtf8Encodings' ] ].  spec    for: #(#'gs3.2.x' #'gs3.3.x' #'gs3.4.x' #'gs3.5.x' #'gs3.6.x')    do: [       spec        package: 'Grease-Tests-GemStone-Core'        with: [ spec file: 'Grease-Tests-GemStone-Core.v32' ] ]! !!BaselineOfGrease methodsFor: 'baselines' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselinePharo: spec	spec		for: #pharo		do: [ spec				package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ];				package: 'Grease-Pharo40-Slime' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Pharo40-Slime') ].			spec				group: 'Slime' with: #('Grease-Pharo40-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime') ].	spec		for: #(#'pharo4.x' #'pharo5.x')		do: [ spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Pharo30-Core');						includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ] ].	spec		for: #'pharo6.x'		do: [ spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo60-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Pharo60-Core');						includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo60-Core' with: [ spec requires: #('Grease-Core') ] ].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo70-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Pharo70-Core');						includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo70-Core' with: [ spec requires: #('Grease-Core') ] ]! !!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselineSqueak: spec	spec		for: #(#'squeak5.x')		do: [ 			spec				project: 'Refactoring-Core'				with: [ spec						className: 'ConfigurationOfRefactoringBrowser';						versionString: #stable;						loads: #('Core');						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Grease-Core'					with: [ spec includes: #('Grease-Squeak5-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Squeak5-Core');						includes: #('Grease-Tests-Squeak-Core' 'Grease-Tests-Squeak5-Core') ];				package: 'Grease-Squeak5-Core'					with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Squeak-Core'					with: [ spec requires: #('Grease-Tests-Core') ];				package: 'Grease-Tests-Squeak5-Core'					with: [ spec requires: #('Grease-Tests-Squeak-Core') ];				package: 'Grease-Slime'					with: [ spec requires: #('Refactoring-Core' 'Grease-Core') ];				package: 'Grease-Tests-Slime'					with: [ spec requires: #('Grease-Slime') ].			spec				group: 'Slime' with: #('Grease-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime') ].	spec		for: #(#'squeak6.x')		do: [			spec				project: 'Refactoring-Core'				with: [ spec						className: 'ConfigurationOfRefactoringBrowser';						versionString: #stable;						loads: #('Core');						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Grease-Core'					with: [ spec includes: #('Grease-Squeak6-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Squeak6-Core');						includes: #('Grease-Tests-Squeak-Core' 'Grease-Tests-Squeak6-Core') ];				package: 'Grease-Squeak6-Core'					with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Squeak-Core'					with: [ spec requires: #('Grease-Tests-Core') ];				package: 'Grease-Tests-Squeak6-Core'					with: [ spec requires: #('Grease-Tests-Squeak-Core') ];				package: 'Grease-Slime' 					with: [ spec requires: #('Refactoring-Core' 'Grease-Core') ];				package: 'Grease-Tests-Slime'					with: [ spec requires: #('Grease-Slime') ].			spec				group: 'Slime' with: #('Grease-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime') ]! !!BaselineOfGrease methodsFor: 'doits' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeLatin1ToUtf8Encodings	"Gemstone only"	(Smalltalk at: #GRUtf8CodecStream) initialize! !!BaselineOfGrease methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!projectClass  Smalltalk at: #'MetacelloCypressBaselineProject' ifPresent: [ :cl | ^ cl ].  ^ super projectClass! !"BaselineOfGrease"!!BaselineOfPharoEnhancements methodsFor: 'baseline'!baseline: spec	<baseline>	spec for: #common do: [ spec package: 'PharoEnhancements' ]! !"BaselineOfPharoEnhancements"!!GRNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRNotification instead of Notification.!!GRDeprecatedApiNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This notification is signaled whenever a deprecated message is sent.see WAObject>>#greaseDeprecatedApi:details: !!GRNotificationBasedDynamicVariable commentStamp: 'pmm 9/5/2017 14:34' prior: 0!An implementation of a dynamic varaible based on notifications. Dialects that do not support dynamic variables or thread/process local variables can create an empty subclass of this class called GRDynamicVariable.!!GRError commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRError instead of Error.!!GRInvalidArgumentCount commentStamp: 'jf 3/14/2009 11:05' prior: 0!Signaled whenever a message is sent with the incorrect number of arguments.!!GRInvalidUtf8Error commentStamp: 'pmm 1/10/2009 22:29' prior: 0!A WAInvalidUtf8Error signals that the input is not valid UTF-8.!!GRObject commentStamp: 'pmm 9/14/2013 15:52' prior: 0!A common superclass that ensures consistent initialization behaviour on all platforms and provides #error: methods that signal an instance of WAPlatformError.Packages that are using Seaside-Platform should normally subclass GRObject instead of Object.!!GRCodec commentStamp: 'lr 2/7/2009 09:55' prior: 0!A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding) and back outside the image (encoding). The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.!!GRNullCodec commentStamp: 'pmm 9/14/2013 15:52' prior: 0!The null codec always returns the original streams. It assumes that the outside world uses the same encoding as the inside world. This is highly efficient as no transformation is applied to the data, but has its drawbacks.!!GRDelayedSend commentStamp: 'NickAger 3/20/2012 09:04' prior: 0!A GRDelayedSend is a future message send of a message to an object. Some of the arguments can be predefined. Instances are intended to be interchangeable with blocks.This class should conform the ANSI (block) valuable protocol. Unlike a block, a GRDelayedSend is not a closure so doesn't hold onto the method context. GRDelayedSend provides similar, but portable, functionality to Pharo's MessageSend.This is an abstract class. Use the methods in the 'instance-creation' protocol on the class side to create intances.Instance Variables	receiver:		<Object>	selector:		<Symbol>receiver	- the object receiving the messageselector	- the message selector sent to the receiver!!GRDelayedSendMessage commentStamp: 'NickAger 3/19/2012 11:20' prior: 0!GRDelayedSendMessage is an abstract base for objects that provide currying functionality for GRDelayedSend!!GRBoundMessage commentStamp: 'jf 3/14/2009 11:04' prior: 0!A delayed send that has some or all of the arguments defined in advance. Additionally supplied arguments will be added, if possible, to these when the object is evaluate.Instance Variables	arguments:		<Array>arguments	- the predefined arguments!!GRUnboundMessage commentStamp: 'jf 3/14/2009 11:03' prior: 0!A delayed send that has none of the arguments defined in advance.!!GRDelegatingStream commentStamp: 'pmm 6/25/2012 20:20' prior: 0!A GRDelegatingStream is a wrapper around a write stream and defines common behavior.Instance Variables	stream:		<WriteStream>stream	- a WriteStream!!GRCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!GRCodecStream is the abstract base class for codec streams!!GRNullCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!A WANullCodecStream is a WriteStream on a String on which you can both put binary and character data without encoding happening.Instance Variables	stream:		<WriteStream>stream	- a WriteStream on a String!!GRCountingStream commentStamp: 'pmm 6/25/2012 20:39' prior: 0!A GRCountingStream counts how many elements have been added to it. This is necessary because the underlying stream may inflate the number of elements in the stream.Instance Variables:	count	<Integer>		count  - number of elements added to this stream!!GRInflector commentStamp: 'lr 12/27/2008 09:43' prior: 0!The Inflector transforms words from singular to plural.!!GRPackage commentStamp: 'pmm 9/14/2013 15:53' prior: 0!I am a platform independent package representation. I know my name, description, my dependencies, the license and the repository URL. Packages are declared by creating a class side extension method that answers a configured package instance. The expression    GRPackage packagesanswers the collection of the complete package graph.!!GRPlatform commentStamp: 'jf 2/6/2009 16:05' prior: 0!The abstract platform implementation. Each platform should provide a subclass implementing any abstract methods and overriding any other methods as necessary.Default implementations should be provided here when possible/useful but default implementations MUST be valid on ALL PLATFORMS so it is rarely practical. VA Smalltalk flags sends of uknown messages so even these must be known to exist on all platforms.Common cases where default implementations *are* appropriate are where there is a standard implementation that is valid on all platforms but one or more platforms have an additional, optimized implementation that should be used instead.All classes and methods used by methods of this class should be either:  + included in the Seaside-Platform package;  + defined by the ANSI Smalltalk standard; or  + (not ideal) referenced via 'Smalltalk at: #ClassName'.!!GRNumberPrinter commentStamp: 'pmm 2/1/2014 13:27' prior: 0!A GRNumberPrinter prints numbers (integers and floats) in various formats in a platform independent way.Instance Variables	accuracy:	<UndefinedObject|Float>	base:		<Integer>	delimiter:	<UndefinedObject|Character>	digits:		<UndefinedObject|Integer>	infinite:		<UndefinedObject|String>	nan:			<UndefinedObject|String>	padding:	<UndefinedObject|Character>	precision:	<Integer>	separator:	<UndefinedObject|Character>!!GRSmallDictionary commentStamp: 'jf 2/15/2010 15:51' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser.!!GROrderedMultiMap commentStamp: 'jf 2/15/2010 16:04' prior: 0!I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.!!GRSmallDictionary2 commentStamp: 'pmm 8/22/2016 11:49' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser and others from Eclipse Collections.!!GROrderedMultiMap2 commentStamp: 'jf 2/15/2010 16:04' prior: 0!I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.!!GRSmallOrderedSet commentStamp: 'pmm 8/25/2016 14:03' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating.!!GRVersion commentStamp: 'lr 2/19/2012 12:57' prior: 0!I model version numbers. I am comparable and I define a natural order.!!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!details	^ details! !!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!details: anObject	details := anObject! !!GRNotificationBasedDynamicVariable class methodsFor: 'defaults' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultValue	^ nil! !!GRNotificationBasedDynamicVariable class methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!use: anObject during: aBlock	"Set the dynamic value of the receiver to anObject during the evaluation of aBlock."		^ aBlock on: self do: [ :notification | notification resume: anObject ]! !!GRNotificationBasedDynamicVariable class methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value	"Answer the dynamic value of the receiver."		^ self signal! !!GRNotificationBasedDynamicVariable methodsFor: 'defaults' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultAction	^ self class defaultValue! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!excerpt: aString	"Answer an excerpt of the receiver that matches the first occurence of aString. If aString isn't found, nil is answered."		^ self excerpt: aString radius: 100! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!excerpt: aString radius: anInteger	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."		^ self excerpt: aString radius: anInteger ellipsis: '...'! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!excerpt: aString radius: anInteger ellipsis: anEllipsisString	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."	| index start stop |	(index := self indexOfSubCollection: aString) = 0		ifTrue: [ ^ nil ].	start := index - anInteger max: 1.	stop := index + anInteger + aString size - 1 min: self size.	^ (start > 1 ifTrue: [ anEllipsisString ] ifFalse: [ '' ]) ,		(self copyFrom: start to: stop) ,	  	(stop < self size ifTrue: [ anEllipsisString ] ifFalse: [ '' ])! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	"Convert the receiver to an integer, answer nil if this is not a number."	| number negated |	number := nil.	negated := false.	1 to: self size do: [ : i |		| char |		char := self at: i.		(i = 1 and: [ char = $- ])			ifTrue: [ negated := true ]			ifFalse: [				(char >= $0 and: [ char <= $9 ])					ifTrue: [						number := (number isNil							ifTrue: [ 0 ]							ifFalse: [ 10 * number ]) + (char greaseInteger - $0 greaseInteger) ]					ifFalse: [						^ number isNil ifFalse: [ 							 negated not								ifFalse: [ number negated ]								ifTrue: [ number ] ] ] ] ].	^ number isNil ifFalse: [		negated not			ifFalse: [ number negated ]			ifTrue: [ number ] ]! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize	^ GRInflector pluralize: self! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPutAll: self! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!truncate	"Truncate the receiver to 30 characters."		^ self truncate: 30! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!truncate: anInteger	"Truncate the receiver to anInteger characters."		^ self truncate: anInteger ellipsis: '...'! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!truncate: anInteger ellipsis: aString	"Truncate the receiver to anInteger characters and append aString as ellipsis if necessary."	^ anInteger < self size		ifTrue: [ (self copyFrom: 1 to: anInteger) , aString ]		ifFalse: [ self copy ]! !!Character methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPut: self! !!UndefinedObject methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream! !!Integer methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	^ self! !!Integer methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize: aSingularString 	^ self 		pluralize: aSingularString		with: (GRInflector pluralize: aSingularString)! !!Integer methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize: aSingularString with: aPluralString	^ self printString , ' ' , (self abs = 1 ifTrue: [ aSingularString ] ifFalse: [ aPluralString ])! !!GRCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allCodecs	"Answer all codecs supported in this system. This is a collection of codec instances."	^ self subclasses		inject: self codecs asArray		into: [ :result :each | result , each allCodecs ]! !!GRCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	"Create the actual instance."	self subclassResponsibility! !!GRCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	"Answer a collection of possible codecs of the receiver. To be overridden by concrete subclasses."	^ #()! !!GRCodec class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!forEncoding: aString	"Answer a new codec instance for the given encoding name. Raise an WAUnsupportedEncodingError if the encoding name is not supported by this image."	self allSubclassesDo: [ :each | 		(each supportsEncoding: aString)			ifTrue: [ ^ each basicForEncoding: aString ] ].	^ self unsupportedEncoding: aString! !!GRCodec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	"Answer whether the the given encoding name is supported by this codec class."	self subclassResponsibility! !!GRCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unsupportedEncoding: aString	"Signal an unsupported encoding."	^ GRUnsupportedEncodingError signal: 'unsupported encoding: ' , aString! !!GRCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aString	| readStream writeStream |	readStream := self decoderFor: aString readStream.	writeStream := GRPlatform current writeCharacterStreamOn: (String new: aString size).	[ readStream atEnd ]		whileFalse: [ writeStream nextPutAll: (readStream next: 1024) ].	^ writeStream contents! !!GRCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aReadStream	"Wrap aReadStream with an decoder for the codec of the receiver. Answer a read stream that delegates to and shares the state of aReadStream." 		self subclassResponsibility! !!GRCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encode: aString	| writeStream |	writeStream := self encoderFor: (GRPlatform current		writeCharacterStreamOn:  (String new: aString size)).	writeStream nextPutAll: aString.	^ writeStream contents! !!GRCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aWriteStream	"Wrap aWriteStream with an encoder for the codec of the receiver. Answer a write stream that delegates to and shares the state of aWriteStream."		self subclassResponsibility! !!GRCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	"Answer a human readable string of the receivers encoding policy."	self subclassResponsibility! !!GRCodec methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!GRCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"Answer a codec that is responsible to encode and decode URLs. In most cases an UTF-8 codec is the only valid choice, but subclasses might decide to do something else."	self subclassResponsibility! !!GRNullCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	^ self new! !!GRNullCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecName	^ '(none)'! !!GRNullCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ Array with: self new! !!GRNullCodec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	^ aString isNil! !!GRNullCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aReadStream! !!GRNullCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aWriteStream! !!GRNullCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ GRNullCodec codecName! !!GRNullCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"The selfish method. Let's do it with ourselves."		^ self! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!empty	^ self receiver: nil selector: #yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self empty! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!receiver: anObject selector: aSymbol 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRUnboundMessage selector: aSymbol);		yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!receiver: anObject selector: aSymbol arguments: anArray 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRBoundMessage selector: aSymbol arguments: anArray);		yourself! !!GRDelayedSend methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	"Answer the number of arguments that must be provided to the receiver when sending it."		^ message argumentCount! !!GRDelayedSend methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithReceiver: anObject message: aDelayedSendMessage	self initialize.	receiver := anObject.	message := aDelayedSendMessage! !!GRDelayedSend methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' receiver: '; print: receiver.	aStream nextPut: $ .	message printOn: aStream! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value	^ self valueWithArguments: #()! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value: anObject	^ self valueWithArguments: (Array with: anObject)! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value: aFirstObject value: aSecondObject	^ self valueWithArguments: (Array with: aFirstObject with: aSecondObject)! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithArguments: anArray	^ message valueFor: receiver withArguments: anArray! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithPossibleArguments: anArray	^ message valueFor: receiver withPossibleArguments: anArray! !!GRBoundMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!selector: aSymbol	^ self selector: aSymbol arguments: #()! !!GRBoundMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!selector: aSymbol arguments: anArray	^ self basicNew		initializeWithSelector: aSymbol arguments: anArray;		yourself! !!GRBoundMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	^ selector numArgs - arguments size! !!GRBoundMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithSelector: aSymbol arguments: anArray	self initializeWithSelector: aSymbol.	arguments := anArray asArray! !!GRBoundMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!mergeArguments: anArray	^ arguments , anArray! !!GRBoundMessage methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' arguments: '; print: arguments! !!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self selector: #yourself! !!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!selector: aSymbol	^ self basicNew		initializeWithSelector: aSymbol;		yourself! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	"Answer the number of arguments that must be provided when sending this message."		self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicPerformFor: receiver withArguments: anArray	^ anArray size = selector numArgs		ifTrue: [ receiver perform: selector withArguments: anArray ]		ifFalse: [ self invalidArgumentCount ]! !!GRDelayedSendMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithSelector: aSymbol	self initialize.	selector := aSymbol! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!invalidArgumentCount	GRInvalidArgumentCount signal! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!mergeArguments: anArray	self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	aStream nextPutAll: 'selector: '; print: selector! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueFor: receiver withArguments: anArray	"Send the message to receiver with the arguments in anArray. Answer the result.	Signal an error if the number of arguments does not match the selector."		^ self basicPerformFor: receiver withArguments: (self mergeArguments: anArray)! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueFor: receiver withPossibleArguments: anArray	"Send the message to receiver with as many of the arguments in anArray as possible. Answer the result.	Error if not enough arguments are available for the selector."	| allArguments |	allArguments := self mergeArguments: anArray.		^ allArguments size < selector numArgs		ifTrue: [ self invalidArgumentCount ]		ifFalse: [ self basicPerformFor: receiver withArguments: (allArguments first: selector numArgs) ]! !!GRUnboundMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	^ selector numArgs! !!GRUnboundMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!mergeArguments: anArray	^ anArray! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	^ stream next! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	^ stream next: anInteger! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacterOrByte	aCharacterOrByte isCharacter		ifTrue: [ stream nextPut: aCharacterOrByte ]		ifFalse: [ stream nextPut: (Character codePoint: aCharacterOrByte) ]! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aStringOrByteArray	aStringOrByteArray isString		ifTrue: [ stream nextPutAll: aStringOrByteArray ]		ifFalse: [			1 to: aStringOrByteArray size do: [ :index |				stream nextPut: (Character codePoint: (aStringOrByteArray at: index)) ] ]! !!GRCountingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!count	^ count! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	super greaseNext: anInteger putAll: aCollection startingAt: startIndex.	count := count + anInteger! !!GRCountingStream methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	count := 0! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	stream nextPut: aCharacter.	count := count + 1	! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	stream nextPutAll: aString.	count := count + aString size	! !!GRCountingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!reset	super reset.	count := 0! !!GRDelegatingStream class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!on: aStream	^ self basicNew initializeOn: aStream! !!GRDelegatingStream methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!atEnd	^ stream atEnd! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!contents	^ stream contents! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!crlf	self nextPut: Character cr; nextPut: Character lf! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!flush	stream flush! !!GRDelegatingStream methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeOn: aStream	self initialize.	stream := aStream! !!GRDelegatingStream methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isStream	^ true! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!position	^ stream position! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject	anObject printOn: self! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!reset	"Reset the stream"	stream reset! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ stream size! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!space	self nextPut: Character space! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!tab	self nextPut: Character tab! !!GRInflector class methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	Uninflected := #('bison' 'bream' 'breeches' 'britches' 'carp' 'chassis' 'clippers' 'cod' 'contretemps' 'corps' 'debris' 'deer' 'diabetes' 'djinn' 'eland' 'elk' 'equipment' 'fish' 'flounder' 'gallows' 'graffiti' 'headquarters' 'herpes' 'high-jinks' 'homework' 'information' 'innings' 'ities' 'itis' 'jackanapes' 'mackerel' 'measles' 'mews' 'money' 'mumps' 'news' 'ois' 'pincers' 'pliers' 'pox' 'proceedings' 'rabies' 'rice' 'salmon' 'scissors' 'sea-bass' 'series' 'shears' 'sheep' 'species' 'swine' 'trout' 'tuna' 'whiting' 'wildebeest').	InflectionRules := #(('man' 'en' 2) ('child' 'ren' 0) ('cow' 'kine' 3) ('penis' 'es' 0) ('sex' 'es' 0) ('person' 'ople' 4) ('octopus' 'es' 0) ('quiz' 'zes' 0) ('ox' 'en' 0) ('louse' 'ice' 4) ('mouse' 'ice' 4) ('matrix' 'ices' 2) ('vertix' 'ices' 2) ('vertex' 'ices' 2) ('indix' 'ices' 2) ('index' 'ices' 2) ('x' 'es' 0) ('ch' 'es' 0) ('ss' 'es' 0) ('sh' 'es' 0) ('ay' 's' 0) ('ey' 's' 0) ('iy' 's' 0) ('oy' 's' 0) ('uy' 's' 0) ('y' 'ies' 1) ('alf' 'ves' 1) ('elf' 'ves' 1) ('olf' 'ves' 1) ('arf' 'ves' 1) ('nife' 'ves' 2) ('life' 'ves' 2) ('wife' 'ves' 2) ('sis' 'es' 2) ('tum' 'a' 2) ('ium' 'a' 2) ('buffalo' 'es' 0) ('tomato' 'es' 0) ('buffalo' 'es' 0) ('bus' 'es' 0) ('alias' 'es' 0) ('status' 'es' 0) ('octopus' 'i' 2) ('virus' 'i' 2) ('axis' 'es' 2) ('s' '' 0))! !!GRInflector class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize: aString	| string |	string := aString asLowercase.	Uninflected do: [ :each |		(string endsWithSubCollection: each)			ifTrue: [ ^ aString ] ].	InflectionRules do: [ :rule |		(string endsWithSubCollection: rule first)			ifTrue: [ ^ (aString allButLast: rule third) , rule second ] ].	^ aString , 's'! !!GRObject class methodsFor: 'error handling' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultErrorClass	^ GRError! !!GRObject class methodsFor: 'error handling' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!error: aString	^ self defaultErrorClass signal: aString! !!GRObject class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self basicNew initialize! !!GRObject methodsFor: 'error handling' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!error: aString	^ self class error: aString! !!GRObject methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize! !!GRPackage class methodsFor: 'querying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grPackages	"Answer a list of all registered packages. A package is registered by adding a class extension to the receiving class answering an instance of the receiving class."	| packages package |	packages := Dictionary new.	self class selectors do: [ :each |		(each numArgs = 0 and: [ each ~= #grPackages ]) ifTrue: [ 			package := self perform: each.			packages at: package name put: package ] ].	packages do: [ :each | each resolveWith: packages ].	^ packages values! !!GRPackage class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseCore	^ self new		name: 'Grease-Core';		description: 'The main package of the Grease compatibility layer.';		url: #greaseUrl;		yourself! !!GRPackage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addDependenciesTo: aCollection	(aCollection includes: self) ifFalse: [		self dependencies			do: [ :each | each addDependenciesTo: aCollection ].		aCollection add: self ].	^ aCollection! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addDependency: aString	dependencies add: aString! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allDependencies	"Answer all dependencies on which this package depends."	^ self addDependenciesTo: OrderedCollection new! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!dependencies	"Return a collection of package names on which this package depends."	^ dependencies! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!description	"Answer a short description of the package."	^ description! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!description: aString	description := aString! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseUrl	^ 'http://smalltalkhub.com/mc/Seaside/Grease11/main'! !!GRPackage methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	dependencies := OrderedCollection new.	license := #MIT! !!GRPackage methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isLGPL	^ self license = #LGPL! !!GRPackage methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isMIT	^ self license = #MIT! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!license	"Answer the current license of this package, by default MIT is used."	^ license! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!license: aSymbol	license := aSymbol! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	"Answer the name of the package. This string should be useable to identify the platform specific native package object, e.g. the Monticello package name."	^ name! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name: aString	name := aString! !!GRPackage methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!resolveWith: aDictionary	dependencies := dependencies 		collect: [ :each |			aDictionary at: each ifAbsent: [				"if Foo-Pharo-Bar fails try Foo-Pharo20-Bar and Foo-Pharo30-Bar"				(each indexOfSubCollection: '-Pharo-' startingAt: 1) ~= 0 ifTrue: [ 					"try -Pharo20-"					aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo20-') ifAbsent: [						"try -Pharo30-"						aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo30-') ifAbsent: [							"try -Pharo40-"							aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo40-') ifAbsent: [								"try -Pharo50-"								aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo50-') ifAbsent: [									"try -Pharo60-"									aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo60-') ifAbsent: [										"try -Pharo70-"										aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo70-') ifAbsent: [											"try -Squeak-"											aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Squeak-') ifAbsent: [												"try -Squeak5-"												aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Squeak5-') ifAbsent: [													"try -Squeak6-"													aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Squeak6-') ifAbsent: [													self error: self name printString , ' depends on unknown package ' , each printString ] ] ] ] ] ] ] ] ] ] ] ]! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!seasideAddonsUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30Addons/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!seasideLGPLUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30LGPL/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!seasideUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside31/main'! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"Answer the base-URL of the package. This string is only meaningful for platforms that can directly access Monticello repositories."	^ url isSymbol		ifTrue: [ self perform: url ]		ifFalse: [ url ]! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url: aStringOrSymbol	"Set the base-URL of the package, or a symbol referring to a method in this class that answers the URL. This setting is only meaningful for platforms that can directly access Monticello repositories."	url := aStringOrSymbol! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!current	^ Current! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!current: aPlatform	Current := aPlatform! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!select	GRPlatform current: self new! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unselect	GRPlatform current class = self ifTrue: [ GRPlatform current: nil ]! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToStartUpList: anObject	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	self subclassResponsibility! !!GRPlatform methodsFor: 'encoding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base64Decode: aString	"Base64 decode the given String and answer the result as a String."	self subclassResponsibility! !!GRPlatform methodsFor: 'bindings' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!bindingOf: aClass	"Answer the binding of aClass.	The binding is the literal that get compiled into the method.	We need the binding to be updated when the class is changed.	The binding has to respond to #value.		This is mostly an issue on GemStone/S because when we hold on	to a class directly we will end up holding on to an old class version.		Dialects with namespaces will need to override this.		On VisualWorks this should like this	^ aClass fullyQualifiedReference"	^ Smalltalk associationAt: aClass name! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!compile: aString into: aClass classified: aSymbol	"The trick here is to be as silently a possible so that the package is not marked dirty when running WAFileLibrary test.	This also makes running tests much faster."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!contentsOfFile: aString binary: aBoolean	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!convertToSmalltalkNewlines: aString	"Convert any line endings (CR, CRLF, LF) to the default platform newline."		aString isNil 		ifTrue: [ ^ nil ].	^ String streamContents: [ :writeStream |		| readStream |		readStream := aString readStream.		[ readStream atEnd ] whileFalse: [			| next |			next := readStream next.			next = Character cr				ifTrue: [					readStream peek = Character lf						ifTrue: [ readStream skip: 1 ].					writeStream nextPutAll: self newline ]				ifFalse: [					next = Character lf						ifTrue: [ writeStream nextPutAll: self newline ]						ifFalse: [ writeStream nextPut: next ] ] ] ]! !!GRPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!deprecationExceptionSet	"Answer the exception set that should considered besides WADeprecation."	^ ExceptionSet new! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'transactions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!doTransaction: aBlock	"for Gemstone/S compatibility	http://gemstonesoup.wordpress.com/2007/05/10/porting-application-specific-seaside-threads-to-gemstone/	use when modifying an object from an outside thread"	^ aBlock value! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!ensureExistenceOfFolder: aString	"Create a folder named aString in the image directory."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileExists: aString	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileStreamOn: aString do: aBlock binary: aBoolean	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!filesIn: aPathString	"Answer a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."		self subclassResponsibility! !!GRPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!label	"Answer a descriptive label string for the platform implementation"		self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!localNameOf: aFilename	"Answer the local name of a file identified by an absolute file path.		Eg.	If the platform is Windwos and aFilename is 'C:\Windows\win32.dll' then it would answer 'win32.dll'.	If the platform is Unix and aFilename is '/usr/bin/vim' then it would answer 'vim'."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.	Used by Squeak to use a secure random when avaiable."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newline	"Answer a String with the default newline character of this platform."		self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!openDebuggerOn: anError	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pathSeparator	"Answer the path separator as a String, eg. '/' on Unix and '\' on Windows."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteByteStream	"Return a ReadWriteStream on a ByteArray that stores integers 0..255		^ReadWriteStream on: ByteArray new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteCharacterStream	"Return a ReadWriteStream on a String that stores characters		^ReadWriteStream on: String new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!reducedConflictDictionary	"used by Gemstone/S reduced conflict classes that can be used to avoid transaction conflicts"	^ Dictionary! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromShutDownList: anObject	"Remove anObject from the shutdown list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromStartUpList: anObject	"Remove anObject from the startup list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeSelector: aSymbol from: aClass	self subclassResponsibility! !!GRPlatform methodsFor: 'cryptography' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!secureHashFor: aString	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stackDepth	self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."		self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!thisContext	"Answer the current activation of a method execution or block activation.		For dialects with a thisContext variable and implementation can lock like this.		^ thisContext sender"	self subclassResponsibility! !!GRPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!version	"Answer the Grease version"	^ (GRVersion major: 1 minor: 4 revision: 0)		yourself! !!GRPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!versionString	^ String streamContents: [ :stream |		stream			nextPutAll: (self version greaseString);			nextPutAll: ' (';			nextPutAll: (self label);			nextPut: $) ]! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!weakDictionaryOfSize: aNumber	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"Write aStringOrByteArray to a file named aFileNameString in the folder aFolderString."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!writeCharacterStreamOn: aString	"String based write stream"	^ WriteStream on: aString! !!GRMappedPrinter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!block: aBlock next: aPrinter	^ self new 		block: aBlock;		next: aPrinter;		yourself! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!block: aBlock	block := aBlock! !!GRMappedPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self block: [ :value | value ]! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: aPrinter	next := aPrinter! !!GRMappedPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	next print: (block value: anObject) on: aStream! !!GRNumberPrinter class methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	NumbersToCharactersLowercase := '0123456789abcdefghijklmnopqrstuvwxyz'.	NumbersToCharactersUppercase := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!accuracy: aFloat	"Round towards the nearest number that is a multiple of aFloat."		accuracy := aFloat! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base: anInteger	"The numeric base to which the number should be printed."	base := anInteger! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!characters: aString	"The characters to be used to convert a number to a string."	characters := aString! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!delimiter: aCharacter	"The delimiter to separate the integer and fraction part of the number."	delimiter := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!digits: anInteger	"The number of digits to be printed in the integer part."	digits := anInteger! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!digitsOf: aNumber base: aBaseInteger	"Answer the absolute digits of aNumber in the base aBaseInteger."	| integer stream next |	integer := aNumber truncated abs.	integer = 0 ifTrue: [ ^ '0' ].	stream := WriteStream on: (String new: 10).	[ integer > 0 ] whileTrue: [		next := integer quo: aBaseInteger.		stream nextPut: (characters 			at: 1 + integer - (next * aBaseInteger)).		integer := next ].	^ stream contents reverse! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!infinite: aString	"The string that should be displayed if the number is positive or negative infinity."		infinite := aString! !!GRNumberPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self lowercase.	self base: 10.	self delimiter: $..	self infinite: 'Infinite'.	self nan: 'NaN'.	self padding: $ .	self precision: 0! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!lengthOf: aNumber base: aBaseInteger	"Answer the number of digits of aNumber in the base aBaseInteger.	Same as #decimalDigitLength"	| integer current length |	integer := aNumber truncated abs.	length := 1.	current := aBaseInteger.	[ current <= integer ] whileTrue: [ 		length := length + 1.		current := current * aBaseInteger ].	^ length! !!GRNumberPrinter methodsFor: 'actions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!lowercase	"Use lowercase characters for numbers of base 10 and higher."	self characters: NumbersToCharactersLowercase! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nan: aString	"The string that should be displayed if the number is not a number."		nan := aString! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padLeft: aCharacter to: aPadCountInteger on: aStream	"Pad to the left side of aString with aCharacter to at anInteger characters."	1 to: aPadCountInteger do: [ :index |		separator isNil ifFalse: [			(index ~= 1 and: [ (digits - index) \\ 3 = 2 ])				ifTrue: [ aStream nextPut: separator ] ].		aStream nextPut: aCharacter ]! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padding: aCharacter	"The padding for the integer part."	padding := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!precision: anInteger	"The number of digits to be printed in the fraction part."		precision := anInteger! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: aNumber on: aStream	aNumber isNaN		ifTrue: [ ^ self printNaN: aNumber on: aStream ].	aNumber isInfinite 		ifTrue: [ ^ self printInfinite: aNumber on: aStream ].	precision = 0		ifTrue: [ self printInteger: aNumber on: aStream ]		ifFalse: [ self printFloat: aNumber on: aStream ]! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printDigitsOf: aNumber withLength: aLengthInteger on: aStream	"Print the digits of aNumber with a lenght of aLengthInteger on aStream.	Also print a separator if required."	| rest |	rest := aNumber truncated abs.	1 to: aLengthInteger do: [ :index |		| divisor current |		divisor := base raisedTo: aLengthInteger - index.		current := rest // divisor.		separator isNil ifFalse: [ 			 (index ~= 1 and: [ (aLengthInteger - index) \\ 3 = 2 ])				ifTrue: [ aStream nextPut: separator ] ].		aStream nextPut: (characters at: current + 1).		rest := rest - (divisor * current) ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printFloat: aNumber on: aStream	| multiplier rounded |	multiplier := base raisedTo: precision.	rounded := aNumber roundTo: (accuracy ifNil: [ multiplier reciprocal ]).	self printInteger: rounded on: aStream.	delimiter isNil		ifFalse: [ aStream nextPut: delimiter ].	self printFraction: rounded fractionPart abs * multiplier on: aStream! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printFraction: aNumber on: aStream	| result |	result := self		pad: (self digitsOf: aNumber rounded base: base)		left: $0 to: precision.	separator isNil		ifTrue: [ aStream nextPutAll: result ]		ifFalse: [ self separate: result left: separator on: aStream ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printInfinite: aNumber on: aStream	infinite isNil		ifFalse: [ aStream nextPutAll: infinite ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printInteger: aNumber on: aStream	| length |	length := self lengthOf: aNumber base: base.		(digits notNil and: [ padding notNil ])		ifTrue: [ self padLeft: padding to: (digits - length) on: aStream ].		self printDigitsOf: aNumber withLength: length on: aStream! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printNaN: anInteger on: aStream	nan isNil		ifFalse: [ aStream nextPutAll: nan ]! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!separate: aString left: aCharacter on: aStream	"Separate from the left side every 3 characters with aCharacter."			| size |	size := aString size.	1 to: size do: [ :index |		(index ~= 1 and: [ index \\ 3 = 1 ])			ifTrue: [ aStream nextPut: aCharacter ].		aStream nextPut: (aString at: index) ]! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!separate: aString right: aCharacter	"Separate from the right side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ size - index \\ 3 = 2 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!separator: aCharacter	"Separator character to be used to group digits."	separator := aCharacter! !!GRNumberPrinter methodsFor: 'actions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!uppercase	"Use uppercase characters for numbers of base 10 and higher."		self characters: NumbersToCharactersUppercase! !!GROrdinalizePrinter methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!ordinalize: anInteger	^ (anInteger \\ 100 between: 11 and: 13)		ifTrue: [ 'th' ]		ifFalse: [ 			#('st' 'nd' 'rd')				at: anInteger \\ 10 				ifAbsent: [ 'th' ] ]! !!GROrdinalizePrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPutAll: (self ordinalize: anObject integerPart)! !!GRPluggablePrinter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!on: aBlock	^ self new block: aBlock! !!GRPluggablePrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!block: aBlock	block := aBlock! !!GRPluggablePrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self block: [ :value | String new ]! !!GRPluggablePrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPutAll: (block value: anObject)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!abbreviatedMonthName	^ self monthName: #('Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!abbreviatedWeekName	^ self weekName: #('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!absOffsetHoursPadded	^ GRMappedPrinter 		block: [ :date | date offset hours abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!absOffsetMinutesPadded	^ GRMappedPrinter 		block: [ :date | date offset minutes abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-units' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!binaryFileSize	^ GRUnitPrinter base: 1024 units: #('byte' 'bytes' 'KiB' 'MiB' 'GiB' 'TiB' 'PiB' 'EiB' 'ZiB' 'YiB')! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!cookieTimestamp	"Netscape's original proposal defined an Expires header that took a date value in a fixed-length variant format in place of Max-Age: Wdy, DD-Mon-YY HH:MM:SS GMT"	^ GRMappedPrinter		block: [ :timestamp | timestamp asUTC ]		next: self abbreviatedWeekName , ', ' , self paddedDay , '-' , self abbreviatedMonthName , '-' , self paddedYear , ' ' , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'parts-units' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decimalFileSize	^ GRUnitPrinter base: 1000 units: #('byte' 'bytes' 'kB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fullMonthName	^ self monthName: #('January' 'February' 'March' 'April' 'May' 'June' 'July' 'August' 'September' 'October' 'November' 'December')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fullWeekName	^ self weekName: #('Sunday' 'Monday' 'Tuesday' 'Wednesday' 'Thursday' 'Friday' 'Saturday')! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!httpDate	"Answers a printer that formats dates for HTTP1.1 (RFC 2616)"	^ self rfc1123! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isoDate	"Ansers a printer that formats dates according to ISO(YYYY-MM-DD) E.g. 2003-12-24"	^ self paddedYear , $- , self paddedMonth , $- , self paddedDay! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isoTime	"Ansers a printer that formats time according to ISO(HH:MM:SS) E.g. 12:23:34"		^ self paddedHour24 , $: , self paddedMinute , $: , self paddedSecond! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!monthName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date monthIndex ]! !!GRPrinter class methodsFor: 'parts-units' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!numberWithAtLeastDigits: anInteger	^ GRNumberPrinter new		padding: $0;		digits: anInteger;		yourself! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!offsetSign	^ GRMappedPrinter 		block: [ :date | date offset ]		next: (GRSignPrinter new				positivePrinter: $+;				negativePrinter: $-;				yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: (GRNumberPrinter new				padding: $0;				digits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: (self numberWithAtLeastDigits: 4)! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rfc1123	"Answers a printer that formats dates for HTTP1.1 (RFC 1123). Eg.	Sun, 06 Nov 1994 08:49:37 GMT "		^ GRMappedPrinter 		block: [ :date | 			"For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time)"			date asUTC ]		next: GRSequentialPrinter new , self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rfc822	"Answers a printer that formats dates according to RFC 822 (email). Eg.	Sun, 31 Aug 2008 19:41:46 +0200"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , self offsetSign , self absOffsetHoursPadded , self absOffsetMinutesPadded! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rfc822WithTimeZone: aString	"Answers a privter that formats dates according to RFC 822 (email) with the given time zone String. Eg.	Sun, 31 Aug 2008 19:41:46 <aString>"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , aString! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!swissCurrency	^ GRSequentialPrinter new , 'CHF ' , GRSignPrinter new , (GRNumberPrinter new			separator: $';			precision: 2;			accuracy: 0.05;			yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!usCurrency	^ GRSignPrinter new , $$ , (GRNumberPrinter new			separator: $,;			precision: 2;			yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!weekName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date dayOfWeek ]! !!GRPrinter methodsFor: 'operators' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!, aPrinter 	^ GRSequentialPrinter new , self , aPrinter! !!GRPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pad: aString center: aCharacter to: anInteger	"Pad to the center of aString with aCharacter to at least anInteger characters."	| result index |	anInteger <= aString size		ifTrue: [ ^ aString ].	index := (anInteger - aString size) // 2.	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: index + 1		to: index + aString size		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pad: aString left: aCharacter to: anInteger	"Pad to the left side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: anInteger - aString size + 1		to: anInteger		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pad: aString right: aCharacter to: anInteger	"Pad to the right side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: 1		to: aString size		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject	^ String streamContents: [ :stream | self print: anObject on: stream ]! !!GRPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	"Subclasses override this method to produce some output."! !!GRSequentialPrinter methodsFor: 'operators' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!, aConverter	parts add: aConverter! !!GRSequentialPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	parts := OrderedCollection new! !!GRSequentialPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream 	parts do: [ :each | each print: anObject on: aStream ]! !!GRSignPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self negativePrinter: $-.	self positivePrinter: nil! !!GRSignPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!negativePrinter: aPrinter	"The printer to be used when the number is negative."		negativePrinter := aPrinter! !!GRSignPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!positivePrinter: aPrinter	"The printer to be used when the number is zero or positive."		positivePrinter := aPrinter! !!GRSignPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream 	anObject negative		ifTrue: [ negativePrinter print: anObject on: aStream ]		ifFalse: [ positivePrinter print: anObject on: aStream ]! !!GRStringPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!character: aCharacter	"The character to pad the string with."		character := aCharacter! !!GRStringPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self character: $ ; length: nil.	self trimNone; padNone! !!GRStringPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!length: anInteger	"The maximal size of the string, or the size to pad to."	length := anInteger! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padCenter	"Pad to the center."		pad := #pad:center:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padLeft	"Pad to the left."		pad := #pad:left:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padNone	"Do not pad the input."		pad := nil! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padRight	"Pad to the right."		pad := #pad:right:to:! !!GRStringPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream 	| string |	string := anObject greaseString.	trim isNil		ifFalse: [ string := string perform: trim ].	length isNil ifFalse: [		length < string size 			ifTrue: [ string := string copyFrom: 1 to: length ].		(pad isNil or: [ character isNil ])			ifFalse: [ string := self perform: pad with: string with: character with: length ] ].	aStream nextPutAll: string! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimBoth	"Trim to the left and to the right."	trim := #trimBoth! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimLeft	"Trim to the left and to the right."	trim := #trimLeft! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimNone	"Do not trim the input."	trim := nil! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimRight	"Trim to the left and to the right."	trim := #trimRight! !!GRUnitPrinter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base: anInteger units: anArray	^ self new 		base: anInteger;		units: anArray;		yourself! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base: anInteger	base := anInteger! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fractionPrinter: aPrinter	fractionPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self integerPrinter: (GRNumberPrinter new		precision: 0;		yourself).	self fractionPrinter: (GRNumberPrinter new		precision: 1;		yourself)! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!integerPrinter: aPrinter	integerPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	anObject = 1		ifTrue: [ ^ self print: anObject unit: units first on: aStream ].	units allButFirst		inject: anObject asFloat		into: [ :value :each |			value < base				ifFalse: [ value / base ]				ifTrue: [ ^ self print: value unit: each on: aStream ] ]! !!GRUnitPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: aNumber unit: aString on: aStream	(units first = aString or: [ units second = aString ])		ifTrue: [ integerPrinter print: aNumber on: aStream ]		ifFalse: [ fractionPrinter print: aNumber on: aStream ].	aStream nextPut: $ ; nextPutAll: aString! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!units: anArray	units := anArray! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self privateAt: anAssociation key put: anAssociation value.	^ anAssociation! !!GROrderedMultiMap methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!"protocol: adding"addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value |			self privateAt: key put: value ].	^ aDictionary! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey	^ Array streamContents: [ :stream |		1 to: size do: [ :index |			(keys at: index) = aKey				ifTrue: [ stream nextPut: (values at: index) ] ] ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey ifAbsent: absentBlock	| results |	results := self allAt: aKey.	^ results isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ results ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey add: aValue	"Add an association between aKey and aValue. Do not replace existing	values with the same key."		^ self privateAt: aKey put: aValue! !!GROrderedMultiMap methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndAllValuesDo: aTwoArgumentBlock	| seenKeys |	seenKeys := GRSmallOrderedSet new.	1 to: size do: [ :index |		| key |		key := keys at: index.		(seenKeys includes: key) ifFalse: [			aTwoArgumentBlock				value: key				value: (self privateAllAt: key startingAt: index).			seenKeys add: key ] ]! !!GROrderedMultiMap methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAllAt: aKey startingAt: aStartInteger	^ Array new: 2 streamContents: [ :stream |		aStartInteger to: size do: [ :index |			(keys at: index) = aKey				ifTrue: [ stream nextPut: (values at: index) ] ] ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	"This is inefficient and could be optimized."	| removed |	removed := Array new: 2 streamContents: [ :stream |		| index |		[ (index := self findIndexFor: aKey) = 0 ] whileFalse: [			stream nextPut: (self removeIndex: index) ] ].	^ removed isEmpty		ifTrue: [ aBlock value ]		ifFalse: [ removed ]! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self new: 3! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!GRSmallDictionary methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value | self at: key put: value ].	^ aDictionary! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	self isEmpty		ifTrue: [ ^ self errorEmptyCollection ].	^ values at: 1! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associations	"Answer a Collection containing the receiver's associations."	| result |	result := WriteStream on: (Array new: self size).	self associationsDo: [ :assoc | result nextPut: assoc ].	^ result contents! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associationsDo: aBlock	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey	"Answer the value associated with aKey. Raise an exception, if no such key is defined."	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsent: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ aBlock value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsentPut: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ self privateAt: aKey put: aBlock value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifPresent: aBlock	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| index |	index := self findIndexFor: aKey.	^ index = 0 ifFalse: [ aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey put: aValue	"Set the value of aKey to be aValue."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index put: aValue ]		ifTrue: [ self privateAt: aKey put: aValue ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aBlock	1 to: size do: [ :index | aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorEmptyCollection	self error: 'Empty'! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorKeyNotFound	self error: 'Key not found'! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!findIndexFor: aKey	1 to: size do: [ :index |		(keys at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grow	| newKeys newValues |	newKeys := Array new: 2 * size.	newValues := Array new: 2 * size.	1 to: size do: [ :index |		newKeys at: index put: (keys at: index).		newValues at: index put: (values at: index) ].	keys := newKeys.	values := newValues! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!includesKey: aKey	"Answer whether the receiver has a key equal to aKey."	^ (self findIndexFor: aKey) ~= 0! !!GRSmallDictionary methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize: anInteger	self initialize.	size := 0.	keys := Array new: anInteger.	values := Array new: anInteger! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isCollection	^ true! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isEmpty	^ size = 0! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keys	^ keys copyFrom: 1 to: size! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndValuesDo: aBlock	1 to: size do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysDo: aBlock	1 to: size do: [ :each | aBlock value: (keys at: each) ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!noneSatisfy: aOneArgumentBlock	1 to: size do: [ :index |		(aOneArgumentBlock value: (values at: index)) ifTrue: [ ^ false ] ].	^ true! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!notEmpty	^ size ~= 0! !!GRSmallDictionary methodsFor: 'copying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!postCopy	super postCopy.	keys := keys copy.	values := values copy! !!GRSmallDictionary methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self size <= 100		ifTrue: [			| first |			first := true.			self keysAndValuesDo: [ :key :value |				"keysAndValuesDo:separatedBy: would be nice"				first					ifTrue: [ first := false ]					ifFalse: [ aStream space ].				aStream					print: key;					nextPutAll: '->';									print: value ] ]		ifFalse: [			aStream				nextPutAll: 'size ';				print: self size ].	aStream nextPut: $)	! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAt: aKey put: aValue	size = keys size ifTrue: [ self grow ].	keys at: (size := size + 1) put: aKey.	^ values at: size put: aValue! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeIndex: index	| value |	value := values at: index.	index to: size - 1 do:			[ :i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1) ].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^ value! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey	"Remove aKey from the receiver, raise an exception if the element is missing."	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	| index |	index := self findIndexFor: aKey.	index = 0 ifTrue: [ ^ aBlock value ].	^ self removeIndex: index! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ size! !!GRSmallDictionary methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted	^ self values sorted! !!GRSmallDictionary methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted: aTwoArgumentBlock	^ self values sorted: aTwoArgumentBlock! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!values	^ values copyFrom: 1 to: size! !!GROrderedMultiMap2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self privateAt: anAssociation key put: anAssociation value.	^ anAssociation! !!GROrderedMultiMap2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value |			self privateAt: key put: value ].	^ aDictionary! !!GROrderedMultiMap2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey	^ self privateAllAt: aKey startingAt: 1! !!GROrderedMultiMap2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey ifAbsent: absentBlock	| results |	results := self allAt: aKey.	^ results isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ results ]! !!GROrderedMultiMap2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey add: aValue	"Add an association between aKey and aValue. Do not replace existing	values with the same key."		^ self privateAt: aKey put: aValue! !!GROrderedMultiMap2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndAllValuesDo: aTwoArgumentBlock	| seenKeys |	seenKeys := GRSmallOrderedSet new.	1 to: size * 2 - 1 by: 2 do: [ :index |		| key |		key := table at: index.		(seenKeys includes: key) ifFalse: [			aTwoArgumentBlock				value: key				value: (self privateAllAt: key startingAt: index).			seenKeys add: key ] ]! !!GROrderedMultiMap2 methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAllAt: aKey startingAt: index	^ Array new: 2 streamContents: [ :stream |		index to: size * 2 - 1 by: 2 do: [ :i |			(table at: i) = aKey				ifTrue: [ stream nextPut: (table at: i + 1) ] ] ]! !!GROrderedMultiMap2 methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	"This is inefficient and could be optimized."	| removed |	removed := Array new: 2 streamContents: [ :stream |		| index |		[ (index := self findIndexFor: aKey) = 0 ] whileFalse: [			stream nextPut: (self removeIndex: index) ] ].	^ removed isEmpty		ifTrue: [ aBlock value ]		ifFalse: [ removed ]! !!GRSmallDictionary2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self new: 3! !!GRSmallDictionary2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallDictionary2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !!GRSmallDictionary2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!GRSmallDictionary2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value | self at: key put: value ].	^ aDictionary! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	self isEmpty		ifTrue: [ ^ self errorEmptyCollection ].	^ table at: 2! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associations	"Answer a Collection containing the receiver's associations."	| result |	result := WriteStream on: (Array new: self size).	self associationsDo: [ :assoc | result nextPut: assoc ].	^ result contents! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associationsDo: aBlock	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey	"Answer the value associated with aKey. Raise an exception, if no such key is defined."	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsent: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ table at: index + 1 ]		ifTrue: [ aBlock value ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsentPut: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ table at: index + 1 ]		ifTrue: [ self privateAt: aKey put: aBlock value ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifPresent: aBlock	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| index |	index := self findIndexFor: aKey.	^ index = 0 ifFalse: [ aBlock value: (table at: index + 1) ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey put: aValue	"Set the value of aKey to be aValue."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ table at: index + 1 put: aValue ]		ifTrue: [ self privateAt: aKey put: aValue ]! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aBlock	2 to: size * 2 by: 2 do: [ :index |		aBlock value: (table at: index) ]! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorEmptyCollection	self error: 'Empty'! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorKeyNotFound	self error: 'Key not found'! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!findIndexFor: aKey	1 to: size * 2 - 1 by: 2 do: [ :index |		(table at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grow	| newTable |	"#replaceFrom:to:with:startingAt: would be better but not portable"	newTable := Array new: 4 * size.	1 to: size * 2 do: [ :index |		newTable at: index put: (table at: index) ].	table := newTable! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!includesKey: aKey	"Answer whether the receiver has a key equal to aKey."	^ (self findIndexFor: aKey) ~= 0! !!GRSmallDictionary2 methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize: anInteger	self initialize.	size := 0.	table := Array new: anInteger * 2! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isCollection	^ true! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isEmpty	^ size = 0! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keys	| keys i |	size = 0 ifTrue: [ ^ #() ].	i := 1.	keys := Array new: size.	1 to: size * 2 - 1 by: 2 do: [ :index |		keys at: i put: (table at: index).		i := i + 1 ].	^ keys! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndValuesDo: aBlock	1 to: size * 2 - 1 by: 2 do: [ :index |		aBlock			value: (table at: index)			value: (table at: index + 1) ]! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysDo: aBlock	1 to: size * 2 - 1 by: 2 do: [ :index |			aBlock value: (table at: index) ]! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!noneSatisfy: aOneArgumentBlock	size = 0 ifTrue: [ ^ true ].	2 to: size * 2 by: 2 do: [ :index |		(aOneArgumentBlock value: (table at: index)) ifTrue: [ ^ false ] ].	^ true! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!notEmpty	^ size ~= 0! !!GRSmallDictionary2 methodsFor: 'copying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!postCopy	super postCopy.	table := table copy! !!GRSmallDictionary2 methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self size <= 100		ifTrue: [			| first |			first := true.			self keysAndValuesDo: [ :key :value |				"keysAndValuesDo:separatedBy: would be nice"				first					ifTrue: [ first := false ]					ifFalse: [ aStream space ].				aStream					print: key;					nextPutAll: '->';									print: value ] ]		ifFalse: [			aStream				nextPutAll: 'size ';				print: self size ].	aStream nextPut: $)	! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAt: aKey put: aValue	size * 2 = table size ifTrue: [ self grow ].	table at: (size * 2 + 1) put: aKey.	table at: (size * 2 + 2) put: aValue.	size := size + 1.	^ aValue! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeIndex: index	| value |	value := table at: index + 1.	index to: size * 2 - 2 do: [ :i | 		table at: i put: (table at: i + 2) ].	table at: size * 2 - 1 put: nil.	table at: size * 2 put: nil.	size := size - 1.	^ value! !!GRSmallDictionary2 methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey	"Remove aKey from the receiver, raise an exception if the element is missing."	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary2 methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	| index |	index := self findIndexFor: aKey.	index = 0 ifTrue: [ ^ aBlock value ].	^ self removeIndex: index! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ size! !!GRSmallDictionary2 methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted	^ self values sorted! !!GRSmallDictionary2 methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted: aTwoArgumentBlock	^ self values sorted: aTwoArgumentBlock! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!values	| values i |	size = 0 ifTrue: [ ^ #() ].	i := 1.	values := Array new: size.	2 to: size * 2 by: 2 do: [ :index |		values at: i put: (table at: index).		i := i + 1 ].	^ values! !!GRSmallOrderedSet class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self new: 3! !!GRSmallOrderedSet class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallOrderedSet class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !!GRSmallOrderedSet methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: newObject	(self findIndexFor: newObject) = 0		ifTrue: [ self privateAdd: newObject ].	^ newObject! !!GRSmallOrderedSet methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aCollection	aCollection do: [ :each |		self add: each ].	^ aCollection! !!GRSmallOrderedSet methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aOneArgumentBlock	1 to: size do: [ :i |		aOneArgumentBlock value: (table at: i) ]! !!GRSmallOrderedSet methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aOneArgumentBlock separatedBy: aNiladicBlock	1 to: size do: [ :i |		i > 1 ifTrue: [ aNiladicBlock value ].		aOneArgumentBlock value: (table at: i) ]! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorNotFound	self error: 'Not found'! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!findIndexFor: aKey	1 to: size do: [ :index |		(table at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grow	| newTable |	"#replaceFrom:to:with:startingAt: would be better but not portable"	newTable := Array new: 2 * size.	1 to: size do: [ :index |		newTable at: index put: (table at: index) ].	table := newTable! !!GRSmallOrderedSet methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!includes: anObject	^ (self findIndexFor: anObject) ~= 0! !!GRSmallOrderedSet methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize: anInteger	self initialize.	size := 0.	table := Array new: anInteger! !!GRSmallOrderedSet methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isCollection	^ true! !!GRSmallOrderedSet methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isEmpty	^ size = 0! !!GRSmallOrderedSet methodsFor: 'copying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!postCopy	super postCopy.	table := table copy! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAdd: newObject	size = table size ifTrue: [ self grow ].	table at: (size := size + 1) put: newObject.! !!GRSmallOrderedSet methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!remove: anObject	^ self remove: anObject ifAbsent: [ self errorNotFound ]! !!GRSmallOrderedSet methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!remove: anObject ifAbsent: aNiladicBlock	| index |	index := self findIndexFor: anObject.	index = 0		ifTrue: [ ^ aNiladicBlock value ]		ifFalse: [ self removeIndex: index ].	^ anObject! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeIndex: index	table at: index put: nil.	index to: size - 1 do: [ :i |		table at: i put: (table at: i + 1) ].	size := size - 1! !!GRSmallOrderedSet methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ size! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: majorInteger	^ self major: majorInteger minor: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: majorInteger minor: minorInteger	^ self major: majorInteger minor: minorInteger revision: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: majorInteger minor: minorInteger revision: revisionInteger	^ self basicNew		initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger;		yourself! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self major: 1! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!< otherVersion	(major < otherVersion major) ifTrue: [ ^ true ].	(otherVersion major < major) ifTrue: [ ^ false ].	((minor ifNil: [ 0 ]) < (otherVersion minor ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion minor ifNil: [ 0 ]) < (minor ifNil: [ 0 ])) ifTrue: [ ^ false ].	((revision ifNil: [ 0 ]) < (otherVersion revision ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion revision ifNil: [ 0 ]) < (revision ifNil: [ 0 ])) ifTrue: [ ^ false ].	(stageLabel = otherVersion stage) ifTrue: [		^ ((stageNumber ifNil: [ 1 ]) < (otherVersion stageNumber ifNil: [ 1 ])) ].	stageLabel isNil ifTrue: [ ^ false ].	otherVersion stage isNil ifTrue: [ ^ true ].	^ stageLabel < otherVersion stage		! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!<= otherVersion	^ (self > otherVersion) not! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!= otherVersion	^ (major = otherVersion major) and: [		((minor ifNil: [ 0 ]) = (otherVersion minor ifNil: [ 0 ])) and: [		((revision ifNil: [ 0 ] ) = (otherVersion revision ifNil: [ 0 ])) and: [		(stageLabel = otherVersion stage) and: [		(stageNumber ifNil: [ 1 ]) = (otherVersion stageNumber ifNil: [ 1 ]) ] ] ] ]! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!> otherVersion	^ otherVersion < self! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!>= otherVersion	^ (self < otherVersion) not! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beAlpha	self beAlpha: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beAlpha: anInteger	self stage: #alpha number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beBeta	self beBeta: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beBeta: anInteger	self stage: #beta number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beFinal	self stage: nil number: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beReleaseCandidate	self beReleaseCandidate: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beReleaseCandidate: anInteger	self stage: #rc number: anInteger! !!GRVersion methodsFor: 'converting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	^ String streamContents: [ :stream |		stream nextPutAll: major greaseString.		stream nextPut: $..		stream nextPutAll: (minor ifNil: [ 0 ]) greaseString.		revision isNil ifFalse: [			stream nextPut: $..			stream nextPutAll: revision greaseString ].		stageLabel isNil ifFalse: [			stream nextPutAll: stageLabel greaseString.			stageNumber isNil ifFalse: [ stream nextPutAll: stageNumber greaseString ] ] ]! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!hash	^ (major hash		bitXor: (minor ifNil: [ 0 ]) hash)		bitXor: (revision ifNil: [ 0 ]) hash! !!GRVersion methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger	self initialize.	major := majorInteger.	minor := minorInteger.	revision := revisionInteger! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isAlpha	^ stageLabel = #alpha! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isBeta	^ stageLabel = #beta! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isFinal	^ stageLabel isNil! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isReleaseCandidate	^ stageLabel = #rc! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major	^ major! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: anInteger	major := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!minor	^ minor! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!minor: anInteger	minor := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!revision	^ revision! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!revision: anInteger	revision := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stage	^ stageLabel! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stage: aSymbol number: anInteger	stageLabel := aSymbol.	stageNumber := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stageNumber	^ stageNumber! !!Object methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseDeprecatedApi: apiString details: detailsString 	GRDeprecatedApiNotification new		details: detailsString;		signal: apiString! !!Number methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	"Answer an integer of the receiver, in our case we simply truncate the number."	^ self truncated! !"Grease-Core"!!GRPharoLatin1Codec commentStamp: '<historical>' prior: 0!A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).!!GRPharoUtf8Codec commentStamp: 'pmm 2/20/2009 12:51' prior: 0!A WAUtf8Codec is a WACodec optimized for UTF-8.!!GRPharoPlatform commentStamp: 'pmm 6/1/2008 01:03' prior: 0!A WASqueakPlatform is the Squeak implementation of SeasidePlatformSupport, the Seaside class that provides functionality that can not be implemented in a platform independent way.!!GRPharoConverterCodecStream commentStamp: 'pmm 6/25/2012 20:22' prior: 0!A WAConverterCodecStream is a WACodec stream around a TextConverter. It is always in text mode.Instance Variables	converter:		<TextConverter>converter	- the TextConverter used to do the encoding conversion!!GRPharoUtf8CodecStream commentStamp: 'pmm 2/20/2009 12:27' prior: 0!A WAUtf8CodecStream is a WACodecStream optimized for UTF-8 performance in the case where most of the characters are ASCII.!!GRPharoLatin1CodecStream commentStamp: '<historical>' prior: 0!A GRPharoLatin1CodecStream is a WACodecStream optimized for ISO-8859-1 (direct byte to character mapping).!!Number methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!milliseconds	^ self milliSeconds! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	Smalltalk addToStartUpList: self.	self startUp! !!GRPharoRandomProvider class methodsFor: 'public' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextInt: anInteger	"Answer a random integer in the interval [1, anInteger]"	^ mutex critical: [ generator nextInt: anInteger ]! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!randomClass	^ Random! !!GRPharoRandomProvider class methodsFor: 'public' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!randomFrom: aCollection	| random count |	random := self nextInt: aCollection size.	^ aCollection isSequenceable		ifTrue: [ aCollection at: random ]		ifFalse: [			count := 1.			aCollection do: [ :ea |				count = random ifTrue: [ ^ ea ].				count := count + 1 ] ]! !!GRPharoRandomProvider class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!startUp	generator := self randomClass new.	mutex := Semaphore forMutualExclusion! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unload	GRPlatform current removeFromStartUpList: self! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	(self supportsEncoding: aString)		ifFalse: [ self unsupportedEncoding: aString ].	^ self basicNew initializeWithName: aString! !!GRPharoLatin1Codec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ Array with: (self basicForEncoding: 'iso-8859-1')! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportedEncodingNames	^ #('iso-8859-1' 'ISO-8859-1' 'latin-1' 'latin1')! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	"Answer whether the the given encoding name is supported."	^ self supportedEncodingNames includes: aString! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aStringOrByteArray	"Overridden for efficencey."	^ aStringOrByteArray asString! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRPharoLatin1CodecStream on: aReadStream! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRPharoLatin1CodecStream on: aWriteStream! !!GRPharoLatin1Codec methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithName: aString 	self initialize.	name := aString! !!GRPharoLatin1Codec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ name! !!GRPharoGenericCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	(self supportsEncoding: aString)		ifFalse: [ self unsupportedEncoding: aString ].	^ self basicNew initializeWithName: aString! !!GRPharoGenericCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ (TextConverter allEncodingNames		select:  [ :each | 			"exclude UFT-8 which is handeled by WAUtf8Codec"			self supportsEncoding: each ])		collect: [ :each |			self basicForEncoding: each greaseString ]! !!GRPharoGenericCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportedEncodingNames	"answers the names of the encodings supported by this class"	^ (TextConverter allSubclasses gather: [ :class | class encodingNames ]) asSet asOrderedCollection		removeAllFoundIn: GRPharoLatin1Codec supportedEncodingNames;		removeAllFoundIn: UTF8TextConverter encodingNames;		yourself! !!GRPharoGenericCodec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	"Answer whether the the given encoding name is supported."	^ self supportedEncodingNames includes: aString! !!GRPharoGenericCodec methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!converter	^ TextConverter newForEncoding: self name! !!GRPharoGenericCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aStream	^ self encoderFor: aStream! !!GRPharoGenericCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aStream 	^ GRPharoConverterCodecStream 		on: aStream		converter: self converter! !!GRPharoGenericCodec methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithName: aString 	self initialize.	name := aString.	urlCodec := (#('iso-8859-15' 'cp-1252') includes: aString) 		ifFalse: [ GRCodec forEncoding: 'utf-8' ]		ifTrue: [ self ]! !!GRPharoGenericCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ name! !!GRPharoGenericCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"RFC 3986: When a new URI scheme defines a component that represents textual data consisting of characters from the Universal Character Set [UCS], the data should first be encoded as octets according to the UTF-8 character encoding."	^ urlCodec! !!GRPharoUtf8Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	^ self new! !!GRPharoUtf8Codec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ Array with: self new! !!GRPharoUtf8Codec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	^ (#('utf-8' 'UTF-8') includes: aString) or: [ UTF8TextConverter encodingNames includes: aString ]! !!GRPharoUtf8Codec methodsFor: 'decoding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream byte1 byte2 byte3 byte4 unicode stream |	stream := aString readStream.	outStream := WriteStream on: (String new: aString size).	[ stream atEnd not ] whileTrue: [		byte1 := stream next asInteger.		unicode := byte1.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next asInteger.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63) ].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next asInteger.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte4 := stream next asInteger.			(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63) ].		unicode ifNil: [ self invalidUtf8 ].		unicode = 16rFEFF "ignore BOM" ifFalse: [			outStream nextPut: (Character codePoint: unicode) ].		unicode := nil ].	^ outStream contents! !!GRPharoUtf8Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aStream 	^ GRPharoUtf8CodecStream 		on: aStream		converter: UTF8TextConverter new! !!GRPharoUtf8Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aStream 	^ GRPharoUtf8CodecStream 		on: aStream		converter: UTF8TextConverter new! !!GRPharoUtf8Codec methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!invalidUtf8	^ GRInvalidUtf8Error signal: 'Invalid UTF-8 input'! !!GRPharoUtf8Codec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'utf-8'! !!GRPharoUtf8Codec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	^ self! !!Interval methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	"#first (used by SequenceableCollection>>anyOne) is an accessor of	Interval and does not error on an empty Interval."		^ self at: 1! !!Point methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	"Reimplemented because in Pharo 1.4	(4 @ 2) greaseString	ansers  '(4@2)'"	^ String streamContents: [ :stream |		x printOn: stream.		stream nextPut: $@.		(y notNil and: [ y negative ])			ifTrue: [				"Avoid ambiguous @- construct"				stream space ].		y printOn: stream ]! !!ByteArray methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	"ByteArrays should not automatically be converted to Strings. You should use a GRCodec for this."	^ self printString! !!GRSmallDictionary methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!customizeExplorerContents	^ true! !!GRSmallDictionary methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!explorerContents	| contents |		contents := OrderedCollection new.	self keysAndValuesDo: [ :key :value |		contents add: (ObjectExplorerWrapper			with: value			name: (key printString contractTo: 32)			model: self) ].	^ contents! !!GRSmallDictionary methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!hasContentsInExplorer	^ true! !!ScaledDecimal methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encodeOn: aDocument	| converter |	converter := GRSignPrinter new, (GRNumberPrinter new precision: self scale).	converter print: self on: aDocument! !!ScaledDecimal methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	| converter |	converter := GRSignPrinter new, (GRNumberPrinter new precision: self scale).	^ converter print: self! !!WriteStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	^ self next: anInteger putAll: aCollection startingAt: startIndex! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	self initializeXmlTable.	self initializeUrlTable.	self select! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeUrlTable	UrlTable := ByteArray new: 256.	1 to: 256 do: [ :index |		('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~' includes: (Character codePoint: index - 1))			ifTrue: [ UrlTable at: index put: 0 ]			ifFalse: [ UrlTable at: index put: 1 ] ]! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeXmlTable	XmlTable := ByteArray new: 256.	1 to: 256 do: [ :index |		('"<&>' includes: (Character codePoint: index - 1))			ifTrue: [ XmlTable at: index put: 1 ]			ifFalse: [ XmlTable at: index put: 0 ] ]! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unload	self unselect! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	Smalltalk addToShutDownList: anObject! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToStartUpList: aClass	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	SessionManager default registerUserClassNamed: aClass name.! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	^ self useByteArrayLiterals		ifTrue: [ self asMethodReturningByteArrayLiteral: aByteArrayOrString named: aSymbol ]		ifFalse: [ self asMethodReturningByteArrayWithCache: aByteArrayOrString named: aSymbol ]! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArrayLiteral: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a byte array using VW/NewCompiler byte array literal syntax."	^ String streamContents: [ :stream |		stream nextPutAll: aSymbol; nextPut: Character cr.		stream tab; nextPutAll: '^ #['.		aByteArrayOrString asByteArray			do: [ :each | each printOn: stream ]			separatedBy: [ stream space ].		stream nextPutAll: ']' ]! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArrayWithCache: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a byte array and caching this array in a literal array of size 1."	^ String streamContents: [ :stream |		stream nextPutAll: aSymbol; nextPut: Character cr.		stream tab; nextPutAll: '^ #('.		aByteArrayOrString asByteArray			do: [ :each | each printOn: stream ]			separatedBy: [ stream space ].		stream nextPutAll: ') asByteArray' ]! !!GRPharoPlatform methodsFor: 'encoding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base64Decode: aString	^ aString base64Decoded asString! !!GRPharoPlatform methodsFor: 'bindings' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!bindingOf: aClass		^ Smalltalk globals associationAt: aClass name! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!compile: aString into: aClass classified: aSymbol 	aClass compile: aString classified: aSymbol! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!contentsOfFile: aString binary: aBoolean	^ self fileStreamOn: aString do: [ :stream | stream contents ] binary: aBoolean! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	^ Array streamContents: [ :stream | 		FileSystem disk directoriesAt: aPathString do: [ :each |			each basename first = $. ifFalse: [				stream nextPut: each asFileReference fullName  ] ] ]! !!GRPharoPlatform methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!doSilently: aBlock	^ SystemAnnouncer uniqueInstance suspendAllWhile:  aBlock! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!ensureExistenceOfFolder: aString	"creates a folder named aString in the image directory"	FileSystem disk ensureCreateDirectory: aString! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileExists: aString	^ aString asFileReference exists ! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileStreamOn: aString do: aBlock binary: aBoolean	^ aBoolean		ifTrue: [			FileStream fileNamed: aString do: [ :stream |				stream binary.				aBlock value: stream ] ]		ifFalse: [			MultiByteFileStream fileNamed: aString do: [ :stream |				stream					ascii;					wantsLineEndConversion: true.					aBlock value: stream ] ]! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!filesIn: aPathString	"Return a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	^ Array streamContents: [ :stream | 		FileSystem disk filesAt: aPathString do: [ :each |			each basename first = $. ifFalse: [				stream nextPut: each asFileReference fullName  ] ] ]! !!GRPharoPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."	^ aProcess isTerminated! !!GRPharoPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!label	^ 'Pharo'! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!localNameOf: aFilename	^ (FileSystem disk resolveString: aFilename) basename! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.."	^ GRPharoRandomProvider! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newline	^ String cr! !!GRPharoPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!openDebuggerOn: anError	| process |	process := Processor activeProcess.	"If we are running in the UI process, we don't want to suspend the active process. The	error was presumably triggered while stepping in the Debugger. If we simply immediately	signal an UnhandledError, the debugger will catch this and display the signaling context.	It isn't perfect or pretty but it works."	(ProcessBrowser isUIProcess: process)		ifTrue: [			UnhandledError signalForException: anError ]		ifFalse: [			WorldState addDeferredUIMessage: [				process					debug: anError signalerContext					title: anError description					full: true ].			process suspend ]! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pathSeparator	^ String with: FileSystem disk delimiter! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteByteStream	"ByteArray based read write stream"		^ ReadWriteStream on: (ByteArray new: 4096)! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteCharacterStream	"String based read write stream"	^ ReadWriteStream on: (String new: 4096)! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromShutDownList: aClass	"Remove aClass from the shutdown list in the system."	SessionManager default unregisterClassNamed: aClass name! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromStartUpList: aClass	"Remove aClass from the startup list in the system."	SessionManager default unregisterClassNamed: aClass name! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeSelector: aSymbol from: aClass	aClass removeSelector: aSymbol! !!GRPharoPlatform methodsFor: 'cryptography' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!secureHashFor: aString	^ SHA1 new hashMessage: aString! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	^ Semaphore! !!GRPharoPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stackDepth	| depth current |	depth := 0.	current := thisContext.	[ current isNil ] whileFalse: [		current := current sender.		depth := depth + 1 ].	^ depth - 1! !!GRPharoPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."	aProcess terminate! !!GRPharoPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!thisContext	^ thisContext sender! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!useByteArrayLiterals	"whether ByteArray literals can/should be used"	^ true! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!weakDictionaryOfSize: aNumber	^ IdentityDictionary new: aNumber! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"writes aStringOrByteArray to a file named aFilenameString in the folder aFolderString"	| folder stream fullFilePath |	folder := FileSystem disk resolveString: aFolderString.	fullFilePath := (folder / aFileNameString) asFileReference.	stream := aStringOrByteArray isString		ifTrue: [			(MultiByteFileStream forceNewFileNamed: fullFilePath fullName)				ascii;				wantsLineEndConversion: true;				yourself ]		ifFalse: [ (FileStream forceNewFileNamed: fullFilePath fullName) binary ].	[ stream nextPutAll: aStringOrByteArray ]		ensure: [ stream close ]! !!Duration class methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!milliseconds: anInteger	^ self milliSeconds: anInteger! !!Duration methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMilliseconds	^ self asMilliSeconds! !!Duration methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!milliseconds	^ nanos quo: NanosInMillisecond! !!Behavior methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fullName	"In VW, will include the namespace"	^ self name! !!PositionableStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseUpToAll: aCollection 	"Needed for Seaside ports to other dialects where #upToAll: may have	different semantics"	^ self upToAll: aCollection! !!GRPharoConverterCodecStream class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!on: aStream converter: aConverter	^ self basicNew initializeOn: aStream converter: aConverter! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	self nextPutAll: (aCollection copyFrom: startIndex to: startIndex + anInteger - 1)! !!GRPharoConverterCodecStream methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeOn: aStream converter: aConverter	self initializeOn: aStream.	converter := aConverter! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	| character |	character := converter nextFromStream: stream.	^ character isNil		ifFalse: [ character asCharacter ]! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	| writeStream |	writeStream := WriteStream on: (String new: anInteger).	anInteger timesRepeat: [		writeStream nextPut: (self next			ifNil: [ ^ writeStream contents ]) ].	^ writeStream contents! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	converter nextPut: aCharacter asCharacter toStream: stream! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	aString asString do: [ :each | self nextPut: each ]! !!GRPharoUtf8CodecStream class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	(Smalltalk hasClassNamed: #UTF8TextConverter) "guard for Squeak 37"		ifFalse: [ ^ self ].	Latin1ToUtf8Map := ByteArray new: 256.	Latin1ToUtf8Encodings := Array new: 256.	0 to: 255 do:[ :index |		| latin1 utf8 |		latin1 := String with: (Character codePoint: index).		utf8 := latin1 convertToWithConverter: UTF8TextConverter new.		latin1 = utf8			ifTrue:[				Latin1ToUtf8Map at: index + 1 put: 0 ] "no translation needed"			ifFalse:[				Latin1ToUtf8Map at: index + 1 put: 1. "no translation needed"				Latin1ToUtf8Encodings at: index + 1 put: utf8 ] ]! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!crlf	stream nextPut: Character cr.	stream nextPut: Character lf! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encodeDefault: aString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	1 to: aString size by: 1 do: [ :index |		converter nextPut: (aString at: index) toStream: stream ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encodeFast: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| lastIndex nextIndex |	lastIndex := 1.	nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue: [ ^ stream nextPutAll: aByteString ].	[	nextIndex > lastIndex ifTrue: [			stream greaseNext: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex ].		stream nextPutAll: (Latin1ToUtf8Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.		nextIndex = 0 ] whileFalse.	stream greaseNext: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	aCollection isByteString		ifTrue: [ self greaseNext: anInteger putAllFast: aCollection startingAt: startIndex ]		ifFalse: [ super greaseNext: anInteger putAll: aCollection startingAt: startIndex ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAllFast: aByteString startingAt: startIndex	| lastIndex nextIndex |	lastIndex := startIndex.	nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue: [ ^ stream greaseNext: anInteger putAll: aByteString startingAt: startIndex ].	[			nextIndex >= (startIndex + anInteger) ifTrue: [			^ stream greaseNext: startIndex + anInteger - lastIndex  putAll: aByteString startingAt: lastIndex ].		nextIndex > lastIndex ifTrue: [			stream greaseNext: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex ].		stream nextPutAll: (Latin1ToUtf8Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.		(nextIndex = 0 or: [ nextIndex >= (startIndex + anInteger) ]) ] whileFalse.	lastIndex >= (startIndex + anInteger) ifFalse: [		stream greaseNext: startIndex + anInteger - lastIndex putAll: aByteString startingAt: lastIndex ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!invalidUtf8	^ GRInvalidUtf8Error signal: 'Invalid UTF-8 input'! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	^ (self next: 1) first! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| output byte1 byte2 byte3 byte4 unicode count alreadyWide |	output := ByteString new: anInteger.	count := 0.	alreadyWide := false.	[ count < anInteger and: [ stream atEnd not ] ] whileTrue: [		byte1 := stream next.		unicode := byte1.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63).			alreadyWide ifFalse: [				output := WideString withAll: output.				alreadyWide := true ] ].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte4 := stream next.			(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63).			alreadyWide ifFalse: [				output := WideString withAll: output.				alreadyWide := true ] ].		unicode ifNil: [ self invalidUtf8 ].		unicode = 16rFEFF "ignore BOM" ifFalse: [			count := count + 1.			output at: count put: (Character codePoint: unicode) ].		unicode := nil ].	^ count < anInteger		ifTrue: [ output first: count ]		ifFalse: [ output ]! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	| codePoint shouldEncode |	codePoint := aCharacter codePoint.	codePoint > 255		ifTrue: [ ^ self nextPutAll: (String with: aCharacter) ].	shouldEncode := Latin1ToUtf8Map at: codePoint + 1.	shouldEncode = 1		ifTrue: [ stream nextPutAll: (Latin1ToUtf8Encodings at: codePoint + 1) ]		ifFalse: [ stream nextPut: aCharacter ]	! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	aString isByteString		ifTrue: [ self encodeFast: aString ]		ifFalse: [ self encodeDefault: aString ]! !!GRDelegatingStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	stream greaseNext: anInteger putAll: aCollection startingAt: startIndex! !!GRDynamicVariable class methodsFor: 'defaults' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultValue	^ nil! !!GRDynamicVariable class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!use: anObject during: aBlock	^ self		value: anObject		during: aBlock! !!GRDynamicVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!default	^ self class defaultValue! !!SequenceableCollection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beginsWithSubCollection: aSequenceableCollection	"Some platforms implement #beginsWith: to answer true for an empty argument."	^ self beginsWith: aSequenceableCollection! !!SequenceableCollection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!endsWithSubCollection: aSequenceableCollection	"Some platforms implement #endsWith: to answer true for an empty argument."	^ self endsWith: aSequenceableCollection! !!SequenceableCollection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30' prior: 61536805!sorted	^ self sorted: [ :a :b | a <= b ]! !!GRPackage class methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greasePharo70Core	^ self new		name: 'Grease-Pharo70-Core';		addDependency: 'Grease-Core';		url: #greaseUrl;		yourself! !!MessageSend methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	^ selector numArgs - self arguments size! !!MessageSend methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithPossibleArguments: anArray	"Evaluate the block represented by the receiver.     If the block requires one argument, use anArg, if it requires more than one,     fill up the rest with nils."	^ self valueWithEnoughArguments: anArray! !!Collection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	^ self anyOne! !!GRPharoLatin1CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	^ Character value: stream next! !!GRPharoLatin1CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	^ (stream next: anInteger) asString! !!SocketStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	"Put a String or a ByteArray onto the stream starting at the given position.	Currently a large collection will allocate a large buffer."	| toPut |	anInteger = 0 ifTrue: [		^ aCollection ].	toPut := binary ifTrue: [ aCollection asByteArray ] ifFalse: [ aCollection asString ].	self adjustOutBuffer: anInteger.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + anInteger - 1 with: toPut startingAt: startIndex.	outNextToWrite := outNextToWrite + anInteger.	self checkFlush! !!Character methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	"Answer an unicode code point of the receiver."	^ self charCode! !!Object methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	^ self asString! !!BlockClosure methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithPossibleArguments: anArray	| args |	(anArray size == self numArgs)		ifTrue: [ ^ self valueWithArguments: anArray ].	args := Array new: self numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self valueWithArguments: args! !!Color methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asHTMLColor	^'#', self asHexString! !"Grease-Pharo70-Core"!!GRObjectInRule commentStamp: 'pmm 9/12/2009 10:37' prior: 0!I detect senders of Object >> #in:!!GRTestAssertionsRule commentStamp: 'pmm 8/17/2014 11:24' prior: 0!I check for TestCase >> #fail.!!GRBasicNewInitializeMissingRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext 	(aContext isMeta not		and: [ (aContext includesSelector: #initialize)		and: [ (#(GRObject GRNotification GRNotification GRError RBLintRule RBTransformationRule) noneSatisfy: [ :each |				aContext includesBehavior: (Smalltalk globals at: each) ])		and: [ aContext class methodDictionary noneSatisfy: [ :each | 				matcher 					executeTree: each parseTree					initialAnswer: false ] ] ] ]) ifTrue: [		result 			addClass: aContext			selector: #initialize ]! !!GRBasicNewInitializeMissingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRBasicNewInitializeMissingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	matcher := RBParseTreeSearcher new.	matcher 		matches: 'self basicNew initialize'		do: [ :node :answer | true ]! !!GRBasicNewInitializeMissingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ '#basicNew initialize is missing'! !!GRBasicNewInitializeMissingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#initialize is not called implicitely when sending #new to an object in other Smalltalk dialects. Consider subclassing GRObject.'! !!GRDeprecatedApiProtocolRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	| matches |	matches := matcher		executeTree: aContext parseTree		initialAnswer: OrderedCollection new.	matches do: [ :node |		" This ensures that the description is of the form ClassName>>#selector:"		(node arguments first isLiteralNode			and: [ node arguments first value isString			and: [ aContext methodClass name greaseString , '>>#' , aContext selector greaseString ~= node arguments first value ] ]) ifTrue: [				result addClass: aContext methodClass selector: aContext selector.				result addSearchString: node arguments first value ].		" This ensures that the description is a string and ends with a dot."		(node arguments size > 1			and: [ node arguments second isLiteralNode			and: [ node arguments second value isString			and: [ (node arguments second value endsWithSubCollection: '.') not ] ] ]) ifTrue: [				result addClass: aContext methodClass selector: aContext selector.				result addSearchString: node arguments second value ] ]! !!GRDeprecatedApiProtocolRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRDeprecatedApiProtocolRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	matcher := RBParseTreeSearcher new.	matcher 		matchesAnyOf: #(			'``@receiver greaseDeprecatedApi: ``@arg1'			'``@receiver greaseDeprecatedApi: ``@arg1 details: ``@arg2' )		do: [ :node :answer | answer add: node; yourself ]! !!GRDeprecatedApiProtocolRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Invalid use of deprecated API protocol.'! !!GRDeprecatedApiProtocolRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Make sure to follow the following pattern: self greaseDeprecatedApi: ''Class>>#selector'' details: ''Some description''.'! !!GREmptyStatementsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	| periods position |	aContext parseTree nodesDo: [ :node |		(node isSequence and: [ node periods notEmpty ]) ifTrue: [			periods := OrderedCollection withAll: node periods.			1 to: node statements size - 1 do: [ :index |				position := periods removeFirst.				((node statements at: index) stop < position and: [ position < (node statements at: index + 1) start ])					ifFalse: [ ^ result addClass: aContext methodClass selector: aContext selector ] ].			(periods isEmpty or: [ periods size = 1 and: [ node statements notEmpty and: [ node statements last stop < periods first ] ] ])				ifFalse: [ ^ result addClass: aContext methodClass selector: aContext selector ] ] ]! !!GREmptyStatementsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GREmptyStatementsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Empty Statements'! !!GREmptyStatementsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Empty statements are not supported by most Smalltalk implementations.'! !!GREmptyStatementsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!resetResult	super resetResult.	result addSearchString: '..'; addSearchString: '.'! !!GRInvalidObjectInitializationRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	(aContext methodClass isMeta not 		and: [ (aContext selector beginsWithSubCollection: #initialize) 		and: [ aContext selector numArgs > 0		and: [ aContext methodClass ~= GRObject		and: [ (aContext methodClass includesBehavior: GRObject)		and: [ (aContext superMessages includes: aContext selector) not 		and: [ aContext selfMessages noneSatisfy: [ :each | each beginsWithSubCollection: #initialize ] ] ] ] ] ] ]) 			ifTrue: [ result addClass: aContext methodClass selector: aContext selector ]! !!GRInvalidObjectInitializationRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRInvalidObjectInitializationRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Invalid object initialization'! !!GRInvalidObjectInitializationRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Initialize methods are required to call the designated initializer or its super implementation.'! !!GRNonPortableMessageRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext	| selectors |	selectors := self methodNames		inject: Set new		into: [ :set :each | 			set				addAll: (aContext whichSelectorsReferTo: each);				yourself ].	selectors do: [ :each | result addClass: aContext selector: each ].	selectors isEmpty		ifFalse: [ result searchStrings: self methodNames ]! !!GRNonPortableMessageRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRNonPortableMessageRule methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!methodNames	^ #( anyOne withIndexCollect: )! !!GRNonPortableMessageRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses non portable message'! !!GRNonPortableMessageRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Some methods are not portable accross different Smalltalk dialects.'! !!GRNonPortableSourceFormatRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext 	| comment |	aContext isMeta 		ifTrue: [ ^ self ].	comment := aContext organization classComment asString.	comment isWideString ifTrue: [		result addClass: aContext ]! !!GRNonPortableSourceFormatRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	| foundLiteral |	foundLiteral := false.	"check individual literals first"	aContext literals do: [ :each | 		(each isString and: [ each isWideString ]) ifTrue: [			result 				addClass: aContext methodClass				selector: aContext selector.			result addSearchString:  each.			foundLiteral := true ] ].		"now check the whole method, could be in comments"	foundLiteral ifFalse: [		aContext sourceCode asString isWideString ifTrue: [			result addClass: aContext methodClass selector: aContext selector ] ]! !!GRNonPortableSourceFormatRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRNonPortableSourceFormatRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Non portable source format'! !!GRNonPortableSourceFormatRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'The method source is required to be a plain string, for portability reasons a wide-string is not supported.'! !!GRSlimeBlockLintRule class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isVisible	^ self name ~= #GRSlimeBlockLintRule! !!GRSlimeBlockLintRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!category	^ self group! !!GRUnnecessaryLastPeriodRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	aContext parseTree nodesDo: [ :node |		node isSequence ifTrue: [			(node statements notEmpty and: [ node periods notEmpty ]) ifTrue: [				node periods last > node statements last stop ifTrue: [					^ result addClass: aContext methodClass selector: aContext selector ] ] ] ]! !!GRUnnecessaryLastPeriodRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRUnnecessaryLastPeriodRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Unnecessary Last Period'! !!GRUnnecessaryLastPeriodRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Periods are not needed after the last satement.'! !!GRUnnecessaryLastPeriodRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!resetResult	super resetResult.	result addSearchString: '..'; addSearchString: '.'! !!GRUsesMethodAnnotationsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	(self shouldExclude: aContext) ifFalse: [		aContext pragmas do: [ :each |			result 				addClass: aContext methodClass				selector: aContext selector.			result addSearchString: each keyword ] ]! !!GRUsesMethodAnnotationsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesMethodAnnotationsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses method annotations'! !!GRUsesMethodAnnotationsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'As of now, it is unclear if method-annotations/pragmas are compatible across all supported platforms. Likely this rule will soon be removed.'! !!GRUsesMethodAnnotationsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!shouldExclude: aContext	"The REST and OmniBrowser related packages are OK to have pragmas"	| classCategory |	classCategory := aContext methodClass theNonMetaClass category.	^ #(#'-REST-' 'OmniBrowser') anySatisfy: [ :each |		 (classCategory indexOfSubCollection: each startingAt: 1) ~= 0 ]! !!GRUsesNotPortableClassRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext 	aContext allSuperclassesDo: [ :each |		(self classNames includes: each name) ifTrue: [			result addClass: aContext.			result addSearchString: each name ] ]! !!GRUsesNotPortableClassRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	(aContext methodClass theNonMetaClass category indexOfSubCollection: #'-Pharo-' startingAt: 1) ~= 0 ifTrue: [		"classes in a -Pharo- package are per definition not portable and therefore allowed to use non-portable classes"		^ self ].	aContext literals do: [ :each | 		(each isVariableBinding and: [ self classNames includes: each key ]) ifTrue: [			result 				addClass: aContext methodClass				selector: aContext selector.			result addSearchString: each key ] ]! !!GRUsesNotPortableClassRule methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!classNames	^ #( Delay MIMEDocument Monitor Mutex MutexSet Random Semaphore TimeStamp Timestamp MessageSend )! !!GRUsesNotPortableClassRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesNotPortableClassRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses not portable class'! !!GRUsesNotPortableClassRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Some classes are not portable accross different Smalltalk dialects.'! !!GRPackage class methodsFor: '*Grease-Pharo40-Slime' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseSlime	^ self new		name: 'Grease-Pharo40-Slime';		description: 'Code critis for Grease. Detects common types of bugs and non-portable code.';		addDependency: 'Grease-Core';		url: #seasideUrl;		yourself! !!GRBlockFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRBlockFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '[ :`@args | | `@temps | ``@.stmts ]'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [					| source |					source := node source.					(source notNil and: [ node left notNil and: [ node right notNil ] ]) ifTrue: [						| before after |						before := source at: node left + 1 ifAbsent: [ $ ].						after := source at: node right - 1 ifAbsent: [ $ ].						(before isSeparator and: [ after isSeparator ])							ifFalse: [ node ]							ifTrue: [								node bar notNil ifTrue: [ 									before := source at: node bar - 1 ifAbsent: [ $ ].									after := source at: node bar + 1 ifAbsent: [ $ ].									(before isSeparator and: [ after isSeparator ])										ifFalse: [ node ] ] ] ] ] ]! !!GRBlockFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Block formatting'! !!GRBlockFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should spaces at the beginning and end of block.'! !!GRParensFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRParensFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '`{ :node | node isValue and: [ node hasParentheses ] }'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [					| found start stop |					found := false.					start := node startWithoutParentheses.					stop := node stopWithoutParentheses.					node parentheses reverseDo: [ :interval |						found := found							or: [ start - 1 ~= interval first							or: [ stop + 1 ~= interval last ] ].						start := interval first.						stop := interval last ].					found ifTrue: [ node ] ] ]! !!GRParensFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Parentheses formatting'! !!GRParensFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should be no spaces inside parentheses.'! !!GRReturnFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRReturnFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '^ ``@expr'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [ 					node start + 2 ~= node value start						ifTrue: [ node ] ] ]! !!GRReturnFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Return formatting'! !!GRReturnFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should be a single space between the ^ and the following expression.'! !!GRSlimeParseTreeLintRule class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isVisible	^ self name ~= #GRSlimeParseTreeLintRule! !!GRSlimeParseTreeLintRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!category	^ self group! !!GRTempsFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRTempsFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '| `temp `@temps | ``@.stmts'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [ 					(node leftBar notNil and: [ node rightBar notNil ]) ifTrue: [						| found position |						found := false.						position := node leftBar.						node temporaries do: [ :each | 							found := found or: [ position + 2 ~= each start ].							position := each stop ].						found := found or: [ position + 2 ~= node rightBar ].						found ifTrue: [ node ] ] ] ]! !!GRTempsFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Temporaries formatting'! !!GRTempsFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should be a single space between the | and the individual temps.'! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matchesAnyOf: #(			'`@receiver canPerform: `@selector'			'`@receiver canUnderstand: `@selector' )		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Sends #canPerform: or #canUnderstand:'! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#canPerform: or #canUnderstand: are not portable.'! !!GRUsesClassForHashRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	aContext parseTree selector = #hash		ifTrue: [ super checkMethod: aContext ]! !!GRUsesClassForHashRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesClassForHashRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '`@receiver class hash'		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesClassForHashRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses its class for hash'! !!GRUsesClassForHashRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'The hash of an object should not depend on the hash of its class as some Smalltalk have non-constant class hashes.'! !!GRUsesCurlyBraceArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesCurlyBraceArraysRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '{ `@.stmts }'		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesCurlyBraceArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses curly brace arrays'! !!GRUsesCurlyBraceArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Curly brace expressions are not portable accross different Smalltalk dialects.'! !!GRUsesLiteralByteArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesLiteralByteArraysRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '`#literal `{ :node | node isLiteralArray and: [ node isForByteArray ] }'		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesLiteralByteArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses literal byte arrays'! !!GRUsesLiteralByteArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Literal byte arrays are not portable accross different Smalltalk dialects.'! !!GRAnsiBooleansRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiBooleansRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@expr1 and: [ | `@temp2 | ``@expr2 ] and: [ | `@temp3 | ``@expr3 ]'			with: '``@expr1 and: [ | `@temp2 | ``@expr2 and: [ | `@temp3 | ``@expr3 ] ]';		replace: '``@expr1 and: [ | `@temp2 | ``@expr2 ] and: [ | `@temp3 | ``@expr3 ] and: [ | `@temp4 | ``@expr4 ]'			with: '``@expr1 and: [ | `@temp2 | ``@expr2 and: [ | `@temp3 | ``@expr3 and: [ | `@temp4 | ``@expr4 ] ] ]';		replace: '``@expr1 and: [ | `@temp2 | ``@expr2 ] and: [ | `@temp3 | ``@expr3 ] and: [ | `@temp4 | ``@expr4 ] and: [  | `@temp5 | ``@expr5 ]'			with: '``@expr1 and: [ | `@temp2 | ``@expr2 and: [ | `@temp3 | ``@expr3 and: [ | `@temp4 | ``@expr4 and: [ | `@temp5 | ``@expr5 ] ] ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ] or: [ | `@temp4 | ``@expr4 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 or: [ | `@temp4 | ``@expr4 ] ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ] or: [ | `@temp4 | ``@expr4 ] or: [ | `@temp5 | ``@expr5 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 or: [ | `@temp4 | ``@expr4 or: [ | `@temp5 | ``@expr5 ] ] ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ] or: [ | `@temp4 | ``@expr4 ] or: [ | `@temp5 | ``@expr5 ] or: [ | `@temp6 | ``@expr6 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 or: [ | `@temp4 | ``@expr4 or: [ | `@temp5 | ``@expr5 or: [ | `@temp6 | ``@expr6 ] ] ] ] ]'! !!GRAnsiBooleansRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Booleans'! !!GRAnsiBooleansRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#and:and: and #or:or: are not ANSI compatible.'! !!GRAnsiCharactersRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiCharactersRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: 'Character value: ``@expr' with: 'Character codePoint: ``@expr';		replace: '`#source to: `#target' 			withValueFrom: [ :node |				RBLiteralNode value: (String streamContents: [ :stream |					node receiver value codePoint to: node arguments first value codePoint do: [ :code |						stream nextPut: (Character codePoint: code) ] ]) ]			when: [ :node | 				node receiver value isCharacter					and: [ node arguments first value isCharacter ] ] ! !!GRAnsiCharactersRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Characters'! !!GRAnsiCharactersRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Character value: 64 and $a to: $b is not ANSI compatible.'! !!GRAnsiCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiCollectionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@collection withIndexDo: [ :`each :`index |  | `@temps | ``@.body ]'			with: '``@collection keysAndValuesDo: [ :`index :`each |  | `@temps | ``@.body ]';		replace: '``@collection doWithIndex: [ :`each :`index |  | `@temps | ``@.body ]'			with: '``@collection keysAndValuesDo: [ :`index :`each |  | `@temps | ``@.body ]';		replace: '``@collection collect: ``@block1 thenDo: ``@block2'			with: '(``@collection collect: ``@block1) do: ``@block2';		replace: '``@collection collect: ``@block1 thenSelect: ``@block2'			with: '(``@collection collect: ``@block1) select: ``@block2';		replace: '``@collection pairsDo: [ :`t1 :`t2 | ``@.statements ]'			with: '1 to: ``@collection size by: 2 do:  [ :index | | `t1 `t2 | `t1 := ``@collection at: index. `t2 := ``@collection at: index + 1. ``@.statements ]';		replace: '``@collection reject: ``@block1 thenDo: ``@block2'			with: '(``@collection reject: ``@block1) do: ``@block2';		replace: '``@collection select: ``@block1 thenCollect: ``@block2'			with: '(``@collection select: ``@block1) collect: ``@block2';		replace: '``@collection select: ``@block1 thenDo: ``@block2'			with: '(``@collection select: ``@block1) do: ``@block2';		replace: '``@collection detectSum: [ :`t1 | ``@.statements. `.last ]'			with: '``@collection inject: 0 into: [ :sum :`t1 | ``@.statements. sum + (`.last) ]';		replace: '``@collection valuesDo: ``@block'			with: '``@collection do: ``@block';		replace: '``@collection reversed'			with: '``@collection reverse';			replace: '``@dictionary keysSortedSafely'			with: '``@dictionary keys asSortedCollection';		replace: '``@collectionClass new: ``@size withAll: ``@character'			with: '(``@collectionClass new: ``@size) atAllPut: ``@character'! !!GRAnsiCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Collections'! !!GRAnsiCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Some collection methods are not ANSI compatible: #pairsDo:, #collect:thenDo:, #reject:thenDo:, #detectSum:, #valuesDo:, #keysSortedSafely, #new:withAll:, etc.'! !!GRAnsiConditionalsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiConditionalsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@boolean ifNotNilDo: ``@block'			with: '``@boolean ifNotNil: ``@block';		replace: '``@boolean ifNotNilDo: ``@block1 ifNil: ``@block2'			with: '``@boolean ifNotNil: ``@block1 ifNil: ``@block2';		replace: '``@boolean ifNil: ``@block1 ifNotNilDo: ``@block2'			with: '``@boolean ifNil: ``@block1 ifNotNil: ``@block2';		replace: '``@boolean ifNotNil: [ | `@temps | ``@.body ]'			with: '``@boolean ifNotNil: [ :arg | | `@temps | ``@.body ]';		replace: '``@boolean ifNotNil: [ | `@temps | ``@.body ] ifNil: ``@block '			with: '``@boolean ifNotNil: [ :arg | | `@temps | ``@.body ] ifNil: ``@block';		replace: '``@boolean ifNil: ``@block ifNotNil: [ | `@temps | ``@.body ]'			with: '``@boolean ifNil: ``@block ifNotNil: [ :arg | | `@temps | ``@.body ]'! !!GRAnsiConditionalsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Conditionals'! !!GRAnsiConditionalsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Conditionals like #ifNotNilDo: are not ANSI compatible.'! !!GRAnsiConvertorRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiConvertorRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@object asString' with: '``@object greaseString';		replace: '``@object asInteger' with: '``@object greaseInteger'! !!GRAnsiConvertorRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Convertors'! !!GRAnsiConvertorRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'The ANSI standard does not support #asInteger and #asString on Object.'! !!GRAnsiExceptionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiExceptionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@block on: `class do: [ | `@temps | ``@.body ]'			with: '``@block on: `class do: [ :err | | `@temps | ``@.body ]'! !!GRAnsiExceptionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Exceptions'! !!GRAnsiExceptionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Exception handlers expect exactly one argument in ANSI.'! !!GRAnsiStreamsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiStreamsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '`{ :node :context | node isVariable and: [ (Smalltalk includesKey: node name asSymbol) not and: [ context at: ''`receiver'' ifAbsentPut: [ node ]. true ] ] } cr'			with: '`{ :context | context at: ''`receiver'' } nextPut: Character cr';		replace: '`{ :node :context | node isVariable and: [ (Smalltalk includesKey: node name asSymbol) not and: [ context at: ''`receiver'' ifAbsentPut: [ node ]. true ] ] } lf'			with: '`{ :context | context at: ''`receiver'' } nextPut: Character lf';		replace: '``@stream nextPut: Character cr; nextPut: Character lf'			with: '``@stream crlf';		replace: '``@collection writeStream'			with: 'WriteStream on: ``@collection'! !!GRAnsiStreamsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Streams'! !!GRAnsiStreamsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#cr and #lf are not part of the ANSI stream protocol.'! !!GRAnsiStringsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiStringsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: 'String tab' with: '(String with: Character tab)';		replace: 'String cr' with: '(String with: Character cr)';		replace: 'String lf' with: '(String with: Character lf)';		replace: 'String crlf' with: '(String with: Character cr with: Character lf)';		replace: 'String space' with: '(String with: Character space)';		replace: '`@string includesSubString: `@subString'			with: '(`@string indexOfSubCollection: `@subString startingAt: 0) ~= 0';		replace: '`@string includesSubstring: `@subString'			with: '(`@string indexOfSubCollection: `@subString startingAt: 0) ~= 0';		replace: '``@string findTokens: ``@arg' withValueFrom: [ :node |			| argument |			argument := node arguments first.			argument isLiteralNode ifTrue: [ 				argument value isArray					ifTrue: [ argument replaceWith: (RBLiteralNode value: (String withAll: argument value)) ].				argument value isCharacter					ifTrue: [ argument replaceWith: (RBLiteralNode value: (String with: argument value)) ] ].			node				selector: #subStrings:;				yourself ]! !!GRAnsiStringsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Strings'! !!GRAnsiStringsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#cr, #crlf, #lf, #space, #tab, #findTokens:, ... are not part of the ANSI string protocol.'! !!GRNotPortableCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRNotPortableCollectionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '`@collection beginsWith: `@subCollection'			with: '`@collection beginsWithSubCollection: `@subCollection';		replace: '`@collection endsWith: `@subCollection'			with: '`@collection endsWithSubCollection: `@subCollection'! !!GRNotPortableCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Collections'! !!GRNotPortableCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#beginsWith: and #endsWith: are not portable.'! !!GRObjectInRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRObjectInRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@object in: [ :`var | | `@temps | `@.statements ]'		with: '[ :`var | | `@temps | `@.statements ] value: ``@object'! !!GRObjectInRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Object>>#in:'! !!GRObjectInRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Object>>#in: has different semantics on different Smalltalk dialects.'! !!GRSlimeTransformationRule class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isVisible	^ self name ~= #GRSlimeTransformationRule! !!GRTestAssertionsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	aContext methodClass isMeta		ifTrue: [ ^ self ].	(aContext methodClass allSuperclasses includes:(Smalltalk at: #TestCase))		ifFalse: [ ^ self ].	^ super checkMethod: aContext ! !!GRTestAssertionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'SUnit Compatibility'! !!GRTestAssertionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: 'self fail'			with: 'self assert: false'! !!GRTestAssertionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'TestCase >> #fail'! !!GRTestAssertionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'TestCase >> #fail is not portable.'! !"Grease-Pharo40-Slime"!!MAAdaptiveModel commentStamp: 'lr 6/2/2006 00:30' prior: 0!I am an adaptive model referencing a dynamic description of myself and a dictionary mapping those descriptions to actual values.!!MAFileModel commentStamp: 'lr 9/28/2007 08:04' prior: 0!I represent a file with filename, mimetype and contents within the Magritte framework.There are different file-models that you can use with Magritte. The idea is that you set the ==#kind:== of an MAFileDescription to one of the subclasses of ==*MAFileModel*==.!!MAMemoryFileModel commentStamp: 'lr 9/28/2007 08:06' prior: 0!I represent a file using a ByteArray in the object memory. I am not practicable for big files: use me for development and testing only.!!MAObject commentStamp: 'lr 5/17/2006 14:07' prior: 0!I provide functionality available to all Magritte objects. I implement a dictionary of properties, so that extensions can easily store additional data.!!MAAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am the abstract superclass to all accessor strategies. Accessors are used to implement different ways of accessing (reading and writing) data from instances using a common protocol: data can be uniformly read and written using ==#readFrom:== respectively ==#write:to:==.!!MADelegatorAccessor commentStamp: 'lr 2/14/2008 09:56' prior: 0!My access strategy is to delegate to the next accessor. I am not that useful all by myself, but subclasses might override certain methods to intercept access.!!MAChainAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am an access strategy used to chain two access strategies. To read and write a value the ==accessor== is performed on the given model and the result is passed into the ==next== accessor.!!MADictionaryAccessor commentStamp: '<historical>' prior: 0!I am an access strategy to be used on dictionaries. I use my ==key== to read from and write to indexed collections. I am mainly used for prototyping as it allows one to treat dictionaries like objects with object-based instance variables.!!MAIdentityAccessor commentStamp: 'lr 2/12/2006 20:09' prior: 0!I am a read-only access strategy and I answer the model itself when being read.!!MANullAccessor commentStamp: 'lr 5/29/2006 09:21' prior: 0!I am a null access strategy and I should be neither read nor written. I am still comparable to other strategies by holding onto a unique-identifier.!!MAPluggableAccessor commentStamp: 'lr 2/12/2006 20:04' prior: 0!I am an access strategy defined by two block-closures. The read-block expects the model as its first argument and is used to retrieve a value. The write-block expects the model as its first and the value as its second argument and is used to write a value to the model.!!MASelectorAccessor commentStamp: 'lr 6/2/2006 10:03' prior: 0!I am the most common access strategy defined by a read- and a write-selector. I am mostly used together with standard getters and setters as usually defined by the accessing protocol. If there is only a read-selector specified, the write selector will be deduced automatically by adding a colon to the read-selector.!!MAVariableAccessor commentStamp: 'lr 5/27/2006 17:20' prior: 0!I am an access strategy that directly reads from and writes to instance variables. I strongly violate encapsulation and most of the time I should be replaced by an instance of *MASelectorAccessor*.!!MADescription commentStamp: 'lr 2/5/2009 12:42' prior: 0!I am the root of the description hierarchy in Magritte and I provide most of the basic properties available to all descriptions. If you would like to annotate your model with a description have a look at the different subclasses of myself.!!ExampleIf your model has an instance variable called ==title== that should be used to store the title of the object, you could add the following description to your class:=Document class>>descriptionTitle=	^ MAStringDescription new=		autoAccessor: #title;=		label: 'Title';=		priority: 20;=		beRequired;=		yourself.The selector ==#title== is the name of the accessor method used by Magritte to retrieve the value from the model. In the above case Magritte creates the accessor method and the instance variable automatically, if necessary. The label is used to give the field a name and will be printed next to the input box if a visual GUI is created from this description.The write-accessor is automatically deduced by adding a colon to the read-selector, in this example ==#title:==. You can specify your own accessor strategy using one of the subclasses of ==*MAAccessor*==. If you have multiple description within the same object, the ==#priority:== field is used to order them. Assign a low priority to have descriptions traversed first.!!MAContainer commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a container holding a collection of descriptions, all instances of subclasses of *MAElementDescription*. I keep my children within an ==OrderedCollection==, but I don't sort them according to their priority.I fully support the collection protocol: descriptions can be added and removed. Moreover I implement most enumeration methods, so that users are able to iterate (==do:==), filter (==select:==, ==reject:==), transform (==collect:==), extract (==detect:==, ==detect:ifNone:==), and test (==allSatisfy:==, ==anySatisfy:==, ==noneSatisfy:==) my elements.!!MAPriorityContainer commentStamp: 'lr 2/12/2006 19:34' prior: 0!I am a container holding a collection of descriptions and I keep them sorted according to their priority.!!MAElementDescription commentStamp: '<historical>' prior: 0!I am an abstract description for all basic description types.!!MABooleanDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of the Boolean values ==true== and ==false==. My visual representation could be a check-box.!!MAClassDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of Smalltalk classes, possible values can be any of ==Smalltalk allClasses==.!!MAColorDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of colors, possible values are instances of ==Color==. My visual representation could be a color-chooser.!!MAFileDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of files, their contents, filename and mime-type. Possible values include instances of *MAFileModel*. My visual representation could be a file-upload dialog.!!MAMagnitudeDescription commentStamp: 'lr 4/10/2007 21:08' prior: 0!I am an abstract description for subclasses of ==Magnitude==. The range of accepted values can be limited using the accessors ==min:== and ==max:==.!!MADateAndTimeDescription commentStamp: 'pmm 8/31/2009 20:11' prior: 0!I am a description of date and times, possible values are instances of ==DateAndTime==. My visual representation could be a date- and time-picker.!!MADateDescription commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a description of dates, possible values are instances of ==Date==. My visual representation could be a date-picker.!!MADurationDescription commentStamp: 'lr 4/10/2007 21:07' prior: 0!I am a description of durations, possible values are instances of ==Duration==.!!MANumberDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of numbers, possible values are instances of ==Number== and all its subclasses, including ==Integer== and ==Float==. My visual representation could be a number input-box or even a slider-control.!!MATimeDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of times, possible values are instances of ==Time==. My visual representation could be a time-picker.!!MATimeStampDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of timestamps, possible values are instances of ==TimeStamp==. My visual representation could be a date- and time-picker.!!MAReferenceDescription commentStamp: 'lr 2/12/2006 19:38' prior: 0!I am an abstract superclass for descriptions holding onto another description.!!MAOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am an abstract description of different options the user can choose from. My instance variable ==options== references the options I am representing. The options can be sorted or unsorted.!!MAMultipleOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiple options, possible options are stored within the ==options== field, possible values are instances of ==Collection==. My visual representation could be a multi-select list or a group of check-boxes.!!MASingleOptionDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of a single option, possible values are stored within the ==options== field, but I might also be extensible so that the user can add its own option. My visual representation could be a drop-down list or a group of option-buttons.!!MARelationDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am an abstract description for descriptions representing a relation. My instance variable ==classes== references a collection of possible classes that I can relate to. If required the reference description will be automatically built from this list of classes.!!MAToManyRelationDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of an one-to-many relationship, possible values are instances of ==Collection==.!!MAToManyScalarRelationDescription commentStamp: 'pmm 11/3/2006 17:48' prior: 0!Like MAToManyRelationDescription but for scalar values.!!MAToOneRelationDescription commentStamp: '<historical>' prior: 0!I am a description of an one-to-one relationship.!!MATableDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of tables, their cells and labels. I hold a reference to the description of my cells, that are all described using the same description. Possible values include instances of *MATableModel*.!!MATokenDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of tokens all described by the referenced description, possible values are instances of ==SequenceableCollection==.!!MAStringDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of strings, possible values are instances of ==String==. My visual representation could be a single line text-field. Use ==*MAMemoDescription*== for multi-line strings.!!MAMemoDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiline strings, possible values are instances of ==String==. My visual representation could be a text-area field.!!MAPasswordDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of a password string, possible values are instances of ==String==. My visual representation could be a password field, where there are stars printed instead of the characters the user enters.!!MASymbolDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of symbols, possible values are instances of ==Symbol==.!!MAMemento commentStamp: 'SeanDeNigris 4/10/2015 20:07' prior: 0!I am an abstract memento. I reference the model I am working on and the description currently used to describe this model.!!MACachedMemento commentStamp: 'lr 5/29/2006 09:22' prior: 0!I cache values being read and written without touching the model. When committing changes, the modifications will be propagated to the model all at once.!!MACheckedMemento commentStamp: 'lr 5/17/2006 15:12' prior: 0!I cache values as my superclass and also remember the original values of the model at the time the cache is built. With this information I am able to detect edit conflicts and can prevent accidental loss of data by merging the changes.!!MAStraightMemento commentStamp: 'lr 5/17/2006 15:02' prior: 0!I am a memento that forwards read- and write-access directly to the model. I can mostly be replaced with the model itself.!!MAPragmaBuilder commentStamp: 'NickAger 3/7/2012 09:30' prior: 0!I dynamically build container descriptions from instance-side methods decorated pragmas. The pragmas used are:# ==#magritteContainer== to identify the method generating the container instance.# ==#magritteDescription== for unary methods returning valid Magritte descriptions which are added to the container.# ==#magritteDescription:== for single parameter methods returning Magritte description extensions, where the pragma parameter defines the related Magritte description method. The extension method will be called after the related method to refine the description definition.!!MATableModel commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a model class representing a table within the Magritte framework. Internally I store my cells within a flat array, however users may access data giving ''row'' and ''column'' coordinates with ==#at:at:== and ==#at:at:put:==. I can support reshaping myself, but of course this might lead to loss of data-cells.!!MAVisitor commentStamp: 'SeanDeNigris 4/10/2015 20:06' prior: 0!I am a visitor responsible for visiting Magritte descriptions. I am an abstract class providing a default implementation for concrete visitors. The protocol I implement reflects the hierarchy of *MADescription* and its subclasses. Visiting a class which my subclasses don't implement specifically automatically defaults to a less-specific implementation. The code was automatically created using code on my class-side.!!MADescriptionBuilder commentStamp: 'DiegoLont 4/2/2017 22:46' prior: 0!A MADescriptionBuilder is an abstract class for enriching a Magritte description, e.g. setting the component class based on the description class.Instance Variables:	model: the root object	target:  the object the current description belongs to	priority: when multiple builders are used, this determines the priority.	buildedDescription: The result!!MADescriptionFlattener commentStamp: 'DiegoLont 4/2/2017 22:45' prior: 0!MADescriptionFlattener  builds from a description with references to single objects a description, that is more flat. This allows us to render these descriptions, without "cluttered" labels. I.E. a nested description (MAInternalEditor) would render two labels: one for the "main" object and one for the "fields" in that object. Replacing a MAInternalEditor would not help, since this would not replace the label in front of this editor.This description is used in a QCMultipartComponent and this is extracted since, visiting gives us more elegant code for this "complex" behaviour.!!MAStringReader commentStamp: 'SeanDeNigris 4/13/2015 07:57' prior: 0!I recreate Magritte-described domain objects from strings. Typically I am used to convert string values entered into a Magritte form back to the objects they represent. For example, a user may have typed '10/01/2020' into a date field.!!ManifestMagritteModel commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!MADynamicDescriptionCache commentStamp: 'SeanDeNigris 2/19/2018 22:55' prior: 0!I am a dynamic variable that caches descriptions defined in the current call stack. I prevent infinite recursion when a description refers to itself.!!MAError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I represent a generic Magritte error.!!MAReadError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem reading serialized data.!!MAValidationError commentStamp: 'lr 5/17/2006 15:15' prior: 0!I am a generic validation error. I reference the description that caused the validation error.!!MAConditionError commentStamp: 'lr 5/30/2006 23:33' prior: 0!I am an error that is raised whenever a user-defined condition is failing.!!MAConflictError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever there is an edit conflict.!!MAKindError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever a description is applied to the wrong type of data.!!MAMultipleErrors commentStamp: 'lr 5/17/2006 15:18' prior: 0!I am an error that is raised whenever there are multiple validation rules failing.!!MARangeError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a described value is out of bounds.!!MARequiredError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a required value is not supplied.!!MAWriteError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem writing serialized data.!!MAAdaptiveModel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!description: aDescription	^ self new		magritteDescription: aDescription;		yourself! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDescription	^ MAContainer new! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDictionary	^ Dictionary new! !!MAAdaptiveModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	super initialize.	self magritteDescription: self defaultDescription.	self values: self defaultDictionary! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescription	"Answer the description of the receiver."	^ magritteDescription! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescription: aDescription	magritteDescription := aDescription! !!MAAdaptiveModel methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readUsing: aDescription	"Answer the actual value of ==aDescription== within the receiver, ==nil== if not present."	^ self values at: aDescription ifAbsent: [ nil ]! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!values	"Answer a dictionary mapping description to actual values."	^ values! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!values: aDictionary	values := aDictionary! !!MAAdaptiveModel methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject using: aDescription	"Set ==anObject== to be that actual value of the receiver for ==aDescription==."	self values at: aDescription put: anObject! !!MABasicObject class methodsFor: 'error handling' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultErrorClass	^ MAError! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMimeType	^ 'application/octet-stream'! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMimeTypes	^ #( '323' 'text/h323' 'acx' 'application/internet-property-stream' 'ai' 'application/postscript' 'aif' 'audio/x-aiff' 'aifc' 'audio/x-aiff' 'aiff' 'audio/x-aiff' 'asc' 'text/plain' 'asf' 'video/x-ms-asf' 'asr' 'video/x-ms-asf' 'asx' 'video/x-ms-asf' 'au' 'audio/basic' 'avi' 'video/x-msvideo' 'axs' 'application/olescript' 'bas' 'text/plain' 'bcpio' 'application/x-bcpio' 'bin' 'application/octet-stream' 'bmp' 'image/bmp' 'c' 'text/plain' 'cat' 'application/vnd.ms-pkiseccat' 'cc' 'text/plain' 'ccad' 'application/clariscad' 'cdf' 'application/x-netcdf' 'cer' 'application/x-x509-ca-cert' 'class' 'application/octet-stream' 'clp' 'application/x-msclip' 'cmx' 'image/x-cmx' 'cod' 'image/cis-cod' 'cpio' 'application/x-cpio' 'cpt' 'application/mac-compactpro' 'crd' 'application/x-mscardfile' 'crl' 'application/pkix-crl' 'crt' 'application/x-x509-ca-cert' 'csh' 'application/x-csh' 'css' 'text/css' 'dcr' 'application/x-director' 'der' 'application/x-x509-ca-cert' 'dir' 'application/x-director' 'dll' 'application/x-msdownload' 'dms' 'application/octet-stream' 'doc' 'application/msword' 'dot' 'application/msword' 'drw' 'application/drafting' 'dtd' 'application/xml-dtd' 'dvi' 'application/x-dvi' 'dwg' 'application/acad' 'dxf' 'application/dxf' 'dxr' 'application/x-director' 'eps' 'application/postscript' 'etx' 'text/x-setext' 'evy' 'application/envoy' 'exe' 'application/octet-stream' 'ez' 'application/andrew-inset' 'f' 'text/plain' 'f90' 'text/plain' 'fif' 'application/fractals' 'fli' 'video/x-fli' 'flr' 'x-world/x-vrml' 'gif' 'image/gif' 'gtar' 'application/x-gtar' 'gz' 'application/x-gzip' 'h' 'text/plain' 'hdf' 'application/x-hdf' 'hh' 'text/plain' 'hlp' 'application/winhlp' 'hqx' 'application/mac-binhex40' 'hta' 'application/hta' 'htc' 'text/x-component' 'htm' 'text/html' 'html' 'text/html' 'htt' 'text/webviewhtml' 'ice' 'x-conference/x-cooltalk' 'ico' 'image/vnd.microsoft.icon' 'ief' 'image/ief' 'iges' 'model/iges' 'igs' 'model/iges' 'iii' 'application/x-iphone' 'ins' 'application/x-internet-signup' 'ips' 'application/x-ipscript' 'ipx' 'application/x-ipix' 'isp' 'application/x-internet-signup' 'jfif' 'image/pipeg' 'jpe' 'image/jpeg' 'jpeg' 'image/jpeg' 'jpg' 'image/jpeg' 'js' 'application/javascript' 'json' 'application/json' 'kar' 'audio/midi' 'latex' 'application/x-latex' 'lha' 'application/octet-stream' 'lsf' 'video/x-la-asf' 'lsp' 'application/x-lisp' 'lsx' 'video/x-la-asf' 'lzh' 'application/octet-stream' 'm' 'text/plain' 'm13' 'application/x-msmediaview' 'm14' 'application/x-msmediaview' 'm3u' 'audio/x-mpegurl' 'man' 'application/x-troff-man' 'mdb' 'application/x-msaccess' 'me' 'application/x-troff-me' 'mesh' 'model/mesh' 'mht' 'message/rfc822' 'mhtml' 'message/rfc822' 'mid' 'audio/midi' 'midi' 'audio/midi' 'mif' 'application/vnd.mif' 'mime' 'www/mime' 'mny' 'application/x-msmoney' 'mov' 'video/quicktime' 'movie' 'video/x-sgi-movie' 'mp2' 'audio/mpeg' 'mp3' 'audio/mpeg' 'mpa' 'video/mpeg' 'mpe' 'video/mpeg' 'mpeg' 'video/mpeg' 'mpg' 'video/mpeg' 'mpga' 'audio/mpeg' 'mpp' 'application/vnd.ms-project' 'mpv2' 'video/mpeg' 'ms' 'application/x-troff-ms' 'msh' 'model/mesh' 'mvb' 'application/x-msmediaview' 'nc' 'application/x-netcdf' 'nws' 'message/rfc822' 'oda' 'application/oda' 'ogg' 'application/ogg' 'p10' 'application/pkcs10' 'p12' 'application/x-pkcs12' 'p7b' 'application/x-pkcs7-certificates' 'p7c' 'application/x-pkcs7-mime' 'p7m' 'application/x-pkcs7-mime' 'p7r' 'application/x-pkcs7-certreqresp' 'p7s' 'application/x-pkcs7-signature' 'pbm' 'image/x-portable-bitmap' 'pdb' 'chemical/x-pdb' 'pdf' 'application/pdf' 'pfx' 'application/x-pkcs12' 'pgm' 'image/x-portable-graymap' 'pgn' 'application/x-chess-pgn' 'pko' 'application/ynd.ms-pkipko' 'pma' 'application/x-perfmon' 'pmc' 'application/x-perfmon' 'pml' 'application/x-perfmon' 'pmr' 'application/x-perfmon' 'pmw' 'application/x-perfmon' 'png' 'image/png' 'pnm' 'image/x-portable-anymap' 'pot' 'application/mspowerpoint' 'ppm' 'image/x-portable-pixmap' 'pps' 'application/mspowerpoint' 'ppt' 'application/mspowerpoint' 'ppz' 'application/mspowerpoint' 'pre' 'application/x-freelance' 'prf' 'application/pics-rules' 'prt' 'application/pro_eng' 'ps' 'application/postscript' 'pub' 'application/x-mspublisher' 'qt' 'video/quicktime' 'ra' 'audio/x-realaudio' 'ram' 'audio/x-pn-realaudio' 'ras' 'image/cmu-raster' 'rgb' 'image/x-rgb' 'rm' 'audio/x-pn-realaudio' 'rmi' 'audio/mid' 'roff' 'application/x-troff' 'rpm' 'audio/x-pn-realaudio-plugin' 'rtf' 'application/rtf' 'rtx' 'text/richtext' 'scd' 'application/x-msschedule' 'scm' 'application/x-lotusscreencam' 'sct' 'text/scriptlet' 'set' 'application/set' 'setpay' 'application/set-payment-initiation' 'setreg' 'application/set-registration-initiation' 'sgm' 'text/sgml' 'sgml' 'text/sgml' 'sh' 'application/x-sh' 'shar' 'application/x-shar' 'silo' 'model/mesh' 'sit' 'application/x-stuffit' 'skd' 'application/x-koan' 'skm' 'application/x-koan' 'skp' 'application/x-koan' 'skt' 'application/x-koan' 'smi' 'application/smil' 'smil' 'application/smil' 'snd' 'audio/basic' 'sol' 'application/solids' 'spc' 'application/x-pkcs7-certificates' 'spl' 'application/futuresplash' 'src' 'application/x-wais-source' 'sst' 'application/vnd.ms-pkicertstore' 'step' 'application/STEP' 'stl' 'application/vnd.ms-pkistl' 'stm' 'text/html' 'stp' 'application/STEP' 'sv4cpio' 'application/x-sv4cpio' 'sv4crc' 'application/x-sv4crc' 'svg' 'image/svg+xml' 'swf' 'application/x-shockwave-flash' 't' 'application/x-troff' 'tar' 'application/x-tar' 'tcl' 'application/x-tcl' 'tex' 'application/x-tex' 'texi' 'application/x-texinfo' 'texinfo' 'application/x-texinfo' 'tgz' 'application/x-compressed' 'tif' 'image/tiff' 'tiff' 'image/tiff' 'tr' 'application/x-troff' 'trm' 'application/x-msterminal' 'tsi' 'audio/TSP-audio' 'tsp' 'application/dsptype' 'tsv' 'text/tab-separated-values' 'txt' 'text/plain' 'uls' 'text/iuls' 'unv' 'application/i-deas' 'ustar' 'application/x-ustar' 'vcd' 'application/x-cdlink' 'vcf' 'text/x-vcard' 'vda' 'application/vda' 'viv' 'video/vnd.vivo' 'vivo' 'video/vnd.vivo' 'vrml' 'model/vrml' 'wav' 'audio/x-wav' 'wcm' 'application/vnd.ms-works' 'wdb' 'application/vnd.ms-works' 'wks' 'application/vnd.ms-works' 'wmf' 'application/x-msmetafile' 'wps' 'application/vnd.ms-works' 'wri' 'application/x-mswrite' 'wrl' 'model/vrml' 'wrz' 'x-world/x-vrml' 'xaf' 'x-world/x-vrml' 'xbm' 'image/x-xbitmap' 'xhtml' 'application/xhtml+xml' 'xla' 'application/vnd.ms-excel' 'xlc' 'application/vnd.ms-excel' 'xll' 'application/vnd.ms-excel' 'xlm' 'application/vnd.ms-excel' 'xls' 'application/vnd.ms-excel' 'xlt' 'application/vnd.ms-excel' 'xlw' 'application/vnd.ms-excel' 'xml' 'text/xml' 'xof' 'x-world/x-vrml' 'xpm' 'image/x-xpixmap' 'xwd' 'image/x-xwindowdump' 'xyz' 'chemical/x-pdb' 'z' 'application/x-compress' 'zip' 'application/zip' )! !!MAFileModel class methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	MimeTypes := Dictionary new.	1 to: self defaultMimeTypes size by: 2 do: [ :index |		MimeTypes 			at: (self defaultMimeTypes at: index)			put: (self defaultMimeTypes at: index + 1) ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!mimetypeFor: aString	^ self mimetypes at: aString ifAbsent: [ self defaultMimeType ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!mimetypes	^ MimeTypes! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validCharacters	"Answer a string with all the valid characters for filenames."		^ '-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'! !!MAFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ self species = anObject species		and: [ self filename = anObject filename		and: [ self mimetype = anObject mimetype ] ]! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents	"Answer the contents of the file. This method is supposed to be overridden by concrete subclasses."	self subclassResponsibility! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents: aByteArray	"Set the contents of the receiver. This method is supposed to be overridden by concrete subclasses."	filesize := aByteArray size! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!extension	"Answer the file-extension."	^ self filename copyAfterLast: $.! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!filename	"Answer the filename of the receiver."	^ filename! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!filename: aString	"Normalize the filenames. Don't just allow any stupid windows filename.'"	filename := aString isNil ifFalse: [ 		aString collect: [ :char |			(self class validCharacters includes: char)				ifTrue: [ char ]				ifFalse: [ 					char = Character space						ifTrue: [ $- ]						ifFalse: [ $_ ] ] ] ]! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!filesize	"Answer the size of the file."	^ filesize! !!MAFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!finalize	"Cleanup after a file is removed, subclasses might require to specialize this method."		self initialize! !!MAFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ self filename hash bitXor: self mimetype hash! !!MAFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	super initialize.	filesize := 0.	filename := 'unknown'.	mimetype := self class defaultMimeType! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isApplication	"Return ==true== if the mimetype of the receiver is application-data. This message will match types like: application/postscript, application/zip, application/pdf, etc."	^ self maintype = 'application'! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAudio	"Return ==true== if the mimetype of the receiver is audio-data. This message will match types like: audio/basic, audio/tone, audio/mpeg, etc."	^ self maintype = 'audio'! !!MAFileModel methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isEmpty	^ self filesize isZero! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isImage	"Return ==true== if the mimetype of the receiver is image-data. This message will match types like: image/jpeg, image/gif, image/png, image/tiff, etc."	^ self maintype = 'image'! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isText	"Return ==true== if the mimetype of the receiver is text-data. This message will match types like: text/plain, text/html, text/sgml, text/css, text/xml, text/richtext, etc."	^ self maintype = 'text'! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isVideo	"Return ==true== if the mimetype of the receiver is video-data. This message will match types like: video/mpeg, video/quicktime, etc."	^ self maintype = 'video'! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maintype	"Answer the first part of the mime-type."	^ self mimetype copyUpTo: $/! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!mimetype	"Answer the mimetype of the receiver."	^ mimetype! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!mimetype: aString	mimetype := aString! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readStream	^ self contents readStream! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!subtype	"Answer the second part of the mime-type."	^ self mimetype copyAfter: $/! !!MAMemoryFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject    ^ super = anObject and: [ self contents = anObject contents ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents	^ contents ifNil: [ contents := ByteArray new ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents: aByteArray	super contents: aByteArray.	contents := aByteArray asByteArray! !!MAMemoryFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!finalize	super finalize.	contents := nil! !!MAMemoryFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self contents hash! !!MAAccessor methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asAccessor	^ self! !!MAAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	"Test if ==aModel== can be read."	^ false! !!MAAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canWrite: aModel	"Test if ==aModel== can be written."	^ false! !!MAAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultLabelFor: aDescription	^ aDescription class defaultLabel! !!MAAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!handlesSelector: aSelector	^ false! !!MAAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printOn: aStream	self storeOn: aStream! !!MAAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	"Read from ==aModel== using the access-strategy of the receiver."	^ nil! !!MAAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	self class storeOn: aStream.	aStream nextPutAll: ' new'! !!MAAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel	"Write ==anObject== to ==aModel== using the access-strategy of the receiver."! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!accessors: aSequenceableCollection	aSequenceableCollection isEmpty		ifTrue: [ self error: 'Unable to create accessor sequence from empty collection.' ].	aSequenceableCollection size = 1		ifTrue: [ ^ aSequenceableCollection first asAccessor ].	^ self 		on: aSequenceableCollection first asAccessor 		accessor: (self accessors: aSequenceableCollection allButFirst)! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!on: anAccessor accessor: anotherAccessor	^ (self on: anAccessor) accessor: anotherAccessor! !!MAChainAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject and: [ self accessor = anObject accessor ]! !!MAChainAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!accessor	^ accessor! !!MAChainAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!accessor: anAccessor	accessor := anAccessor! !!MAChainAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	^ (super canRead: aModel) and: [ self accessor canRead: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canWrite: aModel	^ (super canRead: aModel) and: [ self accessor canWrite: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionAccessor	<magritteDescription>	^ MAToOneRelationDescription new			reference: MAStringDescription new;			accessor: #accessor;			classes: MAAccessor allSubclasses;			priority: 200;			yourself! !!MAChainAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self accessor hash! !!MAChainAccessor methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	accessor := accessor copy! !!MAChainAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ self accessor read: (super read: aModel)! !!MAChainAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPutAll: ' accessor: ';		store: self accessor;		nextPut: $)! !!MAChainAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel	self accessor write: anObject to: (super read: aModel)! !!MADelegatorAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MADelegatorAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!on: anAccessor	^ self new next: anAccessor! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject and: [ self next = anObject next ]! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	^ self next canRead: aModel! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canWrite: aModel	^ self next canWrite: aModel! !!MADelegatorAccessor methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionNext	<magritteDescription>	^ MAToOneRelationDescription new			reference: MAStringDescription new;			accessor: #next;			classes: MAAccessor allSubclasses;			priority: 100;			yourself! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^  super hash bitXor: self next hash! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!next	^ next! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!next: anAccessor 	next := anAccessor asAccessor! !!MADelegatorAccessor methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	next := next copy! !!MADelegatorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ self next read: aModel! !!MADelegatorAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPut: $)! !!MADelegatorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel	self next write: anObject to: aModel! !!MADictionaryAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MADictionaryAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!key: aSymbol	^ self new		key: aSymbol;		yourself! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject		and: [ self key = anObject key ]! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	^ true! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canWrite: aModel	^ true! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self key hash! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!key	^ key! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!key: aKey	key := aKey! !!MADictionaryAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ aModel at: self key ifAbsent: [ nil ]! !!MADictionaryAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' key: ';		store: self key;		nextPut: $)! !!MADictionaryAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel	aModel at: self key put: anObject! !!MAIdentityAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAIdentityAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	^ true! !!MAIdentityAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ aModel! !!MAIdentityAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel 	MAWriteError signal: 'Not supposed to write to ' , aModel greaseString , '.'! !!MANullAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!new	| random uuid |	random := GRPlatform current newRandom.	uuid := Array new: 16.	1 to: 16 do: [ :i | uuid at: i put: (random nextInt: 256) -1 ].	^ self uuid: uuid! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uuid: anObject	^ self basicNew		uuid: anObject;		yourself! !!MANullAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject		and: [ self uuid = anObject uuid ]! !!MANullAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self uuid hash! !!MANullAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel 	MAReadError signal: 'This message is not appropriate for this object'! !!MANullAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' uuid: ';		store: self uuid;		nextPut: $)! !!MANullAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uuid	^ uuid! !!MANullAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uuid: anObject	uuid := anObject! !!MANullAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel 	MAWriteError signal: 'This message is not appropriate for this object'! !!MAPluggableAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAPluggableAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aReadBlock write: aWriteBlock	^ self new		readBlock: aReadBlock;		writeBlock: aWriteBlock;		yourself! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject		and: [ self readBlock = anObject readBlock		and: [ self writeBlock = anObject writeBlock ] ]! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	^ self readBlock notNil! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canWrite: aModel	^ self writeBlock notNil! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: (self readBlock hash bitXor: self writeBlock hash)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ self readBlock value: aModel! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readBlock	^ readBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readBlock: aBlock	readBlock := aBlock! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeBlock: aBlock on: aStream 	aStream nextPutAll: aBlock decompile greaseString allButFirst allButLast! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' read: '.	self storeBlock: self readBlock on: aStream.	aStream nextPutAll: ' write: '.	self storeBlock: self writeBlock on: aStream.	aStream nextPut: $)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel	self writeBlock value: aModel value: anObject! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!writeBlock	^ writeBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!writeBlock: aBlock	writeBlock := aBlock! !!MASelectorAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aReadSelector write: aWriteSelector	^ self new		readSelector: aReadSelector;		writeSelector: aWriteSelector;		yourself! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector: aSelector	^ self new		selector: aSelector;		yourself! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject		and: [ self readSelector = anObject readSelector		and: [ self writeSelector = anObject writeSelector ] ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	^ self readSelector notNil and: [ aModel respondsTo: self readSelector ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canWrite: aModel	^ self writeSelector notNil and: [ aModel respondsTo: self writeSelector ]! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultLabelFor: aDescription	^ self readSelector asString normalizeCamelCase capitalized! !!MASelectorAccessor methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionSelector	<magritteDescription>	^ MASymbolDescription new			accessor: #selector;			yourself! !!MASelectorAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fieldDescription	^ self readSelector asString! !!MASelectorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!handlesSelector: aSelector	^ aSelector = self readSelector or: [ aSelector = self writeSelector ]! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^  super hash bitXor: (self readSelector hash bitXor: self writeSelector hash)! !!MASelectorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ aModel perform: self readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readSelector	^ readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readSelector: aSelector	readSelector := aSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector	^ self readSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector: aSelector 	self readSelector: aSelector asSymbol.	self writeSelector: (aSelector greaseString copyWith: $:) asSymbol! !!MASelectorAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' read: ';		store: self readSelector;		nextPutAll: ' write: ';		store: self writeSelector;		nextPut: $)! !!MASelectorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel	^ aModel perform: self writeSelector with: anObject! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!writeSelector	^ writeSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!writeSelector: aSelector	writeSelector := aSelector! !!MAVariableAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAVariableAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!name: aString	^ self new		name: aString;		yourself! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject and: [ self name = anObject name ]! !!MAVariableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canRead: aModel	^ aModel class allInstVarNames includes: self name asSymbol! !!MAVariableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canWrite: aModel	^ self canRead: aModel! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self name hash! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!name	^ name! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!name: aString	name := aString! !!MAVariableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ aModel instVarNamed: self name! !!MAVariableAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: ';		store: self name;		nextPut: $)! !!MAVariableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject to: aModel	aModel instVarNamed: self name put: anObject! !!MACondition class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ self name = #MACondition! !!MACondition class methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!receiver: anObject selector: aSelector	^ self receiver: anObject selector: aSelector arguments: #(nil) index: 1! !!MACondition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!receiver: anObject selector: aSelector arguments: anArray index: anInteger	(aSelector numArgs = anArray size)		ifFalse: [ self error: 'Invalid number of arguments.' ].	(anInteger between: 0 and: anArray size)		ifFalse: [ self error: 'Index out of bounds.' ].	^ MAPluggableCondition new 		initializeReceiver: anObject		selector: aSelector		arguments: anArray		index: anInteger! !!MACondition class methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector: aSelector	^ self receiver: nil selector: aSelector arguments: #() index: 0! !!MACondition class methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector: aSelector argument: anObject	^ self receiver: nil selector: aSelector arguments: (Array with: anObject) index: 0! !!MACondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!& aCondition 	^ MAConjunctiveCondition new & self & aCondition! !!MACondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!not	^ MANegationCondition with: self! !!MACondition methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!numArgs	^ 1! !!MACondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value: anObject	self subclassResponsibility! !!MACondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!| aCondition 	^ (self not & aCondition not) not! !!MAConjunctiveCondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!& aCondition	conditions := conditions copyWith: aCondition! !!MAConjunctiveCondition methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	conditions := #()! !!MAConjunctiveCondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value: anObject	^ conditions allSatisfy: [ :each | each value: anObject ]! !!MANegationCondition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!with: aCondition	^ self new initializeWith: aCondition! !!MANegationCondition methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initializeWith: aCondition	condition := aCondition! !!MANegationCondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value: anObject	^ (condition value: anObject) not! !!MAPluggableCondition methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initializeReceiver: anObject selector: aSelector arguments: anArray index: anInteger	receiver := anObject.	selector := aSelector.	arguments := anArray.	index := anInteger! !!MAPluggableCondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value: anObject	| actualReceiver actualArguments |	actualReceiver := index = 0		ifFalse: [ receiver ]		ifTrue: [ anObject ].	actualArguments := index > 0		ifFalse: [ arguments ]		ifTrue: [			arguments copy 				at: index put: anObject;				yourself ].	^ actualReceiver		perform: selector		withArguments: actualArguments! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultAccessor	^ MAIdentityAccessor new! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultCollection	^ OrderedCollection new! !!MAContainer class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!with: aDescription	^ self new		add: aDescription;		yourself! !!MAContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!MAContainer methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!MAContainer methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitContainer: self! !!MAContainer methodsFor: 'adding' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!add: aDescription	self children add: aDescription! !!MAContainer methodsFor: 'adding' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addAll: aCollection	self children addAll: aCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!allSatisfy: aBlock	^ self children allSatisfy: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!anySatisfy: aBlock	^ self children anySatisfy: aBlock! !!MAContainer methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asContainer	^ self! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!at: anIndex	^ self children at: anIndex! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!at: anIndex ifAbsent: aBlock	^ self children at: anIndex ifAbsent: aBlock! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!children	^ children! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!collect: aBlock	^ self copy		setChildren: (self children collect: aBlock);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyEmpty	^ self copy		setChildren: self class defaultCollection;		yourself! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyFrom: aStartIndex to: anEndIndex	^ self copy		setChildren: (self children			copyFrom: aStartIndex			to: anEndIndex);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyWithout: anObject	^self reject: [:each | each = anObject]! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyWithoutAll: aCollection	^self reject: [:each | aCollection includes: each]! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionBuilder	^self propertyAt: #descriptionBuilder ifAbsent: [ nil ]! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionBuilder: aBuilderClass	self propertyAt: #descriptionBuilder put: aBuilderClass! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionBuilders	^self propertyAt: #descriptionBuilders ifAbsent: [ #() ]! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionBuilders: aList 	self descriptionBuilder: MAComposedDescriptionBuilder.	self propertyAt: #descriptionBuilders put: aList! !!MAContainer methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionChildren	<magritteDescription>	^ MAToManyRelationDescription new		accessor: (MASelectorAccessor read: #children write: #setChildren:);		classes: MAElementDescription withAllConcreteClasses;		default: self class defaultCollection;		label: 'Elements';		priority: 400;		beOrdered;		yourself! !!MAContainer methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionDefault	<magritteDescription>	^ nil! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!detect: aBlock	^ self children detect: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!detect: aBlock ifNone: anExceptionBlock	^ self children detect: aBlock ifNone: anExceptionBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!do: aBlock	self children do: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!do: aBlock separatedBy: aSeparatorBlock	self children do: aBlock separatedBy: aSeparatorBlock! !!MAContainer methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!errorNotFound: aDescription	self error: aDescription class label , ' not found.'! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hasChildren	^ self notEmpty! !!MAContainer methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self children hash! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!includes: aDescription	^ self children includes: aDescription! !!MAContainer methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	super initialize.	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!inject: anObject into: aBlock	^ self children inject: anObject into: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!intersection: aCollection	^ self copy		setChildren: (self children intersection: aCollection);		yourself! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isContainer	^ true! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isEmpty	^ self children isEmpty! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!keysAndValuesDo: aBlock	self children keysAndValuesDo: aBlock! !!MAContainer methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteTemplate	^ self! !!MAContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!moveDown: aDescription	self children moveDown: aDescription! !!MAContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!moveUp: aDescription	self children moveUp: aDescription! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!noneSatisfy: aBlock	^ self children noneSatisfy: aBlock! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!notEmpty	^ self children notEmpty! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	self setChildren: self children copy! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reject: aBlock	^ self copy		setChildren: (self children reject: aBlock);		yourself! !!MAContainer methodsFor: 'removing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!remove: aDescription	self children remove: aDescription ifAbsent: [ self errorNotFound: aDescription ]! !!MAContainer methodsFor: 'removing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!removeAll	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!select: aBlock	^ self copy		setChildren: (self children select: aBlock);		yourself! !!MAContainer methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setChildren: aCollection	children := aCollection! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!size	^ self children size! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!union: aContainer	^ self copy		addAll: (aContainer reject: [ :each | self includes: each ]);		yourself! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!with: aCollection do: aBlock	self children with: aCollection do: aBlock! !!MAPriorityContainer class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultCollection	^ SortedCollection new! !!MAPriorityContainer methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitPriorityContainer: self! !!MAPriorityContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!moveDown: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!moveUp: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!resort	self setChildren: self children copy! !!MAPriorityContainer methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setChildren: aCollection	super setChildren: aCollection asSortedCollection! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultAccessor	^ MANullAccessor new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultComment	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultConditions	^ Array new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDefault	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultGroup	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Object! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultLabel	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultPersistent	^ true! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultPriority	^ 0! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultReadOnly	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultRequired	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultShouldCacheDefault	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultStringReader	^ MAStringReader! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultStringWriter	^ MAStringWriter! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultUndefined	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultValidator	^ MAValidatorVisitor! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultVisible	^ true! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultVisibleInReport	^true! !!MADescription class methodsFor: 'accessing-examples' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!grouping	^ MADescriptionHolder groupOf: self! !!MADescription methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!, aDescription	"Concatenate the receiver and ==aDescription== to one composed description. Answer a description container containing both descriptions."	^ self asContainer copy		addAll: aDescription asContainer;		yourself! !!MADescription methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!<= anObject	"Answer whether the receiver should precede ==anObject== in a priority container."	^ self priority <= anObject priority! !!MADescription methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	^ super = anObject		and: [ self accessor = anObject accessor ]! !!MADescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitDescription: self! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!accessor	"Answer the access-strategy of the model-value described by the receiver."	^ accessor ifNil: [ accessor := self class defaultAccessor ]! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!accessor: anObject	accessor := anObject asAccessor! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addCondition: aCondition 	self 		addCondition: aCondition		labelled: aCondition greaseString! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addCondition: aCondition labelled: aString	"Add ==aCondition== as an additional validation condition to the receiver and give it the label ==aString==. The first argument is either a block-context or any other object that responds to ==#value:== with ==true== or ==false==."	self conditions: (self conditions		copyWith: (Association			key: aCondition			value: aString))! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addCondition: aCondition labelled: aStringOrBlock ifValid: aDescription	self		addCondition: [ :obj | (aDescription isSatisfiedBy: obj) not or: aCondition ] 		labelled: aStringOrBlock! !!MADescription methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asContainer	"Answer a description container of the receiver."	self subclassResponsibility! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beHidden	self visible: false! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beOptional	self required: false! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beReadOnly	self readOnly: true! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beRequired	self required: true! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beVisible	self visible: true! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beWriteable	self readOnly: false! !!MADescription methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canExpand	" used to expand a relation description into a group "	^self propertyAt: #canExpand ifAbsent: [ self defaultCanExpand ]! !!MADescription methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canExpand: aBoolean	" used to expand a relation description into a group "	^self propertyAt: #canExpand put: aBoolean! !!MADescription methodsFor: 'accessors' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!chainAccessor: anArray	"Uses ==anArray== of selectors to read from the model."	self accessor: (MAChainAccessor accessors: anArray)! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!comment	"Answer a comment or help-text giving a hint what this description is used for. GUIs that are built from this description might display it as a tool-tip."	^ self propertyAt: #comment ifAbsent: [ self class defaultComment ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!comment: aString	self propertyAt: #comment put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!conditions	"Answer a collection of additional conditions that need to be fulfilled so that the described model is valid. Internally the collection associates conditions with an error string."	^ self propertyAt: #conditions ifAbsent: [ self class defaultConditions ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!conditions: anArray	self propertyAt: #conditions put: anArray! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!conflictErrorMessage	^ self propertyAt: #conflictErrorMessage ifAbsent: [ 'Input is conflicting with concurrent modification' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!conflictErrorMessage: aString	self propertyAt: #conflictErrorMessage put: aString! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!default	^ nil! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!default: anObject! !!MADescription methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultCanExpand	" used to expand a relation description into a group "	self isVisible ifFalse: [ ^false ].	self isReadOnly ifTrue: [ ^false ].	self tabDisplay ifTrue: [ ^false ].	self group ifNotNil: [ ^false ].	^true! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultLabel	^ self accessor defaultLabelFor: self! !!MADescription methodsFor: 'owning object' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!describedObject	^ MADynamicDescribedObject value! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionAccessor	<magritteDescription>	^ MAToOneRelationDescription new		reference: MAStringDescription new;		accessor: #accessor;		classes: MAAccessor allSubclasses;		priority: 10;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionComment	<magritteDescription>	^ MAMemoDescription new		accessor: #comment;		label: 'Comment';		priority: 110;		default: self class defaultComment;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionDefault	<magritteDescription>	^ self class isAbstract		ifFalse: [ 			self class new				accessor: #default;				label: 'Default';				priority: 130;				default: self class defaultDefault;				yourself ]! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionGroup	<magritteDescription>	^ MAStringDescription new		accessor: #group;		default: self class defaultGroup;		label: 'Group';		priority: 105;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionLabel	<magritteDescription>	^ MAStringDescription new		accessor: #label;		label: 'Label';		priority: 100;		default: self defaultLabel;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionName	<magritteDescription>	^ MAStringDescription new		accessor: #name;		label: 'Kind';		priority: 0;		beReadOnly;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionPriority	<magritteDescription>	^ MANumberDescription new		accessor: #priority;		label: 'Priority';		priority: 130;		default: self class defaultPriority;		beRequired;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionReadOnly	<magritteDescription>	^ MABooleanDescription new		accessor: #readOnly;		label: 'Read-only';		priority: 200;		default: self class defaultReadOnly;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionRequired	<magritteDescription>	^ MABooleanDescription new		accessor: #required;		label: 'Required';		priority: 220;		default: self class defaultRequired;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionStringReader	<magritteDescription>	^ MASingleOptionDescription new		accessor: #stringReader;		label: 'String Reader';		priority: 300;		default: self class defaultStringReader;		options: self class defaultStringReader withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionStringWriter	<magritteDescription>	^ MASingleOptionDescription new		accessor: #stringWriter;		label: 'String Writer';		priority: 310;		default: self class defaultStringWriter;		options: self class defaultStringWriter withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionUndefined	<magritteDescription>	^ MAStringDescription new		accessor: #undefined;		label: 'Undefined String';		priority: 140;		default: self class defaultUndefined;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionValidator	<magritteDescription>	^ MASingleOptionDescription new		accessor: #validator;		label: 'Validator';		priority: 250;		default: self class defaultValidator;		options: self class defaultValidator withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionVisible	<magritteDescription>	^ MABooleanDescription new		accessor: #visible;		label: 'Visible';		priority: 210;		default: self class defaultVisible;		yourself! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fromString: aString	"Answer an object being parsed from ==aString==."	^ self fromString: aString reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fromString: aString reader: aParser	"Answer an object being parsed from ==aString== using ==aParser==."	^ aParser read: aString readStream description: self! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fromStringCollection: aCollection	"Answer a collection of objects being parsed from ==aCollection== of strings."	^ self fromStringCollection: aCollection reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fromStringCollection: aCollection reader: aParser	"Answer a collection of objects being parsed from ==aCollection== of strings using ==aParser==."	^ aCollection collect: [ :each | self fromString: each reader: aParser ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!group	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	^ self propertyAt: #group ifAbsent: [ self class defaultGroup ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!group: aString	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	self propertyAt: #group put: aString! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hasChildren	"Answer ==true== if the receiver has any child-descriptions. A description container usually has children."	^ false! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hasComment	"Answer ==true== if the the receiver has got a non empty comment."	^ self comment notNil and: [ self comment isEmpty not ]! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hasLabel	"Answer ==true== if the the receiver has got a non empty label."	^ self label notNil and: [ self label isEmpty not ]! !!MADescription methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self accessor hash! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isContainer	"Answer ==true== if the receiver is a description container."	^ false! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isDescription	"Answer ==true== if the receiver is a description."	^ true! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isGrouped	^ false! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isKindDefined	^ self propertyAt: #kind ifPresent: [ :theKind | true] ifAbsent: [ false ]! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isReadOnly	^ self readOnly! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isRequired	^ self required! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSatisfiedBy: anObject	"Answer ==true== if ==anObject== is a valid instance of the receiver's description."	[ self validate: anObject ]		on: MAValidationError		do: [ :err | ^ false ].	^ true! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSortable	"Answer ==true== if the described object can be trivially sorted, e.g. it answers to #<=."	^ false! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isVisible	^ self visible! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!kind	"Answer the base-class (type) the receiver is describing. The default implementation answers the most generic class: Object, the root of the Smalltalk class hierarchy. Subclasses might refine this choice."	^ self propertyAt: #kind ifAbsent: [ self class defaultKind ]! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!kind: aClass	self propertyAt: #kind put: aClass! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!kindErrorMessage	^ self propertyAt: #kindErrorMessage ifAbsent: [ 'Invalid input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!kindErrorMessage: aString	self propertyAt: #kindErrorMessage put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	"Answer the label of the receiving description. The label is mostly used as an identifier that is printed next to the input field when building a GUI from the receiver."	^ self propertyAt: #label ifAbsent: [ self defaultLabel ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label: aString	self propertyAt: #label put: aString! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!multipleErrorsMessage	^ self propertyAt: #multipleErrorsMessage ifAbsent: [ 'Multiple errors' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!multipleErrorsMessage: aString	self propertyAt: #multipleErrorsMessage put: aString! !!MADescription methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!name	"Answer the name of the description, a human-readable string describing the type."	^ self class label! !!MADescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	accessor := accessor copy! !!MADescription methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' label: '; print: self label.	aStream nextPutAll: ' comment: '; print: self comment! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!priority	"Answer a number that is the priority of the receiving description. Priorities are used to give descriptions an explicit order by sorting them according to this number."	^ self propertyAt: #priority ifAbsent: [ self class defaultPriority ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!priority: aNumber	self propertyAt: #priority put: aNumber! !!MADescription methodsFor: 'accessors' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!propertyAccessor: aSelector	"Uses ==aSelector== to read from the property dictionary of the model."	self accessor: ((MAChainAccessor on: #properties) 		accessor: (MADictionaryAccessor key: aSelector))! !!MADescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aModel	^ self accessor read: aModel! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readOnly	"Test whether my model is read-only."	^ self propertyAt: #readOnly ifAbsent: [ self class defaultReadOnly ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readOnly: aBoolean	self propertyAt: #readOnly put: aBoolean! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!required	"Answer ==true== if the model described by the receiver is required, this is it cannot be ==nil==."	^ self propertyAt: #required ifAbsent: [ self class defaultRequired ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!required: aBoolean	self propertyAt: #required put: aBoolean! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!requiredErrorMessage	^ self propertyAt: #requiredErrorMessage ifAbsent: [ 'Input is required but no input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!requiredErrorMessage: aString	self propertyAt: #requiredErrorMessage put: aString! !!MADescription methodsFor: 'accessors' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selectorAccessor: aSelector	"Uses ==aSelector== to read from the model."	self accessor: (MASelectorAccessor selector: aSelector)! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!shouldCacheDefault	^ self propertyAt: #shouldCacheDefault ifAbsent: [ self class defaultShouldCacheDefault ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringReader	"Answer a Visitor that can be used to parse the model described by the receiver from a string."	^ self propertyAt: #stringReader ifAbsent: [ self class defaultStringReader ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringReader: aClass	self propertyAt: #stringReader put: aClass! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringWriter	"Answer a Visitor that can be used to convert the model described by the receiver to a string."	^ self propertyAt: #stringWriter ifAbsent: [ self class defaultStringWriter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringWriter: aClass	self propertyAt: #stringWriter put: aClass! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!toString: anObject	"Answer a string being formatted from ==anObject==."	^ self toString: anObject writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!toString: anObject writer: aFormatter	"Answer a string being formatted from ==anObject== using ==aFormatter==."	^ aFormatter write: anObject description: self! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!toStringCollection: aCollection	"Answer a collection of strings being formatted from ==aCollection==."	^ self toStringCollection: aCollection writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!toStringCollection: aCollection writer: aFormatter	"Answer a collection of strings being formatted from ==aCollection== using ==aFormatter==."	^ aCollection collect: [ :each | self toString: each writer: aFormatter ]! !!MADescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!tryValidation: tryBlock ifPass: passBlock	| shouldContinue |	shouldContinue := true.	tryBlock on: MAValidationError do: [ :e | shouldContinue := false. e pass ].	shouldContinue ifFalse: [ ^ self ].	passBlock value! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!undefined	"Answer a string that is printed whenever the model described by the receiver is ==nil==."	^ (self propertyAt: #undefined ifAbsent: [ self class defaultUndefined ])		ifNil: [ self class defaultUndefined ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!undefined: aString	self propertyAt: #undefined put: aString! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validate: anObject	"Validate ==anObject== in the context of the describing-receiver, raises an error in case of a problem. If ==anObject== is ==nil== and not required, most tests will be skipped. Do not override this message, instead have a look at ==#validateSpecific:== what is usually a better place to define the behaviour your description requires."	self validator on: anObject description: self! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateConditions: anObject	"Validate ==anObject== to satisfy all its custom conditions."	self conditions do: [ :each |		(each key value: anObject)			ifFalse: [ MAConditionError description: self signal: each value ] ]! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateKind: anObject	"Validate ==anObject== to be of the right kind."	(anObject isKindOf: self kind)		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateRequired: anObject	"Validate ==anObject== not to be ==nil== if it is required."	(self isRequired and: [ anObject isNil ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateSpecific: anObject	"Validate ==anObject== to satisfy its descriptions specific validation rules. Subclasses mostly want to override this method."! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validator	"Answer a Visitor that can be used to validate the model described by the receiver."	^ self propertyAt: #validator ifAbsent: [ self class defaultValidator ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validator: aClass	self propertyAt: #validator put: aClass! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visible	"Answer ==true== if the model described by the receiver is visible, as an opposite to hidden."	^ self propertyAt: #visible ifAbsent: [ self class defaultVisible ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visible: aBoolean	self propertyAt: #visible put: aBoolean! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visibleInReport	^self propertyAt: #visibleInReport ifAbsent: [ self class defaultVisibleInReport ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visibleInReport: aBoolean 	self propertyAt: #visibleInReport put: aBoolean! !!MABlockDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ BlockClosure! !!MABlockDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultLineCount	^ 3! !!MABlockDescription class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MAMemoMorph! !!MABlockDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MABlockDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Block'! !!MABlockDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitBlockDescription: self! !!MABlockDescription methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionLineCount	<magritteDescription>	^ MANumberDescription new		accessor: #lineCount;		label: 'Number of Lines';		priority: 400;		default: self class defaultLineCount;		beInteger;		min: 1;		yourself! !!MABlockDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!lineCount	^ self propertyAt: #lineCount ifAbsent: [ self class defaultLineCount ]! !!MABlockDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!lineCount: anInteger	self propertyAt: #lineCount put: anInteger! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultFalseString	^ self defaultFalseStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultFalseStrings	^ #( 'false' 'f' 'no' 'n' '0' 'off' )! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Boolean! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultTrueString	^ self defaultTrueStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultTrueStrings	^ #( 'true' 't' 'yes' 'y' '1' 'on' )! !!MABooleanDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MABooleanDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Boolean'! !!MABooleanDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitBooleanDescription: self! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!allOptions	^ self options! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!allOptionsWith: anObject	^ self options! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionFalseString	<magritteDescription>	^ MAStringDescription new		accessor: #falseString;		default: self class defaultFalseString;		label: 'False String';		priority: 410;		yourself! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionRequired	<magritteDescription>	^ nil! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionTrueString	<magritteDescription>	^ MAStringDescription new		accessor: #trueString;		default: self class defaultTrueString;		label: 'True String';		priority: 400;		yourself! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!falseString	^ self propertyAt: #falseString ifAbsent: [ self class defaultFalseString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!falseString: aString	self propertyAt: #falseString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!falseStrings	^ self class defaultFalseStrings! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isExtensible	^ false! !!MABooleanDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!labelForOption: anObject	anObject == true		ifTrue: [ ^ self trueString ].	anObject == false		ifTrue: [ ^ self falseString ].	^ self undefined! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!options	^ Array with: false with: true! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reference	^ self! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!trueString	^ self propertyAt: #trueString ifAbsent: [ self class defaultTrueString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!trueString: aString	self propertyAt: #trueString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!trueStrings	^ self class defaultTrueStrings! !!MAClassDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Class! !!MAClassDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAClassDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Class'! !!MAClassDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitClassDescription: self! !!MAColorDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ GRPlatform current magritteColorClass! !!MAColorDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAColorDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Color'! !!MAColorDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitColorDescription: self! !!MAElementDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDisplayProperty	^ #greaseString! !!MAElementDescription class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!new	"override #new so that we can create an object without adding it to the collection returned by: MAElementDescription withAllConcreteClasses,	that is so we can call  MAElementDescription new magritteDescription  and it works as expected, which is used in MADescriptionEditor>>#buildReport .	Yes it's a hack, but it works... (better ideas gratefully received)"	^ self basicNew initialize! !!MAElementDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitElementDescription: self! !!MAElementDescription methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asContainer	^ MAContainer with: self! !!MAElementDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!default	^ self propertyAt: #default ifAbsent: [ self class defaultDefault ]! !!MAElementDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!default: anObject	self propertyAt: #default put: anObject! !!MAElementDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!display: aBlockOrSymbol	"Transform how the file is converted to a string.	aSymbol		- is performed on the object	aBlock		- takes one argument, which is the domain object		- returns the string to display"	self propertyAt: #displayBlockOrSymbol put: aBlockOrSymbol.! !!MAElementDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!displayBlockOrSymbol	^self propertyAt: #displayBlockOrSymbol ifAbsent: [ self class defaultDisplayProperty ]! !!MAElementDescription methodsFor: 'displaying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!displayStringFor: anObject	"Convert object to a string. If a block was passed to #display: use that, otherwise send #greaseString by default"	^self displayBlockOrSymbol value: anObject.! !!MAElementDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!handlesSelector: aSelector	^ self accessor handlesSelector: aSelector! !!MAElementDescription methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printFor: anObject on: aWriteStream 	(self read: anObject) ifNotNil: [ :value | aWriteStream nextPutAll: value asString ]! !!MAElementDescription methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeOn: aStream	aStream 		nextPutAll: self className;		nextPutAll: ' new'; cr.	(self magritteDescription reject: #isReadOnly) do: [ :desc |		| value |		value := desc read: self.		(value ~= desc default and: [ value isNotNil ]) ifTrue: [ 			desc accessor store: value inDescriptionOn: aStream ] ].	aStream nextPutAll: 'yourself'! !!MADirectoryDescription class methodsFor: 'acessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^'Directory'! !!MADirectoryDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitDirectoryDescription: self! !!MAFileDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDisplayProperty	^ [ :e | e fullName ].! !!MAFileDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ MAMemoryFileModel! !!MAFileDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAFileDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'File'! !!MAFileDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitFileDescription: self! !!MAFileDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDirectory	^ self propertyAt: #defaultDirectory ifAbsent: [ MAFileSystem imageDirectory ].! !!MAFileDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDirectory: fileReference	"fileReference - a FileSystem FileReference, or an MAFileReference if FileSystem is not installed"	self propertyAt: #defaultDirectory put: fileReference! !!MADateAndTimeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ DateAndTime! !!MADateAndTimeDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MADateAndTimeDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Date and Time'! !!MADateAndTimeDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitDateAndTimeDescription: self! !!MADateDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDisplayProperty	^ [ :aDateOrNil | 				aDateOrNil					ifNotNil: [ aDateOrNil greaseString ]					ifNil: [ '' ] ]! !!MADateDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Date! !!MADateDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MADateDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Date'! !!MADateDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitDateDescription: self! !!MADurationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Duration! !!MADurationDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MADurationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Duration'! !!MADurationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitDurationDescription: self! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMax	^ nil! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMin	^ nil! !!MAMagnitudeDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitMagnitudeDescription: self! !!MAMagnitudeDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionMax	<magritteDescription>	^ self class new		accessor: #max;		label: 'Maximum';		priority: 410;		yourself! !!MAMagnitudeDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionMin	<magritteDescription>	^ self class new		accessor: #min;		label: 'Min';		priority: 400;		yourself! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSortable	^ true! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isWithinRange: anObject	^ (self min isNil or: [ self min <= anObject ])		and: [ self max isNil or: [ self max >= anObject ] ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!max	^ self propertyAt: #max ifAbsent: [ self class defaultMax ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!max: aMagnitudeOrNil	"Set the maximum for accepted values, or ==nil== if open."	self propertyAt: #max put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!min	^ self propertyAt: #min ifAbsent: [ self class defaultMin ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!min: aMagnitudeOrNil	"Set the minimum for accepted values, or ==nil== if open."	self propertyAt: #min put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'conveniance' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!min: aMinimumObject max: aMaximumObject	"Set the minimum and maximum of accepted values, or ==nil== if open."	self min: aMinimumObject; max: aMaximumObject! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rangeErrorMessage	| min max |	^ self propertyAt: #rangeErrorMessage ifAbsent: [		min := self toString: self min. max := self toString: self max.		(self min notNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be between ' , min , ' and ' , max ].		(self min notNil and: [ self max isNil ])			ifTrue: [ ^ 'Input must be above or equeal to ' , min ].		(self min isNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be below or equal to ' , max ] ]! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rangeErrorMessage: aString	self propertyAt: #rangeErrorMessage put: aString! !!MAMagnitudeDescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateSpecific: anObject	super validateSpecific: anObject.	(self isWithinRange: anObject)		ifFalse: [ MARangeError description: self signal: self rangeErrorMessage ]! !!MANumberDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Number! !!MANumberDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MANumberDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Number'! !!MANumberDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitNumberDescription: self! !!MANumberDescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beInteger	self addCondition: (MACondition selector: #isInteger) labelled: 'No integer was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beNegative	self addCondition: (MACondition selector: #negative) labelled: 'No negative number was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!bePositive	self addCondition: (MACondition selector: #positive) labelled: 'No positive number was entered'! !!MATimeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDisplayProperty	^ [ :time | 		time hour greaseString, ':',		time minute greaseString, ':',		time second greaseString ].! !!MATimeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Time! !!MATimeDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MATimeDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Time'! !!MATimeDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitTimeDescription: self! !!MATimeStampDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ GRPlatform current magritteTimeStampClass! !!MATimeStampDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MATimeStampDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Timestamp'! !!MATimeStampDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitTimeStampDescription: self! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDistinct	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Collection! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultOrdered	^ false! !!MAMultipleOptionDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Multiple-Option'! !!MAMultipleOptionDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitMultipleOptionDescription: self! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beDistinct	self distinct: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beIndefinite	self distinct: false! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beOrdered	self ordered: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beUnordered	self ordered: false! !!MAMultipleOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionDistinct	<magritteDescription>	^ MABooleanDescription new		accessor: #distinct;		label: 'Distinct';		priority: 250;		default: self class defaultDistinct;		yourself! !!MAMultipleOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionOrdered	<magritteDescription>	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self class defaultOrdered;		yourself! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!distinct	^ self propertyAt: #distinct ifAbsent: [ self class defaultDistinct ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!distinct: aBoolean	self propertyAt: #distinct put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isDistinct	^ self distinct! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isMultiple	^true! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isOrdered	^ self ordered! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateKind: anObject	self 		tryValidation: [ super validateKind: anObject ]	  ifPass: [ anObject do: [ :e | self validateOptionKind: e ] ]! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultExtensible	^ false! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultOptions	^ OrderedCollection new! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultSorted	^ false! !!MAOptionDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitOptionDescription: self! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!allOptions	^ self options maAllOptionsFor: self! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!allOptionsWith: anObject	^ self prepareOptions: ((self shouldNotInclude: anObject)		ifFalse: [ self options copyWith: anObject ]		ifTrue: [ self options copy ])! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beExtensible	self extensible: true! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beLimited	self extensible: false! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beSorted	self sorted: true! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beUnsorted	self sorted: false! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionDefault	<magritteDescription>	^ nil! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionExtensible	<magritteDescription>	^ MABooleanDescription new		accessor: #extensible;		label: 'Extensible';		priority: 250;		default: self class defaultExtensible;		yourself! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionOptions	<magritteDescription>	^ MAMemoDescription new		accessor: #optionsTextual;		label: 'Options';		priority: 410;		default: self class defaultOptions;		yourself! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionSorted	<magritteDescription>	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self class defaultSorted;		yourself! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!extensible	^ self propertyAt: #extensible ifAbsent: [ self class defaultExtensible ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!extensible: aBoolean	self propertyAt: #extensible put: aBoolean! !!MAOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isExtensible	^ self extensible! !!MAOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isMultiple	^false! !!MAOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSorted	^ self sorted! !!MAOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!labelForOption: anObject	self propertyAt: #labels ifPresent: [ :labels | labels optionFor: anObject ifPresent: [ :value | ^value ] ].	^ self reference toString: anObject! !!MAOptionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!options	^ options ifNil: [ options := self class defaultOptions ]! !!MAOptionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!options: anArray	options := anArray! !!MAOptionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!optionsAndLabels: aCollection	"Set the options to be the keys of aCollection and the labels to be the values of aCollection."	self options: (aCollection collect: [ :assoc | assoc key ]).	self propertyAt: #labels put: (aCollection		inject: IdentityDictionary new		into: [ :result :assoc | result add: assoc; yourself ])! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!optionsTextual	^ (self reference toStringCollection: self options)		asMultilineString! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!optionsTextual: aString	| lines |	lines := (aString ifNil: [ String new ]) lines.	^ self options: (self reference fromStringCollection: lines)! !!MAOptionDescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	options := options copy! !!MAOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!prepareOptions: aCollection	^ self isSorted		ifFalse: [ aCollection asArray ]		ifTrue: [ 			aCollection asArray				sort: self sortBlock;				yourself ]! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!shouldNotInclude: anObject	^ self isExtensible not or: [ anObject isNil or: [ self options includes: anObject ] ]! !!MAOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!sortBlock	^ [ :a :b | (self reference toString: a) caseInsensitiveLessOrEqual: (self reference toString: b) ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!undefined: aString	super undefined: aString.	self reference isNil		ifFalse: [ self reference undefined: aString ]! !!MAOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateOptionKind: anObject	(self options includes: anObject)		ifTrue: [ ^ self ].	self isExtensible		ifTrue: [ self reference validate: anObject ]		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MASingleOptionDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MASingleOptionDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Single-Option'! !!MASingleOptionDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitSingleOptionDescription: self! !!MASingleOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionGroupBy	<magritteDescription>	^ MASymbolDescription new		selectorAccessor: #groupBy;		label: 'Grouped by';		priority: 260;		default: nil;		yourself! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupBy	^ self propertyAt: #groupBy ifAbsent: [ nil ]! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupBy: anAccessor	"anAccessor to be sent to the options objects for getting their group."		self propertyAt: #groupBy put: anAccessor asAccessor! !!MASingleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isGrouped	^ self groupBy notNil! !!MASingleOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!prepareOptions: aCollection	^ self isRequired		ifTrue: [ super prepareOptions: aCollection ]		ifFalse: [ (Array with: nil) , (super prepareOptions: aCollection) ]! !!MASingleOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateKind: anObject	super validateKind: anObject.	self validateOptionKind: anObject! !!MAReferenceDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultReference	^ MAStringDescription new! !!MAReferenceDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitReferenceDescription: self! !!MAReferenceDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionReference	<magritteDescription>	^ MAToOneRelationDescription new		accessor: #reference;		classes: MADescription withAllConcreteClasses;		label: 'Description';		priority: 400;		beRequired;		yourself! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initializer	^ self propertyAt: #initializer ifAbsent: [ #yourself ]! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initializer: valuable	self propertyAt: #initializer put: valuable! !!MAReferenceDescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	reference := reference copy! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reference	^ reference ifNil: [ reference := self class defaultReference ]! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reference: aDescription	reference := aDescription! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultClasses	^ Set new! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultReference	^ nil! !!MARelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitRelationDescription: self! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!allClasses	^ (Array withAll: self classes)		sort: [ :a :b | a label caseInsensitiveLessOrEqual: b label ];		yourself! !!MARelationDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!classes	^ classes ifNil: [ classes := self class defaultClasses ]! !!MARelationDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!classes: aCollection	classes := aCollection! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!commonClass	"Answer a common superclass of the classes of the receiver. The algorithm is implemented to be as efficient as possible. The inner loop will be only executed the first few iterations."	| current |	self classes isEmpty		ifTrue: [ ^ self descriptionContainer ].	current := self classes anyOne.	self classes do: [ :each |		[ each includesBehavior: current ]			whileFalse: [ current := current superclass ] ].	^ current! !!MARelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionClasses	<magritteDescription>	^ MAMultipleOptionDescription new		accessor: #classes;		label: 'Classes';		priority: 400;		options: Smalltalk globals allClasses;		default: Set new; "To avoid storing unneeded empty set [1]"		reference: MAClassDescription new;		yourself		"1. There may be a better way. When generating description methods from meta-meta descriptions, without the line above, an unneeded `default: Set new;` was being added to the generated method."! !!MARelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionReference	<magritteDescription>	^ super descriptionReference		classes: MAContainer withAllConcreteClasses;		beOptional;		yourself! !!MARelationDescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	classes := classes copy! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reference	"The reference within a ==*MARelationDescription*== is calculated automatically from all the classes of the receiver, if set to ==nil==. By setting the reference to a ==*MAContainer*== instance it is possible to customize the reference description."	^ super reference ifNil: [ self commonClass magritteTemplate magritteDescription ]! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultDefinitive	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Collection! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultOrdered	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultShouldCacheDefault	^ true! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultSorted	^ false! !!MAToManyRelationDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ '1:m Relation'! !!MAToManyRelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitToManyRelationDescription: self! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beDefinitive	self definitive: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beModifiable	self definitive: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beOrdered	self ordered: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beSorted	self sorted: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beUnordered	self ordered: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beUnsorted	self sorted: false! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!definitive	"Return true if the field is non-modifiable"	^ self propertyAt: #definitive ifAbsent: [ self class defaultDefinitive ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!definitive: aBoolean	self propertyAt: #definitive put: aBoolean! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionDefinitive	<magritteDescription>	^ MABooleanDescription new		accessor: #definitive;		label: 'Definitive';		priority: 265;		default: self class defaultDefinitive;		yourself! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionOrdered	<magritteDescription>	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self class defaultOrdered;		yourself! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionSorted	<magritteDescription>	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self class defaultSorted;		yourself! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isDefinitive	"Return true if the field is non-modifiable"	^ self definitive.! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isOrdered	^ self ordered! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSorted	^ self sorted! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateKind: anObject	self		tryValidation: [ super validateKind: anObject ]		ifPass: [ 			anObject do: [ :object |				(self classes anySatisfy: [ :class | object species includesBehavior: class ])					ifFalse: [ MAKindError description: self signal: self kindErrorMessage ] ] ]! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MAToManyScalarRelationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ '1:m scalar Relation'! !!MAToManyScalarRelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitToManyScalarRelationDescription: self! !!MAToOneRelationDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAToOneRelationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ '1:1 Relation'! !!MAToOneRelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitToOneRelationDescription: self! !!MAToOneRelationDescription methodsFor: 'ToMany compatibility' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isDefinitive	"I'm really not sure what this does, but we need to respond to it to get MAElementRow to work, which was copied over from ToMany"	^ false! !!MAToOneRelationDescription methodsFor: 'ToMany compatibility' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isOrdered	"See #isDefinitive comment"	^ false! !!MAToOneRelationDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateKind: anObject	super validateKind: anObject.	(self classes anySatisfy: [ :class | anObject species includesBehavior: class ])		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultColumnLabels	^ OrderedCollection with: 'a' with: 'b' with: 'c'! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ MATableModel! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultRowLabels	^ OrderedCollection with: '1' with: '2' with: '3'! !!MATableDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MATableDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Table'! !!MATableDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitTableDescription: self! !!MATableDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!columnCount	^ self columnLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!columnLabels	^ self propertyAt: #columnLabels ifAbsent: [ self class defaultColumnLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!columnLabels: aCollection	self propertyAt: #columnLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!columnLabelsTextual	^ (MAStringDescription new toStringCollection: self columnLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!columnLabelsTextual: aString	self columnLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionColumnLabels	<magritteDescription>	^ MAMemoDescription new		accessor: #columnLabelsTextual;		label: 'Column Labels';		priority: 250;		yourself! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionDefault	<magritteDescription>	^ nil! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionRequired	<magritteDescription>	^ nil! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionRowLabels	<magritteDescription>	^ MAMemoDescription new		accessor: #rowLabelsTextual;		label: 'Row Labels';		priority: 250;		yourself! !!MATableDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rowCount	^ self rowLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rowLabels	^ self propertyAt: #rowLabels ifAbsent: [ self class defaultRowLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rowLabels: aCollection	self propertyAt: #rowLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rowLabelsTextual	^ (MAStringDescription new toStringCollection: self rowLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rowLabelsTextual: aString	self rowLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'private-validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateChildren: anObject 	anObject do: [ :row :value :each | self reference validate: each ].! !!MATableDescription methodsFor: 'private-validating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateCounts: anObject 	(anObject rowCount ~= self rowCount or: [ anObject columnCount ~= self columnCount ])		ifTrue: [ MAKindError description: self signal: self kindErrorMessage ].! !!MATableDescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validateSpecific: anObject	self		tryValidation: [ super validateSpecific: anObject ]		ifPass: [ 			self validateCounts: anObject.			self validateChildren: anObject ]! !!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Array! !!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultSeparators	^ ' ,;', (String with: Character cr with: Character lf with: Character tab)! !!MATokenDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MATokenDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Token'! !!MATokenDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitTokenDescription: self! !!MATokenDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionSeparators	<magritteDescription>	^ MAStringDescription new		accessor: #separators;		label: 'Separators';		priority: 250;		yourself! !!MATokenDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!separators	^ separators ifNil: [ separators := self class defaultSeparators ]! !!MATokenDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!separators: aString	"A string with the separator characters to split tokens, the first character is used as a default for printing."	separators := aString! !!MAMemoDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultLineCount	^ 3! !!MAMemoDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Memo'! !!MAMemoDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitMemoDescription: self! !!MAMemoDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionLineCount	<magritteDescription>	^ MANumberDescription new		accessor: #lineCount;		label: 'Number of Lines';		priority: 400;		default: self class defaultLineCount;		beInteger;		min: 1;		yourself! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!lineCount	^ self propertyAt: #lineCount ifAbsent: [ self class defaultLineCount ]! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!lineCount: anInteger	self propertyAt: #lineCount put: anInteger! !!MAPasswordDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Password'! !!MAPasswordDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitPasswordDescription: self! !!MAPasswordDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isObfuscated: anObject	^ anObject notNil		and: [ anObject isString		and: [ anObject isEmpty not		and: [ anObject allSatisfy: [ :each | each = $* ] ] ] ]! !!MAPasswordDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSortable	^ false! !!MAPasswordDescription methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!obfuscated: anObject	^ String new: (self toString: anObject) size withAll: $*! !!MAStringDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ String! !!MAStringDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAStringDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'String'! !!MAStringDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitStringDescription: self! !!MAStringDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSortable	^ true! !!MASymbolDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultKind	^ Symbol! !!MASymbolDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'Symbol'! !!MASymbolDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitSymbolDescription: self! !!MAUrlDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor	aVisitor visitUrlDescription: self! !!MACachedMemento class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MACachedMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!cache	^ cache! !!MACachedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!commit	super commit.	self push: self cache.	self reset! !!MACachedMemento methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hasChanged	"Answer ==true==, if the cached data is different to the data in the model."	^ self isDifferent: self cache to: self pullRaw! !!MACachedMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readUsing: aDescription	^ self cache at: aDescription! !!MACachedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reset	super reset.	self setCache: self pull! !!MACachedMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setCache: aDictionary	cache := aDictionary! !!MACachedMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject using: aDescription	self cache at: aDescription put: anObject! !!MACheckedMemento methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hasConflict	"Answer ==true==, if there is an edit conflict."	^ self hasChanged and: [ self isDifferent: self original to: self pullRaw ]! !!MACheckedMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!original	^ original! !!MACheckedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reset	super reset.	self setOriginal: self pullRaw! !!MACheckedMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setOriginal: aDictionary	original := aDictionary! !!MACheckedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validate	self hasConflict		ifFalse: [ ^ super validate ].	self reset.	MAConflictError		description: self magritteDescription		signal: self magritteDescription conflictErrorMessage! !!MAMemento class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!model: aModel	^ self model: aModel description: aModel magritteDescription! !!MAMemento class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!model: aModel description: aDescription	^ self new		setModel: aModel;		setDescription: aDescription;		reset; yourself! !!MAMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!commit	"Commit the receiver into the model."! !!MAMemento methodsFor: 'reflective operations' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!doesNotUnderstand: aMessage  self model magritteDescription children detect: [ :desc | desc isMessage: aMessage selector ] ifFound: [ : desc | ^ self readUsing: desc ].  ^ super doesNotUnderstand: aMessage! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isDifferent: firstDictionary to: secondDictionary	| firstValue secondValue |	self magritteDescription do: [ :each |		(each isVisible and: [ each isReadOnly not ]) ifTrue: [			firstValue := firstDictionary at: each ifAbsent: [ nil ].			secondValue := secondDictionary at: each ifAbsent: [ nil ].			firstValue = secondValue ifFalse: [ ^ true ] ] ].	^ false! !!MAMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescription	^ description! !!MAMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!model	^ model! !!MAMemento methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' model: '; print: self model! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!pull	"Utility method to pull the model into a dictionary mapping descriptions to values. nil values are replaced with the default ones of the model."	| result |	result := self pullRaw.	result keysAndValuesDo: [ :key :value |		value isNil			ifTrue: [ result at: key put: key default yourself ] ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!pullRaw	| result |	result := Dictionary new.	self magritteDescription do: [ :each |		result at: each put: (self model			readUsing: each) ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!push: aDictionary	"Utility method to push a dictionary mapping descriptions to values into the model."	aDictionary keysAndValuesDo: [ :key :value |		(key isVisible and: [ key isReadOnly not ]) 			ifTrue: [ self model write: value using: key ] ]! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readUsing: aDescription	^ self subclassResponsibility! !!MAMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reset	"Reset the memento from the model."! !!MAMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setDescription: aDescription	description := aDescription! !!MAMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setModel: aModel	model := aModel! !!MAMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validate	"Check if the data in the receiver would be valid if committed. In case of problems an exception is raised."	self magritteDescription validate: self! !!MAStraightMemento class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAStraightMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readUsing: aDescription	^ (self model readUsing: aDescription)		ifNil: [ aDescription default ]! !!MAStraightMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject using: aDescription	self model write: anObject using: aDescription! !!MAObject class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ true! !!MAObject class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!new	"Create a new instance of the receiving class and checks if it is concrete."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!MAObject class methodsFor: 'reflection' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!MAObject class methodsFor: 'reflection' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!withAllConcreteClassesDo: aBlock	self withAllSubclassesDo: [ :each |		each isAbstract ifFalse: [			aBlock value: each ] ]! !!MAObject methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject	"Answer whether the receiver and the argument represent the same object. This default implementation checks if the species of the compared objects are the same, so that superclasses might call super before performing their own check. Also redefine the message ==#hash== when redefining this message."	^ self species = anObject species! !!MAObject methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!acceptMagritte: aVisitor! !!MAObject methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!errorPropertyNotFound: aSelector 	MAPropertyError signal: 'Property ' , aSelector , ' not found.'! !!MAObject methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hasProperty: aKey	"Test if the property ==aKey== is defined within the receiver."	^ self properties includesKey: aKey! !!MAObject methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	"Answer a SmallInteger whose value is related to the receiver's identity. Also redefine the message ==#= == when redefining this message."	^ self species hash! !!MAObject methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	"This method is called whenever a shallow copy of the receiver is made. Redefine this method in subclasses to copy other fields as necessary. Never forget to call super, else class invariants might be violated."	super postCopy.	properties := properties copy! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!propertyAt: aKey	"Answer the value of the property ==aKey==, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, or the result of ==aBlock== if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	^ self properties at: aKey ifAbsentPut: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!propertyAt: aKey ifPresent: aBlock	"Lookup the property ==aKey==, if it is present, answer the value of evaluating ==aBlock== block with the value. Otherwise, answer ==nil==."	^ self properties at: aKey ifPresent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!propertyAt: aKey ifPresent: oneArgBlock ifAbsent: absentBlock	"Lookup ==aKey==, if it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."	^ self properties at: aKey ifPresent: oneArgBlock ifAbsent: absentBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue==."	^ self properties at: aKey put: aValue! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!containerPragma 	^ #magritteContainer! !!MAPragmaBuilder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!for: anObject	^ self new for: anObject! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescriptionExtensionPragma 	^ #magritteDescription:! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescriptionPragma 	^ #magritteDescription! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteSelectors	^ Array with: self containerPragma with: self magritteDescriptionExtensionPragma with: self magritteDescriptionPragma! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!build: anObject cache: cache	| container |	container := cache at: anObject put: (self buildContainer: anObject).		^ container		addAll: (self buildDescriptions: anObject);		yourself.! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildContainer: anObject	| containerPragmas containerPragma containerSelector extensionSelectors container |		containerPragmas := Pragma 		allNamed: self class containerPragma 		from: anObject class to: Object.			containerPragma := containerPragmas detect: [ :each | each method numArgs = 0 ].	containerSelector := containerPragma method selector.	extensionSelectors := (containerPragmas 		select: [ :each | each method numArgs = 1 ]) 		collect: [ :each | each method selector ]. 	MADynamicDescribedObject use: anObject during: [			container := anObject perform: containerSelector.		extensionSelectors do: [ :each | 			anObject perform: each with: container ] ].	^ container! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildDescriptions: anObject	| descriptionExtensions descriptionSelectors |		descriptionSelectors := self uniqueDescriptionSelectors: anObject.	descriptionExtensions := self descriptionExtensions: anObject.	^ (descriptionSelectors 		collect:  [ :each |			| description |			description := anObject perform: each.						description notNil ifTrue: [				descriptionExtensions at: each ifPresent: [ :extensions | 					extensions do: [ :extensionSelector | 						description := anObject perform: extensionSelector with: description ] ] ].			description ])		select: #notNil.! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionExtensions: anObject	| extensionPragmas |		extensionPragmas := Pragma		allNamed: self class magritteDescriptionExtensionPragma		from: anObject class to: Object.		^ extensionPragmas inject: Dictionary new into: [ :extensionSelectors :each | 		| extensionSelectorTarget |		extensionSelectorTarget := each arguments first.		(extensionSelectors at: extensionSelectorTarget ifAbsentPut: [ SortedCollection new ]) add: each method selector.		extensionSelectors ].! !!MAPragmaBuilder methodsFor: 'description building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!for: anObject	| cache |	cache := MADynamicDescriptionCache value.		MADynamicDescriptionCache use: cache during: [		^ cache at: anObject ifAbsentPut: [ self build: anObject cache: cache ] ]! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uniqueDescriptionSelectors: anObject	| descriptionPragmas selectors |		descriptionPragmas := Pragma 		allNamed: self class magritteDescriptionPragma 		from: anObject class to: Object.			selectors := descriptionPragmas collect: [ :each | each method selector ].		^ Set withAll: selectors! !!MASortBlock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!accessor: anAccessor selector: aSelector	^ self basicNew initializeAccessor: anAccessor selector: aSelector! !!MASortBlock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector: aSelector 	^ self 		accessor: MAIdentityAccessor new		selector: aSelector! !!MASortBlock methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fixTemps! !!MASortBlock methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initializeAccessor: anAccessor selector: aSelector	accessor := anAccessor asAccessor.	selector := aSelector! !!MASortBlock methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value: aFirstObject value: aSecondObject	^ (accessor read: aFirstObject)		perform: selector		with: (accessor read: aSecondObject)! !!MATableModel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rows: aRowCount columns: aColumnCount	^ self rows: aRowCount columns: aColumnCount contents: (Array new: aRowCount * aColumnCount)! !!MATableModel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rows: aRowCount columns: aColumnCount contents: anArray	^ self new		setRowCount: aRowCount;		setColumnCount: aColumnCount;		setContents: anArray;		yourself! !!MATableModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= aTable	^ self species = aTable species		and: [ self rowCount = aTable rowCount		and: [ self columnCount = aTable columnCount		and: [ self contents = aTable contents ] ] ]! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!at: aRowIndex at: aColumnIndex	"Answer the contents of ==aRowIndex== and ==aColumnIndex==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!at: aRowIndex at: aColumnIndex put: aValue	"Set the contents of ==aRowIndex== and ==aColumnIndex==> to ==aValue==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex put: aValue! !!MATableModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!checkAt: aRowIndex at: aColumnIndex	(aRowIndex between: 1 and: self rowCount)		ifFalse: [ self error: 'Row subscript out of range.' ].	(aColumnIndex between: 1 and: self columnCount)		ifFalse: [ self error: 'Column subscript out of range.' ]! !!MATableModel methodsFor: 'enumeration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!collect: aBlock	| copy |	copy := self copyEmpty.	self do: [ :row :col :val |		copy			at: row at: col			put: (aBlock value: row value: col value: val) ].	^ copy! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!columnCount	"Answer the column count of the table."	^ columnCount! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents	"Answer the contents array of the receiver."	^ contents! !!MATableModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyEmpty	^ self class rows: self rowCount columns: self columnCount! !!MATableModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyRows: aRowCount columns: aColumnCount	| table |	table := self class rows: aRowCount columns: aColumnCount.	1 to: (self rowCount min: aRowCount) do: [ :row |		1 to: (self columnCount min: aColumnCount) do: [ :col |			table				uncheckedAt: row at: col				put: (self uncheckedAt: row at: col) ] ].	^ table! !!MATableModel methodsFor: 'enumeration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!do: aBlock	1 to: self rowCount do: [ :row |		1 to: self columnCount do: [ :col |			aBlock				value: row value: col				value: (self uncheckedAt: row at: col) ] ]! !!MATableModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ self contents hash! !!MATableModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!indexAt: aRowIndex at: aColumnIndex	^ (aRowIndex - 1) * self columnCount + aColumnIndex! !!MATableModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!pointAt: anIndex	^ Point x: (anIndex - 1 // self columnCount + 1) y: (anIndex - 1 \\ self columnCount + 1)! !!MATableModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	super postCopy.	self setContents: self contents copy! !!MATableModel methodsFor: 'operations' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reshapeRows: aRowCount columns: aColumnCount	"Change the size of the receiving table to ==aRowCount== times ==aColumnCount==, throwing away elements that are cut off and initializing empty cells with ==nil==."	self setContents: (self copyRows: aRowCount columns: aColumnCount) contents.	self setRowCount: aRowCount; setColumnCount: aColumnCount! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rowCount	"Answer the row count of the table."	^ rowCount! !!MATableModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setColumnCount: anInteger	columnCount := anInteger! !!MATableModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setContents: anArray	contents := anArray! !!MATableModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setRowCount: anInteger	rowCount := anInteger! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uncheckedAt: aRowIndex at: aColumnIndex	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex)! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uncheckedAt: aRowIndex at: aColumnIndex put: aValue	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex) put: aValue! !!MADescriptionHolder class methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionClasses	^ MAElementDescription withAllConcreteClasses asOrderedCollection! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupChoice	^ Set new		add: MABooleanDescription;		add: MASingleOptionDescription;		add: MAMultipleOptionDescription;		add: MAToOneRelationDescription;		add: MAToManyRelationDescription;		add: MAToManyScalarRelationDescription;				yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupMagnitude	^ Set new		add: MANumberDescription;		add: MADurationDescription;		add: MADateDescription;		add: MATimeDescription;		add: MATimeStampDescription;		add: MADateAndTimeDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupMisc	^ Set new		add: MAFileDescription;		add: MAClassDescription;		add: MATableDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupOf: aClass 	(self groupText includes: aClass)		ifTrue: [ ^ 'Text' ].	(self groupChoice includes: aClass)		ifTrue: [ ^ 'Choice' ].	(self groupMagnitude includes: aClass)		ifTrue: [ ^ 'Magnitude' ].	(self groupPick includes: aClass)		ifTrue: [ ^ 'Pick' ].	(self groupMisc includes: aClass)		ifTrue: [ ^ 'Miscellaneous' ].	^ 'Other'! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupPick	^ Set new		add: MAColorDescription;		add: MATokenDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!groupText	^ Set new		add: MAStringDescription;		add: MAMemoDescription;		add: MASymbolDescription;		add: MAPasswordDescription;		yourself! !!MADescriptionHolder methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionValue	<magritteDescription>	^ MASingleOptionDescription new		reference: MAClassDescription new;		options: self class descriptionClasses;		selectorAccessor: 'contents';		groupBy: #grouping;		label: 'Type';		priority: 20;		yourself! !!MADescriptionHolder methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	super initialize.	self contents: self class descriptionClasses first! !!MAValueHolder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!on: anObject	^ self new contents: anObject! !!MAValueHolder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents	^ contents! !!MAValueHolder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents: anObject	contents := anObject! !!MAComposedDescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setBuiltDescription: aDescription 	| builders |	builders := self target magritteDescription descriptionBuilders.	builtDescription := aDescription.	builders do: [ :each | builtDescription := each buildFrom: builtDescription target: target model: model ]! !!MAComposedDescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitContainer: aContainer	| builders |	builders := aContainer descriptionBuilders.	builtDescription := aContainer.	builders do: [ :each | builtDescription := each buildFrom: builtDescription target: self target model: self model ]! !!MAComposedDescriptionBuilder methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitRelationDescription: aDescription	| builders buildedReference relationValue |	builders := self target magritteDescription descriptionBuilders.	buildedReference := aDescription reference.	relationValue := (target readUsing: aDescription).	relationValue ifNotNil: [ 		builders do: [ :each | buildedReference := each buildFrom: buildedReference target: relationValue model: self model ].		aDescription reference: buildedReference].	super visitRelationDescription: aDescription! !!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildFrom: aDescription target: aTarget	^ self new 		target: aTarget;		visit: aDescription;		builtDescription! !!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildFrom: aDescription target: aTarget model: aModel	^ self new 		target: aTarget;		model: aModel;		visit: aDescription;		builtDescription! !!MADescriptionBuilder class methodsFor: 'accessing defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultPriority	^0! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildFrom: aDescription target: aTarget 	self target: aTarget; visit: aDescription.	^self builtDescription! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!builtDescription	^builtDescription! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!model	^model! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!model: aModel	model := aModel! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!priority	^ priority ifNil: [ ^self class defaultPriority ]! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!priority: anObject	priority := anObject! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setBuiltDescription: aDescription 	builtDescription := aDescription! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!target	^ target! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!target: anObject	target := anObject! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitContainer: aContainer	builtDescription := aContainer copy.	builtDescription removeAll.	aContainer do: [ :each |		self visit: each copy ]! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDescription: anObject	builtDescription		ifNil: [ self setBuiltDescription: anObject]		ifNotNil: [ builtDescription add: anObject ]! !!MADescriptionFlattener methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addToBuildedDescription: aDescription for: aValue	"aValue is the intermediate value that can be processed by further expansion"	aDescription canExpand		ifTrue: [ self expandDescription: aDescription for: aValue ]		ifFalse: [ builtDescription add: aDescription ]! !!MADescriptionFlattener methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!expandDescription: aDescription for: aValue	aValue magritteDescription do: [ :each |		| val |		val := aValue readUsing: each.		each			addToAccessor: aDescription accessor;			priority: aDescription priority + (each priority / 1000).		aDescription groupExpandOnLabel			ifTrue: [ each group: aDescription label ]			ifFalse: [ each group: aDescription group ].		self addToBuildedDescription: each for: val ]! !!MADescriptionFlattener methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitToOneRelationDescription: aDescription	| sample |	aDescription canExpand ifFalse: [ ^ super visitToOneRelationDescription: aDescription ].	sample := self target isCollection		ifTrue: [			self target ifEmpty: [ ^ super visitToOneRelationDescription: aDescription ].			self target anyOne ]		ifFalse: [ self target ].	(sample readUsing: aDescription)		ifNil: [ super visitToOneRelationDescription: aDescription ]		ifNotNil: [ :value | self expandDescription: aDescription for: value ]! !!MAReader class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aStream description: aDescription	^ self new read: aStream description: aDescription! !!MAReader methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!error: aString 	MAReadError signal: aString! !!MAReader methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aStream description: aDescription	self		stream: aStream;		visit: aDescription.	^ self object! !!MAStringReader methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!nextMatchAll: aCollection on: aStream	"Tries to match ==aCollection== on ==aStream==. Answer ==true== if ==aCollection== was consumed, otherwise ==false==."	| position |	(aCollection isNil or: [ aCollection isEmpty ])		ifTrue: [ ^ false ].	position := aStream position.	aCollection do: [ :char |		(aStream atEnd or: [ aStream next ~= char ]) ifTrue: [			aStream position: position.			^ false ] ].	^ true! !!MAStringReader methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!read: aStream description: aDescription	(aStream atEnd or: [ self nextMatchAll: aDescription undefined on: aStream ])		ifTrue: [ ^ nil ].	^ super read: aStream description: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitBlockDescription: aDescription	self object: (Smalltalk compiler evaluate: self contents)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitBooleanDescription: aDescription	(aDescription trueString = self contents		or: [ aDescription trueStrings includes: self contents ])			ifTrue: [ ^ self object: true ].	(aDescription falseString = self contents		or: [ aDescription falseStrings includes: self contents ])			ifTrue: [ ^ self object: false ].	MAReadError signal! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitClassDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitColorDescription: aDescription	(self contents notEmpty and: [ self contents allSatisfy: [ :each | '#0123456789ABCDEFabcdef.' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind fromString: self contents)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitContainer: anObject	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDurationDescription: aDescription	| contents |	contents := self contents.	contents isEmpty		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents indexOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $.) > 1		ifTrue: [ MAReadError signal ].	(contents allSatisfy: [:each | '-0123456789.:' includes: each])		ifFalse: [ MAReadError signal ].	super visitDurationDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitElementDescription: aDescription	"This implementation can be very dangerous and might lead to a potential security hole (this is tested), since the default implementation of #readFrom: in Object evaluates the expression to find its value. Most subclasses like Number, Date, Time, ... override this implementation, but some others (like Boolean) do not."	self object: ([ aDescription kind readFrom: self stream ]		on: Error do: [ :err | MAReadError signal: err messageText ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitFileDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitMultipleOptionDescription: aDescription	self object: (Array streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			output nextPut: (aDescription reference				fromString: (self stream upTo: $,)).			self stream peek = Character space				ifTrue: [ self stream next ] ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitNumberDescription: aDescription	| isContentsValid |	isContentsValid := NumberParser isValidNumber: self contents.	isContentsValid ifFalse: [ MAReadError signal ].	super visitNumberDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitRelationDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitSingleOptionDescription: aDescription	aDescription propertyAt: #labels ifPresent: [ :labels |		labels keysAndValuesDo: [ :key :value |			(self nextMatchAll: value on: self stream)				ifTrue: [ ^ self object: key ] ] ].	self visit: aDescription reference! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitStringDescription: aDescription	self object: self contents! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitSymbolDescription: aDescription	self object: self contents asSymbol! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTableDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTimeDescription: aDescription	| string |	string := self contents.	(string notEmpty and: [ string allSatisfy: [ :each | '0123456789: apm' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind readFrom: string readStream)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTokenDescription: aDescription	| token |	self object: (aDescription kind streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			token := WriteStream on: String new.			[ self stream atEnd or: [ aDescription separators includes: self stream peek ] ]				whileFalse: [ token nextPut: self stream next ].			self stream atEnd 				ifFalse: [ self stream next ].			token contents isEmpty				ifFalse: [ output nextPut: (aDescription reference fromString: token contents) ] ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitUrlDescription: aDescription	self object: self contents asUrl! !!MAStreamingVisitor methodsFor: 'streaming' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents	^ self stream contents! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!object	^ object! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!object: anObject	object := anObject! !!MAStreamingVisitor methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!object: anObject during: aBlock	| previous |	previous := self object. self object: anObject.	aBlock ensure: [ self object: previous ]! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stream	^ stream! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stream: aStream	stream := aStream! !!MAStringWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultWriteStream	^ WriteStream on: String new! !!MAStringWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printObjectDescribedBy: aDescription	| string |	string := aDescription displayStringFor: self object.	self stream nextPutAll: string.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitBooleanDescription: aDescription	self stream nextPutAll: (self object		ifTrue: [ aDescription trueString ]		ifFalse: [ aDescription falseString ])! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitClassDescription: aDescription	self stream nextPutAll: self object name! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitColorDescription: aDescription	stream nextPut: $#.	stream nextPutAll: ((255 * self object red) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object green) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object blue) asInteger		printPaddedWith: $0 to: 2 base: 16)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitContainer: aDescription	aDescription do: [ :each |		each isVisible ifTrue: [			each stringWriter				write: (self object readUsing: each)				description: each to: stream.			^ self ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDateAndTimeDescription: aDescription	self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitElementDescription: aDescription 	self stream nextPutAll: self object greaseString! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitFileDescription: aDescription	self stream nextPutAll: self object filename! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitMultipleOptionDescription: aDescription	self object isEmpty		ifTrue: [ self stream nextPutAll: aDescription undefined ]		ifFalse: [			self object				do: [ :each | self stream nextPutAll: (aDescription labelForOption: each) ]				separatedBy: [ self stream nextPutAll: ', ' ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitSingleOptionDescription: aDescription	self stream nextPutAll: (aDescription labelForOption: self object)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitStringDescription: aDescription	self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTimeDescription: aDescription 		self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTimeStampDescription: aDescription	self stream print: self object asDate; space.	self stream print: self object asTime! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitToManyRelationDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: each magritteDescription ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitToOneRelationDescription: aDescription	self visit: self object magritteDescription! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTokenDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPut: aDescription separators first ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitUrlDescription: aMAUrlDescription 	self stream nextPutAll: self object asString! !!MAStringWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject description: aDescription to: aStream	anObject isNil 		ifTrue: [ aStream nextPutAll: aDescription undefined ]		ifFalse: [ super write: anObject description: aDescription to: aStream ].	^ aStream contents! !!MAWriter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject	^ self new write: anObject! !!MAWriter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject description: aDescription	^ self new write: anObject description: aDescription! !!MAWriter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject description: aDescription to: aStream	^ self new write: anObject description: aDescription to: aStream! !!MAWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultWriteStream	self subclassResponsibility! !!MAWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!error: aString 	MAWriteError signal: aString! !!MAWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject	^ self write: anObject description: anObject magritteDescription! !!MAWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject description: aDescription	^ self write: anObject description: aDescription to: self defaultWriteStream! !!MAWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject description: aDescription to: aStream	self		object: anObject;		stream: aStream;		visit: aDescription.	^ self contents! !!MAValidatorVisitor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!on: anObject description: aDescription	^ self new on: anObject description: aDescription! !!MAValidatorVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!object	"Answer the currently validated object."	^ object! !!MAValidatorVisitor methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!on: anObject description: aDescription	self use: anObject during: [ self visit: aDescription ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!use: anObject during: aBlock	| previous |	previous := object. object := anObject.	^ aBlock ensure: [ object := previous ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validate: anObject using: aDescription	aDescription validateRequired: anObject.	anObject isNil ifTrue: [ ^ self ].	aDescription		tryValidation: [ aDescription validateKind: anObject ]		ifPass: [ 			aDescription				validateSpecific: anObject;				validateConditions: anObject ]		! !!MAValidatorVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visit: aDescription	"Only visit objects that are visible and that can be changed."		(aDescription isVisible and: [ aDescription isReadOnly not ])		ifTrue: [ super visit: aDescription ].	! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitContainer: aDescription		super visitContainer: aDescription.	self object ifNotNil: [		aDescription do: [ :description |			self				use: (self object readUsing: description)				during: [ self visit: description ] ] ]! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDescription: aDescription	self validate: self object using: aDescription! !!MAVisitor class methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildVisitorHierarchyForClass: aClass selector: aBlock classified: aSelector	" self buildVisitorHierarchyForClass: MADescription selector: [ :class | 'visit' , (class name allButFirst: 2) , ':' ] classified: #'visiting-description' "	| visitSourceCode acceptSourceCode classesOwnedByMagritte |	classesOwnedByMagritte := aClass withAllSubclasses select: [ :class | class category beginsWith: 'Magritte' ].	classesOwnedByMagritte do: [ :class | | visitSelector |			visitSelector := aBlock value: class.			visitSourceCode := String streamContents: [ :stream |					stream nextPutAll: visitSelector; nextPutAll: ' anObject'; cr.					class = aClass ifFalse: [						stream tab; nextPutAll: 'self '; nextPutAll: (aBlock value: class superclass); nextPutAll: ' anObject' ] ].			self compile: visitSourceCode classified: aSelector.							acceptSourceCode := String streamContents: [ :stream |					stream nextPutAll: 'acceptMagritte: aVisitor'; cr.					stream tab; nextPutAll: 'aVisitor '; nextPutAll: visitSelector; nextPutAll: ' self' ].			class compile: acceptSourceCode classified: #visiting ]! !!MAVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visit: anObject	"Visit ==anObject== with the receiving visitor."	| errors |	errors := OrderedCollection new.	[		anObject acceptMagritte: self.	]		on: MAValidationError		do: [ :err | 			errors add: err. 			err resume ].			errors isEmpty ifFalse: [		MAMultipleErrors			description: anObject 			errors: errors			signal: anObject label ]! !!MAVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitAll: aCollection	"Visit all elements of ==aCollection== with the receiving visitor."	aCollection do: [ :each | self visit: each ]! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitBlockDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitBooleanDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitClassDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitColorDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitContainer: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDateAndTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDateDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDirectoryDescription: anObject	self visitFileDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitDurationDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitElementDescription: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitFileDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitMagnitudeDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitMemoDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitMultipleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitNumberDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitOptionDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitPasswordDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitPriorityContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitReferenceDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitRelationDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitReportContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitSingleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitStringDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitSymbolDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTableDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTableReference: anObject	^ self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTimeStampDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitToManyRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitToManyScalarRelationDescription: anObject	self visitToManyRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitToOneRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitTokenDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-descriptions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!visitUrlDescription: aMAUrlDescription 	self visitElementDescription: aMAUrlDescription! !!ManifestMagritteModel class methodsFor: 'code-critics' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!ruleRBBadMessageRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Object #maLazyFrom: #false)) #'2019-03-23T09:33:42.523345-04:00') )! !!Class methodsFor: '*magritte-model-configuration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionContainer	"Return the default description container."	<magritteContainer>	^ MAPriorityContainer new		label: self label;		yourself! !!Class methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	"Answer a human-readable name of the receiving class. This implementation tries to be smart and return a nice label, unfortunately for a lot of classes this doesn't work well so subclasses might want to override this method and return soemthing more meaningfull to end-users."	| start input |	start := self name findFirst: [ :each | each isLowercase ].	input := (self name copyFrom: (1 max: start - 1) to: self name size)		readStream.	^ String streamContents: [ :stream |		[ input atEnd ] whileFalse: [			stream nextPut: input next.			(input atEnd or: [ input peek isLowercase ])				ifFalse: [ stream nextPut: Character space ] ] ]! !!MADynamicDescriptionCache class methodsFor: 'defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultValue	^ IdentityDictionary new! !!MADynamicVariable class methodsFor: 'defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultValue	^ nil! !!MADynamicVariable class methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!use: anObject during: aBlock	"Set the dynamic value of the receiver to anObject during the evaluation of aBlock."		^ aBlock on: self do: [ :notification | notification resume: anObject ]! !!MADynamicVariable class methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value	"Answer the dynamic value of the receiver."		^ self signal! !!MADynamicVariable methodsFor: 'defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultAction	^ self class defaultValue! !!WriteStream methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maPrint: anMADescription for: anObject	anMADescription printFor: anObject on: self		"# Motivation: Printing ConvenienceTypically, `#printOn:` and friends have a lot of nil checks sprinkled around. Modern Pharo's tools are typically robust to printString errors, but you still get a not-very-helpful ""error printing"" message. Here comes Magritte to the rescue with `WriteStream >> #maPrint:for:`. Here's an example:```smalltalkprintOn: aStream	aStream 		maPrint: self descriptionDescription for: self;		nextPutAll: 'whatever'.```This reads the value and behaves gracefully if it is unset (by doing nothing). Notice that it also fits into the typical cascade without breaking it into multiple statements.Without this the options are not as nice...## Old (Typical) PatternNil checks everywhere...```smalltalkprintOn: aStream	description ifNotNil: [ :desc | aStream nextPutAll: desc ]	""repeated for each relevant field""```## Naive Magritte FixYou might just supply a reasonable default value for each description, like:```smalltalkdescriptionDescription	<magritteDescription>	^ MAStringDescription new		accessor: #description;		default: '';		yourself```which allows you to simplify to:```smalltalkprintOn: aStream	aStream nextPutAll: self description.```However, that requires cluttering descriptions with default values which may not fit the domain."! !!Dictionary methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!optionFor: anObject ifPresent: aBlock	self at: anObject ifPresent: aBlock! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteAllSubInstancesOf: aClass do: aBlock	"Evaluate the aBlock for all instances of aClass and all its subclasses."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteClassNamed: aString	"Return the class named aString, nil if the class can't be found."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteColorClass	"Return a Color class"		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteEvaluatorClassFor: aClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteTimeStampClass	"Return the platform's TimeStamp class. It is currently assumed that all platforms	have one, though this may not be correct and could require moving timestamp stuff	to its own package in order to resolve."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteUniqueObject	"Answer a random object, such as a UUID, that is extremely likely to	be unique over space and time."		self subclassResponsibility! !!Symbol methodsFor: '*magritte-model-converting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asAccessor	^ MASelectorAccessor selector: self! !!Symbol methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!optionFor: anObject ifPresent: aBlock	aBlock value: (anObject perform: self)! !!NumberParser class methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isValidNumber: aStringOrStream	| stream parser |	stream := aStringOrStream readStream.	parser := (Smalltalk at: #ExtendedNumberParser ifAbsent: [self]).	parser parse: stream onError: [ ^ false ].	^ stream atEnd! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asAccessor	^ MAChainAccessor accessors: self! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!moveDown: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := (first > 0 and: [ first < self size ])		ifTrue: [ first + 1 ]		ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!moveUp: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := first > 1 ifTrue: [ first - 1 ] ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!MAMultipleErrors class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!description: aDescription errors: aCollection signal: aString 	^ self new		setDescription: aDescription;		setCollection: aCollection;		signal: aString;		yourself! !!MAMultipleErrors methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!collection	^ collection! !!MAMultipleErrors methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printOn: aStream	self collection		do: [ :each | aStream print: each ]		separatedBy: [ aStream nextPut: Character cr ]! !!MAMultipleErrors methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setCollection: aCollection	collection := aCollection! !!MAValidationError class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!description: aDescription signal: aString 	^ self new		setDescription: aDescription;		signal: aString;		yourself! !!MAValidationError methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isResumable	^ true! !!MAValidationError methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printOn: aStream	(self tag isDescription and: [ self tag label notNil ])		ifTrue: [ aStream nextPutAll: self tag label greaseString; nextPutAll: ': ' ].	aStream nextPutAll: self messageText greaseString ! !!MAValidationError methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setDescription: aDescription	self tag: aDescription! !!UndefinedObject methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asAccessor	^ MANullAccessor new! !!UndefinedObject methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ 'n/a'! !!UndefinedObject methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescription	^ MAContainer new! !!GRPackage class methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteModel	^ self new		name: 'Magritte-Model';		description: 'The Magritte metamodel.';		addDependency: 'Grease-Core';		url: #magritteUrl;		yourself! !!GRPackage methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteUrl	^ 'http://source.lukas-renggli.ch/magritte2'! !!Integer methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asFileSize	#( 'B' 'KB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB' )		inject: self		into: [ :value :each |			value < 1024				ifFalse: [ value // 1024 ]				ifTrue: [ ^ value asString , ' ' , each ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asMultilineString	^ String streamContents: [ :stream |		self			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream nextPut: Character cr ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyWithAll: aCollection	^ self copy		addAll: aCollection;		yourself! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyWithoutFirst: anObject	| done |	done := false.	^ self reject: [ :each |		(each = anObject			and: [ done not ])				and: [ done := true ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyWithoutFirstOccurrenceOf: anObject	| done |	done := false.	^ self reject: [ :each |		each = anObject			and: [ done not			and: [ done := true ] ] ]! !!Collection methodsFor: '*magritte-model-dynopt' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maAllOptionsFor: aDescription	^ aDescription prepareOptions: self copy! !!Collection methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maSelectMatching: aString 	^ self select: [ :e | e asString startsWith: aString ]! !!ArrayedCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!copyWithAll: aCollection	^ (self species new: self size + aCollection size)		replaceFrom: 1 to: self size with: self startingAt: 1;		replaceFrom: self size + 1 to: self size + aCollection size with: aCollection startingAt: 1;		yourself! !!MAActionDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maPragma	"Annotate constructor methods with this pragma to get picked up by Magritte; similar to #magritteDescription"	^ #magritteActionDescription! !!MAActionDescription methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!<= anObject	^ self priority <= anObject priority! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!action	^ action! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!action: aValuable	action := aValuable.! !!MAActionDescription methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asGlmAction	| result |	result := GLMGenericAction new			action: [ :pres :receiver | 				self performOn: receiver.				self isMutator ifTrue: [ pres update ] ];			enabledCondition: self enableBlock;			help: self comment;			shortcut: self shortcut;			title: self label;			yourself.		"Glamour doesn't like setting a nil icon!!"	self icon ifNotNil: [ :i | result icon: i ].	^ result			! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!comment	^ comment! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!comment: aString	comment := aString.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!enableBlock	^ [ true ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!enableBlock: aBlock	"aBlock		- one argument (optional); the model object		- returns a boolean indicating whether the button should be enabled"		enableBlock := aBlock.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!icon	^ icon ifNotNil: [ self iconNamed: icon ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!icon: aSymbol	"Browse available via `Smalltalk ui icons`"	icon := aSymbol! !!MAActionDescription methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	super initialize.	enableBlock := [ true ].! !!MAActionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isEnabled	^ enableBlock cull: model.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isMutator	^ isMutator ifNil: [ true ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isMutator: anObject	"Does the action I describe potentially change the object it acts on?"	isMutator := anObject! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label	^ label ifNil: [ action asString capitalized normalizeCamelCase ].! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!label: aString	label := aString.! !!MAActionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!performOn: aModel	action cull: aModel.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' label: '; print: self label.	aStream nextPutAll: ' comment: '; print: self comment! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!priority	^ priority ifNil: [ 0 ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!priority: anInteger 	priority := anInteger.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector	self 		deprecated: 'Renamed to #action because now accepts any valuable as an action (e.g. aBlock).'		on: '10/24/2017'		in: #Pharo61		transformWith: '`@receiver selector' 						-> '`@receiver action'.	^ self action! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selector: aValuable		self 		deprecated: 'Renamed to #action: because now accepts any valuable as an action (e.g. aBlock).'		on: '10/24/2017'		in: #Pharo61		transformWith: '`@receiver selector: `@arg' 						-> '`@receiver action: `@arg'.	self action: aValuable.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!shortcut	^ shortcut! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!shortcut: anObject	shortcut := anObject! !!MADynamicOptions class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!block: aBlock	^ self new			block: aBlock;			yourself.! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!block	^ block! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!block: aBlock	block := aBlock! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!detect: anObject	"Convert from a possibly-optimized object for entry-completion, to the object that should be saved"	^ self reader value: anObject! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!includes: anObject	^ includesBlock value: anObject! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!includesBlock	^ includesBlock! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!includesBlock: aBlock	includesBlock := aBlock! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maAllOptionsFor: anOptionDescription 	^ self! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maSelectMatching: aString 	^ self block value: aString! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reader	^ completionToObjectBlock ifNil: [ [ :obj | obj ] ]! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reader: aBlock	completionToObjectBlock := aBlock! !!Object class methodsFor: '*magritte-model-description' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteTemplate	"Allow subclasses to have a prototype instance for creating a Magritte description (especially reference description)."	^self new! !!Object methodsFor: '*magritte-model-accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!basicMagritteDescription	^ MAPragmaBuilder for: self! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionContainer	"Return the default description container."	<magritteContainer>	^ MAPriorityContainer new		label: self class label;		yourself! !!Object methodsFor: '*magritte-model-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initializeMagritte	"Initializes the receiving object with the default values of its description."	self magritteDescription do: [ :each |		each isReadOnly			ifFalse: [ self write: each default using: each ] ]! !!Object methodsFor: '*magritte-model-testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isDescription	^ false! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSameAs: rhs	^ self isSameAs: rhs using: [ self magritteDescription ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isSameAs: rhs using: valuableDescription	"Use #isSameAs: unless you need to cache the description for efficiency.	CAUTION: this may not work if the description depends on the instance e.g. uses `self` in a block	(See comment below for more details)"	^ valuableDescription value allSatisfy: [ :desc |			| myVal rhsVal |			(desc accessor canRead: rhs)				ifFalse: [ false ]				ifTrue: [					myVal := desc read: self.					rhsVal := desc read: rhs.					({ nil. desc default } includesAll: { myVal. rhsVal })						ifTrue: [ true ]						ifFalse: [ myVal = rhsVal ] ] ].	"Motivation: We cache the description because profiling on a large dataset (120,000 records) showed about 66% of processing time was spent (re)building it"! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maHash	^ self maHashUsing: [ self magritteDescription ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maHashUsing: valuabledescription	"See isSameAs:using: comments"	^ valuabledescription value children 			inject: 0 hash 			into: [ :hash :desc | hash bitXor: (desc read: self) hash ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maLazyFrom: description	"Return the current value of a field as specified by its description		- NB: Only works with a selector accessor with matching inst var name e.g. (readSelector = instVarName = #myField). It could be extended to other cases if the need arises.		- The default value is cached if the description's #shouldCacheDefault property is true. An example when caching is necessary is for to-many relations because the user may modify the collection, which will then be thrown away if not cached	Usage: 		MyDomainObject>>#getter			^ self maLazyFrom: self descriptionName				MyDomainObject>>#descriptionName			^ MAStringDescription new					accessor: #name;					default: 'Alan';					yourself"	| currentValue defaultValue |	currentValue := self instVarNamed: description accessor readSelector.	currentValue ifNotNil: [ ^ currentValue ].	defaultValue := description default.	description shouldCacheDefault ifTrue: [ self write: defaultValue using: description ].	^ defaultValue.! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maPrintOn: aStream	"Print the current values of all described fields. Customize the printing of a field with the #maPrintString property, which should store a valuable with the value of the field as an optional argument"		self magritteDescription		do: [ :d | 			| value |			value := d read: self.			value ifNotNil: [ 				| stringValue |				stringValue := d 					propertyAt: #maPrintString					ifPresent: [ :map | map cull: value ]					ifAbsent: [ d toString: value ].				aStream nextPutAll: stringValue ] ]		separatedBy: [ aStream space ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maValidate	^ self magritteDescription validate: self! !!Object methodsFor: '*magritte-model-actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteActionDescriptions	^ self uniqueActionSelectors collect: [ :each | self perform: each ] as: SortedCollection! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteAllDescriptionsFor: aDescriptionSelector	"Experiment: What if our object has a field that can be thought of in different ways? For example, a messages field that can be filtered into #read, #unread, and #all. #descriptionMessages would be the actual description, and then there could be a #descriptionUnreadMessages and #descriptionReadMessages which are dcescriptions of the filtered collections. By annotating these alternate descriptions with <magritteAltFor: #descriptionMessages>, these could be e.g. displayed as tabs in a Magritte form"		^ OrderedCollection new			add: (self perform: aDescriptionSelector);			addAll: (self magritteAlternatesFor: aDescriptionSelector);			sort;			yourself! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteAlternatesFor: aDescriptionSelector	| altDescriptionMethods relevantDescMeths |	altDescriptionMethods := Pragma		allNamed: #magritteAltFor:		from: self class		to: Object.	relevantDescMeths := altDescriptionMethods select: [ :p | p arguments first = aDescriptionSelector ].	^ relevantDescMeths collect: [ :m | self perform: m method selector ]! !!Object methodsFor: '*magritte-model-builder' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescription	|basicDescription builders|	basicDescription := self basicMagritteDescription.	builders := self magritteDescriptionBuilders.	builders ifNotNil: [^builders buildFrom: basicDescription target: self].	^basicDescription! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescriptionBuilders	|builderPragmas container|	builderPragmas := Pragma allNamed: #magritteBuilder from: self class to: Object.	builderPragmas ifEmpty: [ ^nil ].	container := QCDescriptionBuilderContainer new.	builderPragmas do: [ :pragma |		|bld |		pragma method numArgs = 0 ifTrue: [ 			bld := self perform: pragma method selector.			bld ifNotNil: [ container add: bld ] ] ].	^container! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!mementoClass	"Return a class to be used to remember or cache the receiver, namely a memento object."	^ MACheckedMemento! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readUsing: aDescription	"Dispatch the read-access to the receiver using the accessor of aDescription."	^ aDescription accessor read: self! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uniqueActionSelectors	| descriptionPragmas selectors |		descriptionPragmas := Pragma 		allNamed: MAActionDescription maPragma		from: self class to: Object.			selectors := descriptionPragmas collect: [ :each | each method selector ].		^ Set withAll: selectors! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!write: anObject using: aDescription	"Dispatch the write-access to the receiver of anObject using the accessor of aDescription."	aDescription accessor write: anObject to: self! !!BlockClosure methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!optionFor: anObject ifPresent: aBlock	aBlock value: (self cull: anObject)! !!String methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!matches: aString	aString isEmpty ifTrue: [ ^ true ].	^ (aString includesAnyOf: '*#')		ifTrue: [ aString match: self ]		ifFalse: [ self includesSubstring: aString caseSensitive: false ]! !!String methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!normalizeCamelCase	^ self class streamContents: [ :out |		self do: [ :e |			(e isUppercase and: [ out position > 0 ]) ifTrue: [ out nextPut: Character space ].			out nextPut: e ] ]! !"Magritte-Model"!!MAExternalFileModel commentStamp: '<historical>' prior: 0!I manage the file-data I represent on the file-system. From the programmer this looks the same as if the file would be in memory (==*MAMemoryFileModel*==), as it is transparently loaded and written out as necessary.I delegate my actual location on disk to MAFileDatabase (see class comment).!!MAFileDatabase commentStamp: '<historical>' prior: 0!I provide locations for external files.- The ==#baseDirectory== is the place where Magritte puts its file-database. Keep this value to nil to make it default to a subdirectory next to the Smalltalk image.- The ==#baseUrl== is a nice optimization to allow Apache (or any other Web Server) to directly serve the files. ==#baseUrl== is an absolute URL-prefix that is used to generate the path to the file. If you have specified one the file data does not go trough the image anymore, but instead is directly served trough the properly configured Web Server.The files are currently stored using the following scheme:=/files/9d/bsy8kyp45g0q7blphknk48zujap2wd/earthmap1k.jpg=1     2   3                            						  41. is the #baseDirectory as specified in the settings.2. Are 256 directories named '00' to 'ff' to avoid having thousands of files in the same directory. Unfortunately this leads to problems with the Squeak file primitives and some filesystems don't handle that well. This part is generated at random.3. This is a secure ID, similar to the Seaside session key. It is generated at random and provides a security system that even works through Apache (you have to disable directory listings of course): if you don't know the filename you can not access the file.4. This is the original filename. Subclasses might want to store other cached versions of the same file there, for example resized images, etc.!!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseDirectoryPath	" deprecated: use MAFileDatabase baseDirectoryPath instead "	^MAFileDatabase baseDirectory fullName! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseDirectoryPath: aString 	" deprecated, but still used by pier "	MAFileDatabase baseDirectory: aString! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseUrl	" deprecated: use MAFileDatabase baseDirectoryPath instead "	^ MAFileDatabase baseUrl! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseUrl: aString	" deprecated: use MAFileDatabase baseUrl instead "	^ MAFileDatabase baseUrl: aString! !!MAExternalFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!= anObject    ^ super = anObject and: [ self directory = anObject directory ]! !!MAExternalFileModel methodsFor: 'configuration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseUrl	^ self database baseUrl! !!MAExternalFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents	| stream |	^ self file exists		ifFalse: [ ByteArray new ]		ifTrue: [			stream := self readStream.			[ stream contents ]				ensure: [ stream close ] ]! !!MAExternalFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contents: aByteArray	| stream |	stream := self writeStream.	[ stream nextPutAll: aByteArray asByteArray ]		ensure: [ stream close ].	super contents: aByteArray! !!MAExternalFileModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!database	^ MAFileDatabase new.! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!directory	^ directory ifNil: [ directory := self database uniqueLocation ].! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!file	^(self directory / self filename) asFileReference! !!MAExternalFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!finalize	|  dir |	dir := self directory.	dir exists		ifTrue: [ dir deleteAll ].	[ (dir := dir parent) hasChildren ]		whileFalse: [ dir ensureDelete ].	super finalize.	location := nil! !!MAExternalFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!hash	^ super hash bitXor: self directory hash! !!MAExternalFileModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!postCopy	| previous |	super postCopy.	previous := self contents.	location := nil.	self contents: previous! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readStream	^ self file binaryReadStream ! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!writeStream	^ self file binaryWriteStream ! !!MorphicUIManager methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!chooseFile: windowTitle in: directoryString	| chooser |	chooser := FileDialogWindow newWithTheme: Smalltalk ui theme.	chooser		title: windowTitle;		selectDirectory: directoryString;		answerFileEntry.	^ chooser openModal answer		ifNotNil: [ :answer | answer asFileReference ]! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteAllSubInstancesOf: aClass do: aBlock	"Evaluate the aBlock for all instances of aClass and all its subclasses."	aClass allSubInstancesDo: aBlock! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteClassNamed: aString	"Return the class named aString, nil if the class can't be found."	^ Smalltalk classNamed: aString! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteColorClass	"Return a Color class"		^ Color! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteEvaluatorClassFor: aClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."		^ aClass compilerClass! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteTimeStampClass	"Return the platform's TimeStamp class. It is currently assumed that all platforms	have one, though this may not be correct and could require moving timestamp stuff	to its own package in order to resolve."		^ DateAndTime! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteTimeStampIfAbsent: absentBlock	"Return the TimeStamp class, or if the platform does not have a TimeStamp	return the result of evaluating absentBlock."		^ DateAndTime! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteUniqueObject	"Answer a random object, such as a UUID, that is extremely likely to	be unique over space and time."	^ ByteArray withAll: UUID new! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseDirectory	^ baseDirectory ifNil: [ FileLocator imageDirectory / 'files' ].! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseDirectory: aStringOrDirectory	"Defines where the files are stored. If this value is set to nil, it defaults to a subdirectory of of the current image-location."	baseDirectory := aStringOrDirectory asFileReference.! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseUrl	^ baseUrl! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseUrl: aString	"Defines the base-URL where the files are served from, when using an external web server. This setting is left to nil by default, causing the files to be served trough the image."	baseUrl := aString isNil ifFalse: [		aString last = $/			ifFalse: [ aString ]			ifTrue: [ aString copyUpToLast: $/ ] ]! !!MAFileDatabase class methodsFor: 'public' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!garbageCollect	"Remove obsolete files from the file-system that are not referenced from the image anymore. This method has to be called manually and is not intended to be portable."		| mark sweep |	mark := self allInstances		collect: [ :each | each directory ].	sweep := Array with: self baseDirectory.	self locationDefinition do: [ :definition |		sweep := sweep gather: [ :directory |			directory hasChildren ifFalse: [ directory delete ].			FileLocator imageDirectory directories select: [ :e | e basename size = definition first ] ] ].	sweep do: [ :directory |		(mark includes: directory) ifFalse: [ directory recursiveDelete ] ]! !!MAFileDatabase class methodsFor: 'public' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!locationDefinition	^ #( ( 2 '63450af8d9c2e17b' ) ( 30 'iaojv41bw67e0tud5m9rgplqfy8x3cs2kznh' ) )! !!MAFileDatabase methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseDirectory	^ self class baseDirectory.! !!MAFileDatabase methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseUrl	^ self class baseUrl.! !!MAFileDatabase methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!randomIdentifierName	| digits idLength allowedCharacters |	digits := $0 to: $9.	allowedCharacters := digits, Character alphabet.	idLength := 30.	^ String streamContents: [ :str |		idLength timesRepeat: [ str nextPut: allowedCharacters atRandom ] ].! !!MAFileDatabase methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!randomPartitionFolderName	"Returns a string between '00' to 'FF'"	| twoCharacterHexString |	twoCharacterHexString := 16rFF atRandom printStringBase: 16 length: 2 padded: true.	^ twoCharacterHexString asLowercase.! !!MAFileDatabase methodsFor: 'public' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!uniqueLocation	"Finds an unique path to be used and create the necessary sub directories."	| partition id result |	[		partition := self randomPartitionFolderName.		id := self randomIdentifierName.		result := self baseDirectory ensureCreateDirectory / partition / id.	] doWhileTrue: [ result exists ].		^ result ensureCreateDirectory.! !!MAFileSystem class methodsFor: 'paths' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!extensionFor: aString 	^ aString asFileReference extension.! !!MAFileSystem class methodsFor: 'entries' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fileSizeFor: filenameString 	^ filenameString asFileReference size! !!MAFileSystem class methodsFor: 'paths' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!fullNameFor: aString 	^ aString asFileReference fullName.! !!MAFileSystem class methodsFor: 'locations' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!imageDirectory	^ FileLocator imageDirectory.! !!MAFileSystem class methodsFor: 'mime types' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!mimeTypesForExtension: aString 	| types |	types := MIMEType forExtensionReturnMimeTypesOrNil: aString.	^ types ifNotNil: [ types collect: [ :e | e asString ] ].! !!GRPackage class methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magrittePharoModel	^ self new		name: 'Magritte-Pharo-Model';		addDependency: 'Magritte-Model';		url: #magritteUrl;		yourself! !"Magritte-Pharo7-Model"!!MADescription class methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultReadonly	self 		deprecated: 'Use #defaultReadOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver defaultReadonly' 						-> '`@receiver defaultReadOnly'.	^ self defaultReadOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!beReadonly	self 		deprecated: 'Use #beReadOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver beReadonly' 						-> '`@receiver beReadOnly'.		^ self beReadOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isReadonly	self 		deprecated: 'Use #isReadOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver isReadonly' 						-> '`@receiver isReadOnly'.	^ self isReadOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readonly	self 		deprecated: 'Use #readOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver readonly' 						-> '`@receiver readOnly'.		^ self readOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!readonly: aBoolean	self 		deprecated: 'Use #readOnly: instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver readonly:' 						-> '`@receiver readOnly:'.		^ self readOnly: aBoolean! !!MASilentContainerMorph commentStamp: 'tg 5/6/2009 13:26' prior: 0!The only difference to the superclass is that on answer it does not delete the morph. This is useful when we want the morph to be embedded.!!MAElementRow class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addMorphFor: anObject of: aDescriptionMorph to: aMorph	| instance |	instance := self for: anObject of: aDescriptionMorph.	aMorph addMorphBack: instance.! !!MAElementRow class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!for: anObject of: aDescriptionMorph	^ self basicNew		object: anObject;		container: aDescriptionMorph;		initialize.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildButton: aSymbol	^ Smalltalk ui theme builder		newButtonFor: self		action: aSymbol		label: aSymbol capitalized		help: ''! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildCommands	| commands |	commands := self rectangleMorph		listDirection: #leftToRight;		cellInset: self cellInset;		yourself.	container magritteDescription isDefinitive ifFalse: [		commands			addMorphBack: (self buildButton: #edit);			addMorphBack: (self buildButton: #remove) ].	container magritteDescription isOrdered ifTrue: [		self shouldBeImplemented.		"commands			addCommandOn: self selector: #up: text: 'up';			addCommandOn: self selector: #down: text: 'down'" ].	^ commands! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!cellInset	^ 4@4.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!container: aDescriptionMorph	container := aDescriptionMorph! !!MAElementRow methodsFor: 'callbacks' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!edit	object asMagritteMorph		onAnswer: [ :result | self summary: result printString ];		addButtons;		addWindow;		openInWorld.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	super initialize.	self		borderWidth: 0;		color: Color transparent;		layoutPolicy: TableLayout new;		cellPositioning: #topLeft;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		listDirection: #leftToRight;		cellInset: self cellInset;		layoutInset: 0@2.	self		addMorphBack: (container magritteDescription displayStringFor: object) asMorph;		addMorphBack: self buildCommands! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!object: anObject	object := anObject! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rectangleMorph	^ MADescriptionMorph new rectangleMorph.! !!MAElementRow methodsFor: 'callbacks' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!remove	container remove: object.	self owner addMorph: container buildSelectList.	self delete.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!summary: aString	submorphs first contents: aString! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value	^ self memento readUsing: self magritteDescription! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value: anObject	self memento write: anObject using: self magritteDescription! !!MAContainerMorph methodsFor: 'decorating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addButtons	self addButtons: #( save cancel )! !!MAContainerMorph methodsFor: 'decorating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addButtons: anArray	morph := self rectangleMorph		addMorphBack: self morph;		addMorphBack: (self barMorph: anArray);		yourself! !!MAContainerMorph methodsFor: 'decorating' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addWindow	| scrollPane newMorph |	scrollPane := GeneralScrollPane new.	newMorph := self morph 		vResizing: #spaceFill;		hResizing: #spaceFill.	scrollPane changeScrollerTableLayout; scrollTarget: newMorph.		morph := self windowMorph		model: self;		vResizing: #shrinkWrap;		addMorph: (scrollPane layoutInset: 5 @ 5)			frame: (0 @ 0 corner: 1 @ 1);		yourself! !!MAContainerMorph methodsFor: 'answering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!answer: anObject	| didUserCancel |	self morph delete.		didUserCancel := anObject isNil.	didUserCancel | answerBlock isNil ifTrue: [ ^ self ].	answerBlock value: anObject.! !!MAContainerMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildChildren	^ Array streamContents: [ :stream |		self magritteDescription do: [ :each |			each isVisible ifTrue: [				stream nextPut: (each morphClass					memento: self memento					description: each					parent: self) ] ] ]! !!MAContainerMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphViewOn: aMorph	| toolbar |	aMorph		listDirection: #topToBottom;		cellInset: 3.	self children do: [ :each |		aMorph addMorphBack: each morph ].	toolbar := self rectangleMorph		listDirection: #leftToRight;		cellInset: 4@0;		layoutInset: 4@4;		yourself.	self model magritteActionButtons do: [ :e | toolbar addMorphBack: e ].	aMorph addMorphBack: toolbar.		! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!callInHand	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInHand; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!callInWorld	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInWorld; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!cancel	self reset; answer: nil! !!MAContainerMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!children	^ children! !!MAContainerMorph methodsFor: 'error handling' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!doesNotUnderstand: aMessage	"Forward callbacks from #addButtons: to the model if appropriate"	(self model respondsTo: aMessage selector)		ifTrue: [ self model perform: aMessage selector ]		ifFalse: [ super doesNotUnderstand: aMessage ].! !!MAContainerMorph methodsFor: 'answering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!onAnswer: aBlock	answerBlock := aBlock! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!openInHand	^ self morph openInHand! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!openInWindow	^ self		addWindow;		openInWorld.! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!openInWorld	^ self morph openInWorld! !!MAContainerMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!save	[ self validate ]		on: MAValidationError		do: [ :err | ^ self inform: err greaseString ].	self commit; answer: self model! !!MAContainerMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setChildren: aCollection	children := aCollection! !!MAContainerMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setDescription: aDescription	super setDescription: aDescription.	self setChildren: self buildChildren! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!waitUntilClosed	[ self morph world notNil ]		whileTrue: [ self morph outermostWorldMorph doOneCycle ]! !!MASilentContainerMorph methodsFor: 'answering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!answer: anObject	answerBlock isNil		ifFalse: [ answerBlock value: anObject ].! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!memento: aMemento	^ self memento: aMemento description: aMemento magritteDescription! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!memento: aMemento description: aDescription	^ self memento: aMemento description: aDescription parent: nil! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!memento: aMemento description: aDescription parent: aComponent	^ self new		setMemento: aMemento;		setDescription: aDescription;		setParent: aComponent;		yourself! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!barMorph: anArray	| bar |	bar := self rectangleMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		listCentering: #center;		wrapCentering: #bottomRight;		cellInset: self defaultSpacerSize;		yourself.	anArray do: [ :selector |		bar addMorphBack: (self buttonMorph: selector) ].	^ bar! !!MADescriptionMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorph	| result |	result := self rectangleMorph		setBalloonText: self magritteDescription comment;		yourself.	self magritteDescription isReadOnly		ifTrue: [ self buildMorphViewOn: result ]		ifFalse: [ self buildMorphEditorOn: result ].	^ result! !!MADescriptionMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphEditorOn: aMorph	self buildMorphViewOn: aMorph! !!MADescriptionMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphViewOn: aMorph	self subclassResponsibility! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buttonMorph: aSelector	| button |	button := PluggableButtonMorph		on: self		getState: #buttonState		action: aSelector.	button		label: aSelector;		hResizing: #spaceFill;		shortcutCharacter: aSelector first.	^ button! !!MADescriptionMorph methodsFor: 'private-morphic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buttonState	^ true! !!MADescriptionMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!commit	self memento commit! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultBackgroundColor	^ self magritteDescription morphColor! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultSpacerSize	^ 5! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescription	^ description! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!memento	^ memento! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!model	^ self memento model! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!morph	^ morph ifNil: [ morph := self buildMorph ]! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!parent	^ parent! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!rectangleMorph	^ BorderedMorph new		borderWidth: 0;		color: Color transparent;		layoutPolicy: TableLayout new;		cellPositioning: #topLeft;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		yourself! !!MADescriptionMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reset	self memento reset! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!root	^ self parent isNil		ifTrue: [ self ]		ifFalse: [ self parent root ]! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setDescription: aDescription	description := aDescription! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setMemento: aMemento	memento := aMemento! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!setParent: aMorph	parent := aMorph! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringMorph	^ StringMorph new! !!MADescriptionMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!validate	"Flushes the cached state of some morphic elements (such as text-morphs) to the memento and then does the validation. I don't know of a better flush the morphic contents (happy flickering), probably morphic is just too limited to customize that easily or I am too dumb to find out."	self morph allMorphsDo: [ :each |		(each respondsTo: #accept)			ifTrue: [ each accept ] ].	self memento validate! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!windowMorph	^ SystemWindow labelled: self magritteDescription label! !!MACheckboxMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	^ Smalltalk ui theme		newCheckboxIn: nil		for: self		getSelected: #selected		setSelected: #selected:		getEnabled: #enabled		label: ''		help: self magritteDescription comment! !!MACheckboxMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!enabled	^ true! !!MACheckboxMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected	^ (self value ifNil: [ self magritteDescription default ]) ifNil: [ false ]! !!MACheckboxMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected: aBoolean	self value: aBoolean ! !!MADateMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	| model |	model := DateModel new		displayBlock: [ :e | description displayStringFor: e ];		date: self value;		whenDateChanged: [ :newDate | self value: newDate ];		yourself.	^ model buildWithSpec			yourself.! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphLabel	^ self stringMorph		contents: self magritteDescription label , ':';		width: 100;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphRequired	^ self stringMorph		contents: ' *';		color: Color red;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	^ self stringMorph		contents: self string;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphViewOn: aMorph	aMorph		layoutInset: 1 @ 1;		listDirection: #leftToRight;		addMorphBack: self buildMorphLabel;		addMorphBack: self buildMorphView.	self magritteDescription hasComment		ifTrue: [ aMorph setBalloonText: self magritteDescription comment ].	self magritteDescription isRequired		ifTrue: [ aMorph addMorphBack: self buildMorphRequired ]! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!string	^ self magritteDescription toString: self value! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!string: aString	| value |	value := self magritteDescription fromString: aString greaseString.	self value: value; changed: #string! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value	^ self memento readUsing: self magritteDescription! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!value: anObject	self memento write: anObject using: self magritteDescription.	self changed: #value! !!MADirectoryMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!choose: titleString in: defaultDirectory	^ UIManager default chooseDirectory: titleString from: defaultDirectory.! !!MAFileMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	| button |	rectangleMorph := self rectangleMorph		listDirection: #leftToRight;		yourself.	button := self buttonMorph: #choose.	button		hResizing: #shrinkWrap.	rectangleMorph addMorphBack: button.	self value ifNotNil: [ self displayCurrentValue ].	^ rectangleMorph.! !!MAFileMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!choose	| file |	file := self		choose: 'Choose ', self magritteDescription label		in: self magritteDescription defaultDirectory. 	file ifNil: [ ^ self ].	self value: file.	self displayCurrentValue.! !!MAFileMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!choose: titleString in: defaultDirectory	^ UIManager default chooseFile: titleString in: defaultDirectory.	"We're using UIManager apparently for two reasons:		1. To maintain compatibility between Pharo and Squeak.		2. If this is a Seaside app, we may be headless	However, none of the Squeak/Pharo common UIManager API does what's needed e.g. to specify a starting folder. So I'm implementing the #chooseFile:in: for headful Pharo. At such time when someone tries in another scenario i.e. headless/Squeak, we have an entry point to implement support for those"! !!MAFileMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!currentValueMorph	| exists |	exists := rectangleMorph submorphs size = 2.	exists ifFalse: [ rectangleMorph addMorph: StringMorph new ].	^ rectangleMorph submorphs first.! !!MAFileMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!displayCurrentValue	| displayString |	displayString := description displayStringFor: self value.	self currentValueMorph contents: displayString.! !!MADropListMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView		| list |	list := DropListModel new.	list		items: self options;		displayBlock: [ :e | 			e				ifNil: [ '' ]				ifNotNil: [ self magritteDescription reference toString: e ] ];		setSelectedItem: self value;		whenSelectedItemChanged: [ :e | self value: e ].		^ list buildWithSpec.! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!options	^ self magritteDescription allOptions! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!strings	^ self options collect: [ :each | self magritteDescription reference toString: each ]! !!MAMultiSelectListMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorph			^ super buildMorph.! !!MAMultiSelectListMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	^ (PluggableListMorph on: self list: #strings primarySelection: #selected changePrimarySelection: #selected: listSelection: #selectionAt: changeListSelection: #selectionAt:put: menu: nil)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 1;		beMultipleSelection;		yourself! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected	^ selected ifNil: [ selected := 0 ]! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected: anInteger	selected := anInteger.	self changed: #selected! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selectionAt: anInteger	^ self value includes: (self options at: anInteger)! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selectionAt: anInteger put: aBoolean	| option |	option := self options at: anInteger.	self value: (aBoolean		ifTrue: [ self value copyWith: option ]		ifFalse: [ self value copyWithout: option ]).	self changed: #selected! !!MASingleSelectListMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	^ (PluggableListMorph on: self list: #strings selected: #selected changeSelected: #selected:)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 1;		yourself! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected	^ self options indexOf: self value! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected: anInteger	self value: (self options at: anInteger ifAbsent: [ nil ]).	self changed: #selected! !!MATokenCompletionMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	self flag: 'Obviously, the inline conditionals are horrifying. I think the nil check will go away if we set a default value'.	^ TokenCollectorMorph new			hResizing: #spaceFill;			vResizing: #rigid;			borderColor: #inset;			borderWidth: 1;			options: self options;			objects: (self magritteDescription isMultiple				ifTrue: [ self value copy ]				ifFalse: [ self value copy ifNotNil: [ :v | { v } ] ifNil: [ OrderedCollection new ] ]);			whenObjectsChanged: [ :e | 				self magritteDescription isMultiple					ifTrue: [ self value: e ]					ifFalse: [ self value: e first ] ];			factory: self magritteDescription initializer;			height: 150;			yourself! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!annotation	^ self string! !!MAMemoMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	"The selector #annotation should be #string instead, but we use this one and dispatch since this prevents morphic to draw a thin red border around changed fields. Stupid hack, really, but doesn't work otherwise."	| result lineSpacingFactor height |	result := RubPluggableTextMorph on: self text: #annotation accept: #string: readSelection: nil menu: nil.		"We want to set the height to honor the #lineCount from the description, but PluggableTextMorph doesn't seem to have an API to get the height of a hypothetical block of text e.g. 5 lines in the current font. So we work out an approximation as follows..."	lineSpacingFactor := 1.1. "This seems to account well for space between lines"	height := (description lineCount * result font height * lineSpacingFactor) + (result borderWidth * 2).		^ result			height: height;			hResizing: #spaceFill;			borderColor: #inset;			borderWidth: 1! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!enabled	^ self magritteDescription readOnly not! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected	^ (self value ifNil: [ self magritteDescription default ]) ifNil: [ false ]! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected: aBoolean	self value: aBoolean ! !!MAPasswordMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	^ super buildMorphView		font: (StrikeFont passwordFontSize: 12);		yourself! !!MATextMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	^ Smalltalk ui theme		newTextEntryIn: nil		for: self		get: #string		set: #string:		class: String		getEnabled: #enabled		help: self magritteDescription comment! !!MAOneToManyMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!add	self newRelation asMagritteMorph		onAnswer: [ :result |			result isNil ifFalse: [ self value: (self value copyWith: result) ].			self add: result ];		addButtons; 		addWindow;		openInWorld! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!add: anObject	| rowParent lastRowIndex newRow |	rowParent := morph submorphs second.	newRow := MAElementRow for: anObject of: self.	lastRowIndex := rowParent submorphs findLast: [ :e | e isKindOf: MAElementRow ].	lastRowIndex = 0 		ifTrue: [ rowParent addMorph: newRow ]		ifFalse: [ rowParent 			addMorph: newRow 			after: (rowParent submorphs at: lastRowIndex) ].! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	| table scrollPane |	table := self rectangleMorph		listDirection: #topToBottom;		yourself.	self value ifNotNil: [ :v | v do: [ :e | MAElementRow addMorphFor: e of: self to: table ] ].	self magritteDescription isDefinitive		ifFalse: [ self addSelectListTo: table ].	scrollPane := GeneralScrollPane new			changeScrollerTableLayout;			hResizing: #shrinkWrap;			yourself.	table computeBounds. "Layout so we know the height, which is needed below"	scrollPane		height: (table height min: 200);		scrollTarget: table.	^ scrollPane! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildSelectButton	^ Smalltalk ui theme builder		newButtonFor: self		action: #add		label: 'Add'		help: ''! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!remove: anObject	self value: (self value copyWithout: anObject).! !!MAExternalEditorMorph class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAExternalEditorMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!create	self newRelation asMagritteMorph		onAnswer: [ :result | result isNil ifFalse: [ self value: result ] ];		addButtons; 		addWindow;		openInWorld! !!MAExternalEditorMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!edit	self chooser: (self editorFor: self value)! !!MAExternalEditorMorph methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!renderButtonsOn: html	html submitButton on: #remove of: self.	html submitButton on: #edit of: self! !!MAExternalEditorMorph methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!renderViewerOn: html	html render: (self reference toString: self value)! !!MAInternalEditorMorph class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!isAbstract	^ false! !!MAInternalEditorMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildComponent	^ self value isNil ifFalse: [ 		(self magritteDescription reference asComponentOn: self value)			setParent: self;			yourself ]! !!MAInternalEditorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!children	^ Array with: self component! !!MAInternalEditorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!component	^ component ifNil: [ component := self buildComponent ]! !!MAInternalEditorMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!create	self value: self newRelation.	component := nil! !!MAInternalEditorMorph methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!renderViewerOn: html	html render: (self component		readOnly: self isReadOnly;		yourself)! !!MAOneToOneMorph methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildMorphView	| table |	table := self rectangleMorph		listDirection: #topToBottom;		yourself.	self value		ifNotNil: [ MAElementRow addMorphFor: self value of: self to: table ]		ifNil: [ self addSelectListTo: table ].	^ table.! !!MAOneToOneMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildSelectButton	^ Smalltalk ui theme builder		newButtonFor: self		action: #create		label: 'Create'		help: ''! !!MAOneToOneMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!create	self subclassResponsibility! !!MAOneToOneMorph methodsFor: 'removing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!remove: anObject	self value: nil! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addSelectListTo: aMorph	self classes ifEmpty: [ ^ self ].	aMorph addMorphBack: self buildSelectList! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildClassChooser	| items |	items := self classes collect: [ :e | e label ].	^ Smalltalk ui theme builder		newDropListFor: self		list: items		getSelected: #selectedIndex		setSelected: #selectedIndex:		help: ''! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildSelectButton	self subclassResponsibility! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buildSelectList	| list |	list := self rectangleMorph		listDirection: #leftToRight;		yourself.	self classes size > 1 ifTrue: [ list addMorphBack: self buildClassChooser ].	^ list 			addMorphBack: self buildSelectButton;			yourself.! !!MARelationMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!classes	^ self magritteDescription classes asSortedCollection.! !!MARelationMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!newRelation	| instance |	instance := self selected new.	self magritteDescription initializer value: instance.	^ instance! !!MARelationMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selected	^ self classes at: self selectedIndex! !!MARelationMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selectedIndex	^ selectedIndex ifNil: [ selectedIndex := 1 ]! !!MARelationMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!selectedIndex: anInteger	selectedIndex := anInteger.! !!MAToManyRelationDescription class methodsFor: '*magritte-morph-defaults' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MAOneToManyMorph! !!MAMultipleOptionDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MATokenCompletionMorph with: MAMultiSelectListMorph! !!MADirectoryDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MADirectoryMorph! !!MAFileDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MAFileMorph! !!MAElementDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MATextMorph! !!TokenCollectorMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!accept: text	| object |	object := self options		detect: [ :e | self stringDecoder value: e value: text asString ]		ifNone: [ factory value: text ].	self objects add: object.	whenObjectsChangedBlock ifNotNil: [ :blk | blk value: self objects ].	self refresh! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!entryCompletion	entryCompletion ifNotNil: [ ^ entryCompletion ].	^ entryCompletion := EntryCompletion new			dataSourceBlock: [ :currText | self options collect: self stringEncoder ];			filterBlock: [ :currApplicant :currText | currApplicant asString asUppercase includesSubstring: currText asString asUppercase ];			yourself.! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!factory	^ factory ifNil: [ factory := [ :text | text ] ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!factory: aBlock	factory := aBlock! !!TokenCollectorMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	| scrollPane |	super initialize.	self		changeTableLayout;		color: Color transparent.	self addMorphBack: self textInput.	scrollPane := GeneralScrollPane new			changeScrollerTableLayout;			hResizing: #spaceFill;			vResizing: #spaceFill;			scrollTarget: self tokenViewer;			yourself.	self addMorphBack: scrollPane! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!objects	^ objects ifNil: [ objects := OrderedCollection new ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!objects: aCollection	objects := aCollection.	self refresh! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!options	^ options! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!options: anObject	options := anObject! !!TokenCollectorMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!refresh	self textInput model model text: ''.	self tokenViewer removeAllMorphs.	self objects do: [ :object |		self tokenViewer addMorphBack: (TokenMorph on: object) ]					! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringDecoder	"Test whether a string represents an object"	^ stringDecoder ifNil: [ stringDecoder := [ :obj :str | obj asString = str ] ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringDecoder: aBlock	stringDecoder := aBlock! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringEncoder	^ stringEncoder ifNil: [ stringEncoder := [ :obj | obj asString ] ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!stringEncoder: aBlock	"Turn data object into a string"	stringEncoder := aBlock! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!textInput	textInput ifNotNil: [ ^ textInput ].	textInput := TextInputFieldModel new		entryCompletion: self entryCompletion;		acceptBlock: [ :text | self accept: text ];		buildWithSpec.	textInput		vResizing: #rigid;		height: textInput textFont height + (textInput borderWidth * 2).	^ textInput! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!tokenViewer	tokenViewer ifNotNil: [ ^ tokenViewer ].	^ tokenViewer := Morph new		color:			Smalltalk ui theme backgroundColor;		changeTableLayout;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		listDirection: #leftToRight;		wrapDirection: #topToBottom;		cellInset: 5 @ 5;		yourself! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!whenObjectsChanged: aBlock	whenObjectsChangedBlock := aBlock! !!TokenMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!on: anObject 	^ self new		object: anObject;		yourself! !!TokenMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!initialize	super initialize.	self roundedCorners: #(1 2 3 4).	"Seems to do nothing"	self		color:			Smalltalk ui theme buttonColor;		changeTableLayout;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 5 @ 1! !!TokenMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!object	^ object! !!TokenMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!object: anObject	object := anObject.	self removeAllMorphs.	self addMorph: object asString asMorph! !!MABooleanDescription class methodsFor: '*magritte-morph-default' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MACheckboxMorph with: MASingleSelectListMorph! !!MADateDescription class methodsFor: '*magritte-morph-default' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MADateMorph.! !!GRPackage class methodsFor: '*magritte-morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteMorph	^ self new		name: 'Magritte-Morph';		description: 'Morphic integration for the Magritte metamodel.';		addDependency: 'Magritte-Model';		url: #magritteUrl;		yourself! !!MADescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClass	^ self defaultMorphClasses notEmpty		ifTrue: [ self defaultMorphClasses first ]! !!MADescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array new! !!MADescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphColor	^ Color white! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionMorphClass	<magritteDescription>	^ MASingleOptionDescription new		accessor: #morphClass;		label: 'Morph Class';		priority: 2000;		reference: MAClassDescription new;		options: self class defaultMorphClasses;		default: self class defaultMorphClass;		yourself! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!morphClass	^ self propertyAt: #morphClass ifAbsent: [ self class defaultMorphClass ]! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!morphClass: aClass	^ self propertyAt: #morphClass put: aClass! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!morphColor	^ self propertyAt: #morphColor ifAbsent: [ self class defaultMorphColor ]! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!morphColor: aColor	^ self propertyAt: #morphColor put: aColor! !!MAContainer class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MAContainerMorph! !!MAContainer methodsFor: '*magritte-morph-converting' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asMorphOn: anObject	^ self morphClass		memento: (anObject mementoClass			model: anObject			description: self)! !!MASingleOptionDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array			with: MASingleSelectListMorph			with: MADropListMorph! !!MAMemoDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MAMemoMorph! !!MAActionDescription methodsFor: '*magritte-morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!buttonOn: anObject	^ Smalltalk ui theme builder		newButtonFor: self		getState: nil		action: #performOn:		arguments: {anObject}		getEnabled: #isEnabled		label: self label		help: comment! !!MAToOneRelationDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MAExternalEditorMorph with: MAInternalEditorMorph! !!MAPasswordDescription class methodsFor: '*magritte-morph-default' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMorphClasses	^ Array with: MAPasswordMorph! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!asMagritteMorph	^ self magritteDescription asMorphOn: self! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maEdit 	self maEditAnswering: [ :editedObj | ]! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maEditAnswering: aBlock 	self asMagritteMorph		addButtons;		addWindow;		onAnswer: aBlock;		openInWorld.! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteActionButtons	^ self magritteActionDescriptions collect: [ :e | e buttonOn: self ].! !!MARelationDescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionClassesWithMorphic: description	<magritteDescription: #descriptionClasses>	^ description			morphClass: MATokenCompletionMorph;			yourself! !"Magritte-Morph"!!ManifestPharoEnhancements commentStamp: '' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!Object methodsFor: '*PharoEnhancements' prior: 54747038!fuelOut	| target |	target := FileLocator imageDirectory / self printString asFileName, 'fuel'.	self serializeToFileNamed: target nextVersion fullName! !!MailMessage methodsFor: '*PharoEnhancements'!timestamp	| dateField dateString isWeekdayPresent safeDateString |	dateField := self 		fieldNamed: 'date'		ifAbsent: [ ^ nil ].	"These header values seem to start with a weekday e.g. 'Thu, ' which breaks Pharo's DateAndTime parsing"	dateString := dateField mainValue.	isWeekdayPresent := dateString includes: $,.	safeDateString := isWeekdayPresent		ifTrue: [ 			| dateStringNoWeekday |			dateStringNoWeekday := dateString copyAfter: $,.			dateStringNoWeekday trimLeft ]		ifFalse: [ dateString ].	^ safeDateString asDateAndTime! !!FileLocator class methodsFor: '*PharoEnhancements'!dynabookData	^ self origin: #dynabookData! !!GTPlayBook class methodsFor: '*PharoEnhancements'!browseAll	<script>	GTPlayBook instance allFiles inspect! !!GTPlayBook class methodsFor: '*PharoEnhancements'!browseNamed	<script>	(GTPlayBook instance allFiles reject: [ :e | e basename prefixMatchesRegex: '\d\d\d\d-' ]) inspect! !!GTPlayBook class methodsFor: '*PharoEnhancements'!menuCommandOn: aBuilder	<worldMenu>	(aBuilder item: #'Play Pages')		parent: 'Tools';		with: [			(aBuilder item: #'Browse All')				action: [ self browseAll ]; 				icon: Smalltalk tools workspace taskbarIcon.			(aBuilder item: #'Browse Named')				action: [ self browseNamed ]; 				icon: Smalltalk tools workspace taskbarIcon. ]! !!String methodsFor: '*PharoEnhancements'!asEncodedUrl	"Send this instead of `#asUrl` if I potentially have characters not allowed by the URL spec, which Zinc enforces on input to its parser. Example: `'https://en.wikipedia.org/wiki/Česká republika' asEncodedUrl`"	| encodedString |	encodedString := String streamContents: [ :out | 		self do: [ :each | 			(each codePoint < 127 and: [ each ~= Character space ])				ifTrue: [ out nextPut: each ]				ifFalse: [ out nextPutAll: each asString urlEncoded ] ] ].	^ encodedString asUrl! !!String methodsFor: '*PharoEnhancements'!asFilename	"`#asFileName` leaves in $: which mac doesn't like"	| result |	result := self asFileName copyReplaceAll: ':' with: '#'.	self assert: (#('' '/' '..' '.' '\') includes: result) not. "Agressively protect against wonky FS resolution of special strings"	^ result! !!String methodsFor: '*PharoEnhancements'!surroundedByDoubleQuotes	^ self surroundedBy: '"'! !!RPackage methodsFor: '*PharoEnhancements'!createBaselineOf	"Example:		(RPackage named: 'MyCoolPackage') createBaselineOf	"	(MetacelloToolBox baselineNamed: self name)		createBaselineOfMethod: 'baseline:' inCategory: 'baseline';		addBaselineOfSection: #common			requiredProjects: #() "This means Configs, not Baselines, so will usually be empty"			packages: { self name }			repositories: #()			dependencies: #() "Could calculate from Dependency Analyzer?"			groups: #()			versionSpecsDo: [ :versionSpec |  ];		commitBaselineOfMethod! !!DateAndTime methodsFor: '*PharoEnhancements'!printUS	^ self asDate mmddyyyy, ' @ ', self asTime printMinutes.! !!ConfigurationOf class methodsFor: '*PharoEnhancements'!createBaselineFrom: selector	| projectName baselineName baseline methodTree commonBlockBody |		"Create new class"	projectName := self name allButFirst: self superclass name size.	baselineName := 'BaselineOf', projectName.	baseline := BaselineOf subclass: baselineName asSymbol	instanceVariableNames: ''	classVariableNames: ''	category: baselineName.		"Convert baseline##: method"	methodTree := (self methodNamed: selector) parseTree.	methodTree selector: #baseline:.	methodTree pragmas at: 1 put: (RBPragmaNode selector: #baseline arguments: #()).	commonBlockBody := methodTree statements first arguments last body.	commonBlockBody statements		detect: [ :e | e selector = #repository: ]		ifFound: [ :repoSetter | commonBlockBody removeNode: repoSetter ].		"Compile baseline method"	baseline compile: methodTree newSource classified: 'baseline'! !!Date methodsFor: '*PharoEnhancements'!addYears: anInteger	| targetYear isLeapDay |	targetYear := self year + anInteger.		isLeapDay := self monthIndex = 2 and: [ self dayOfMonth = 29 ].	isLeapDay		ifTrue: [ 			^ self class 					year: targetYear					day: self start dayOfYear ].		^ self class 			year: targetYear			month: self monthIndex			day: self dayOfMonth! !!Date methodsFor: '*PharoEnhancements'!subtractYears: anInteger	^ self addYears: anInteger negated! !!Date methodsFor: '*PharoEnhancements'!yearsSince: aDate	"Returns aNumber whose fractional part = fraction of the year from last to next anniversary rounded to the day"	| fullYears lastAnniversary nextAnniversary partialYear |	fullYears := 0.	self year = aDate year ifTrue: [ fullYears := 0 ].	fullYears := self year - aDate year.	lastAnniversary := Date year: self year month: aDate monthIndex day: aDate dayOfMonth.	nextAnniversary := Date year: self year + 1 month: aDate monthIndex day: aDate dayOfMonth.	partialYear := (self - lastAnniversary) / (nextAnniversary - lastAnniversary).	^ (self monthIndex > aDate monthIndex or: [ self monthIndex = aDate monthIndex and: [ self dayOfMonth >= aDate dayOfMonth ] ])		ifTrue: [ fullYears + partialYear ]		ifFalse: [ fullYears - partialYear ]! !!EpCodeChange class methodsFor: '*PharoEnhancements'!allAffectingPackagesNamed: aBlock	| nodes entries filter filteredEntries groups |	"To see diffs on the changes, you could do:	events collect: [ :e | 		DiffModel new			showOptions: true;			leftText: (e accept: EpOldStateVisitor new);			rightText: (e accept: EpNewStateVisitor new);			contextClass: e class;			buildWithSpec ]"	nodes := EpFileLogNode fromAllLogsIn: EpMonitor current sessionStore baseLocator.	nodes do: [ :node | node populateReferencedNodesWith: nodes ].	entries := nodes flatCollect: [ :n | n log entries ].	filter := EpAndFilter		withAll:			{(EpImpactCodeChangeFilter new				environment: self class environment;				yourself).			(EpPluggableFilter new condition: [ :e | e content isCodeChange and: [ aBlock value: e content affectedPackageName ] ]).			EpPluggableFilter noTriggerFilter}.	filteredEntries := entries select: [ :e | filter accepts: e ].	filteredEntries sort: [ :a :b | (a tagAt: #time) > (b tagAt: #time) ].	groups := filteredEntries		groupedBy: [ :e | 			(e content respondsTo: #methodAffected)				ifFalse: [ '?' ]				ifTrue: [ e content methodAffected ] ].	^ groups collect: [ :col | col first content ] as: OrderedCollection.! !!HandMorph methodsFor: '*PharoEnhancements' prior: 29185119!generateKeyboardEvent: evtBuf	"Override to get horizontal scrolling"	| buttons modifiers type pressType stamp charCode keyValue keyEvent |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown		ifTrue: [			type := #keyDown.			lastKeyScanCode := evtBuf third].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [		type := #keystroke].	modifiers := evtBuf fifth.	buttons := modifiers bitShift: 3.	keyValue := evtBuf third. 	charCode := evtBuf sixth.	type = #keystroke		ifTrue: [combinedChar			ifNil: [				| peekedEvent |				peekedEvent := Sensor peekEvent.				(peekedEvent notNil					and: [peekedEvent fourth = EventKeyDown])					ifTrue: [						(CombinedChar isCompositionCharacter: charCode)							ifTrue: [								combinedChar := CombinedChar new.								combinedChar simpleAdd: charCode asCharacter.								(combinedChar combinesWith: peekedEvent third asCharacter)									ifTrue: [^nil].								]]]			ifNotNil: [				(combinedChar simpleAdd: charCode asCharacter)					ifTrue: [charCode := combinedChar combined charCode].				combinedChar := nil]].	self flag: #fixme.	"This piece of code handles the creation of scrolling events. When a scroll is done by the user, the VM forwards a keystroke event with the up/down key. So we reconvert it to a MouseWheelEvent in that case."	(type = #keystroke and: [(buttons anyMask: 16) and: [ charCode asCharacter isArrow ]])		ifTrue: [^ MouseWheelEvent					fromCharacter: charCode asCharacter					position: lastMouseEvent cursorPoint					buttons: buttons					hand: self					stamp: stamp].	keyEvent := KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: keyValue		charCode: charCode		hand: self		stamp: stamp.	keyEvent scanCode: lastKeyScanCode.	^keyEvent! !!ManifestPharoEnhancements class methodsFor: 'code-critics'!ruleGRUsesCurlyBraceArraysRuleV1FalsePositive	^ #(#(#(#RGPackage #(#PharoEnhancements)) #'2018-08-26T16:20:35.927752+00:00') )! !!PluggableTextFieldMorph methodsFor: '*PharoEnhancements' prior: 55785305!entryCompletion: anEntryCompletion	entryCompletion := anEntryCompletion.	entryCompletion ifNotNil: [ 		entryCompletion chooseBlock isNil			ifTrue: [ entryCompletion					chooseBlock: [ :v | 						self setText: v.						self acceptTextInModel ] ]			ifFalse: [ | blk |				blk := entryCompletion chooseBlock.				entryCompletion					chooseBlock: [ :v | 						(blk value: v) = true							ifTrue: [ 								self setText: v.								self acceptTextInModel ] ] ] ]! !!PeDateTest methodsFor: 'tests'!testAddYears	| start increment cases expected |	cases := { 		{ '3/1/2016'. 1. '3/1/2017' }.				"Leap year"		{ '2/29/2016'. 4. '2/29/2020' }.		{ '2/29/2016'. 1. '3/1/2017' }.	}.		cases do: [ :e |		start := e first asDate.		increment := e second.		expected := e third asDate.				self assert: (start addYears: increment) equals: expected ]! !!PeDateTest methodsFor: 'tests'!testSubtractYears	| start increment cases expected |	cases := { 		{ '3/1/2016'. 1. '3/1/2015' }.				"Leap year"		{ '2/29/2016'. 4. '2/29/2012' }.		{ '2/29/2016'. 1. '3/1/2015' }.	}.		cases do: [ :e |		start := e first asDate.		increment := e second.		expected := e third asDate.				self assert: (start subtractYears: increment) equals: expected ]! !!PeDateTest methodsFor: 'tests'!testYearsSince	| start end cases expected |	"See #yearsSince: method comment for explanation of return value"	cases := { 		{ '1/1/2018'. '1/2/2018'. 1 / 365 }.		{ '1/1/2018'. '1/1/2019'. 1 }.		{ '1/1/2018'. '1/2/2019'. 1 + (1 / 365) }.				"Leap year"		{ '1/1/2016'. '1/1/2017'. 1 }.		{ '2/28/2016'. '3/1/2016'. 2 / 366 }.	}.		cases do: [ :e |		start := e first asDate.		end := e second asDate.		expected := e third.				self assert: (end yearsSince: start) equals: expected ]! !!SystemResolver methodsFor: '*PharoEnhancements'!dynabookData 	<origin>	^ (FileLocator home / 'Dynabook' / 'User Data') resolve! !!AbstractFileReference methodsFor: '*PharoEnhancements'!isMD5Equal: aReference	| sourceHash targetHash |	sourceHash := self binaryReadStreamDo: [ :str | MD5 hashStream: str ].	targetHash := aReference binaryReadStreamDo: [ :str | MD5 hashStream: str ].	^ sourceHash = targetHash! !!AbstractFileReference methodsFor: '*PharoEnhancements'!macLock: aBoolean	"Adapted from https://macosx.com/threads/lock-unlock-files-with-the-terminal.317350/"	| keyword commandTemplate command |	OSPlatform current isMacOSX ifFalse: [ ^ self ].	keyword := aBoolean		ifTrue: [ 'uchg' ]		ifFalse: [ 'nouchg' ].	commandTemplate := 'chflags {keyword} "{fileName}"'.	command := commandTemplate format: { 		#keyword -> keyword.		#fileName -> self fullName } asDictionary.	LibC system: command! !!AbstractFileReference methodsFor: '*PharoEnhancements'!open	LibC system: 'open "', self fullName, '"'! !!AbstractFileReference methodsFor: '*PharoEnhancements'!preview	"Reference: http://www.maclife.com/article/columns/easy_mac_hacks_using_quicklook_command_line"	LibC system: '/usr/bin/qlmanage -p "', self fullName, '" &'! !!AbstractFileReference methodsFor: '*PharoEnhancements'!showInFinder	LibC system: 'open --reveal ', (self fullName surroundedBy: '"')! !!AbstractFileReference methodsFor: '*PharoEnhancements'!verifiedCopyTo: aReference	| result |	result := self copyTo: aReference.	(self isMD5Equal: aReference) ifFalse: [ self error: 'Copy hash has changed!!' ].	^ result! !!AbstractFileReference methodsFor: '*PharoEnhancements'!verifiedMoveTo: aFileReference	self verifiedCopyTo: aFileReference.	self delete! !"PharoEnhancements"!!GLMCompositePresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritte	^ self custom: GLMMagrittePresentation new! !!MAStringDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!glmDefaultPresentation	^ #text! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!description: anObject	"convenience method for scripting"		magritteDescription := anObject! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteDescription	"By default the we read it via the #description selector"	^ magritteDescription ifNil: [ magritteDescription := #magritteDescription ]! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!onAnswer: aBlock	answerBlock := aBlock! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!reactOnAnswerFor: aValue	self update.	^ answerBlock glamourValue:		(aValue asGlamorousMultiValue, 		self asGlamorousMultiValue, 		self entity asGlamorousMultiValue)! !!GLMMagrittePresentation methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!renderGlamorouslyOn: aRenderer 	^ aRenderer renderMagrittePresentation: self! !!GLMPresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!glmAddActions	self dynamicActions: [ :pres | pres entity magritteActionDescriptions collect: #asGlmAction ]! !!GLMPresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!glmAddSelectionActions	self dynamicActionsOnSelection: [ :pres | 			pres selection magritteActionDescriptions collect: #asGlmAction ]! !!GLMMorphicRenderer methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!renderMagrittePresentation: aMagrittePresentation 	^ GLMMorphicMagritteRenderer render: aMagrittePresentation from: self! !!MAElementDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!glmCustomizePresentation: presentation for: domainObject	presentation hasTitle ifFalse: [ presentation title: self label ].	presentation hasTransformation ifFalse: [ presentation display: (self accessor read: domainObject) ].	presentation glmAddSelectionActions! !!MAElementDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!glmPresentation	| valuable |	valuable := self 		propertyAt: #glmPresentation		ifAbsent: [ self glmDefaultPresentation ].			valuable ifNil: [ ^ [ ] ].		^ [ :composite :context :subject |			| presentation |			presentation := valuable cull: composite cull: context.			self glmCustomizePresentation: presentation for: subject ]! !!MAElementDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!glmPresentation: aValuable	"aValuable:		- Return value: a Glamour presentaion; FYI a default title, label, and selection actions will be added automatically by Magritte (see #glmCustomizePresentation:for:).		- Arguments (all optional) 				- composite - the container presentation				- context - e.g. an Inspector				- subject - the object being visualized		- To disable the presentation, make aValuable = `nil`"	self propertyAt: #glmPresentation put: aValuable! !!GLMListingPresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maAddSelectionActionsFor: aClass 		aClass magritteActionDescriptions do: [ :desc |		| glmAction actionBlock |		actionBlock := [ :list |			desc performOn: list selection.			desc isMutator ifTrue: [ list update ] ].		glmAction := GLMGenericAction new			action: actionBlock;			icon: desc icon;			title: desc label;			yourself.		desc shortcut ifNotNil: [ :sc | glmAction shortcut: sc key "assumes single key" ].		self addSelectionAction: glmAction ].! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!actOnPresentationUpdated: ann	scrollPane scrollTarget: (self magritteMorphFrom: ann presentation) ! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!magritteMorphFrom: aMagrittePresentation	| toShow description magritteMorph magritteDescriptionMorph |	toShow := aMagrittePresentation displayValue.	description := (aMagrittePresentation magritteDescription glamourValue: toShow) copy.	"Using MAContainerMorph can raise some problems, as it try to delete morphs after commiting. We don't want this behavior."	(description morphClass = MAContainerMorph)		ifTrue: [description morphClass: MASilentContainerMorph]. 	magritteDescriptionMorph :=  (description asMorphOn: toShow)		onAnswer: [ :value | aMagrittePresentation reactOnAnswerFor: value ].	magritteMorph := magritteDescriptionMorph		addButtons;		morph.	magritteMorph		hResizing: #spaceFill;		vResizing: #shrinkWrap;		layoutChanged.	^ magritteMorph! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!render: aMagrittePresentation	scrollPane := GeneralScrollPane new.	scrollPane changeScrollerTableLayout.	scrollPane scrollTarget: (self magritteMorphFrom: aMagrittePresentation).	scrollPane layoutFrame: (LayoutFrame identity bottomOffset: 25).	aMagrittePresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.	^ scrollPane! !"Magritte-Glamour"!!CompiledMethod class methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maNautilusMethodMenu: aBuilder	<nautilusGlobalMethodMenu>	| selectedMethod |	selectedMethod := aBuilder model selectedMethod.	(selectedMethod isNil or: [ selectedMethod maIsDescription not ]) ifTrue: [ ^ self ].		(aBuilder item: #'Show in GT Inspector')		action: [ selectedMethod maShowInGtInspector ];		order: 0;		enabled: [ :browser | true "Disable if already toggled, but we'll probably make two-way soon i.e. add disable" ];		help: 'Display in Inspector'.! !!CompiledMethod methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maIsDescription	^ self hasPragmaNamed: #magritteDescription! !!CompiledMethod methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maShowInGtInspector		| order |	order := UIManager default request: 'Presentation Order' initialAnswer: 1 asString.	order 		ifNotNil: [ order := order asNumber ]		ifNil: [ ^ self ].			self maShowInGtInspectorOrder: order! !!CompiledMethod methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maShowInGtInspectorOrder: aNumber		| nodes newPragmaNode |		nodes := self parseTree.	newPragmaNode := RBPragmaNode 		selector: #gtInspectorPresentationOrder: 		arguments: { RBLiteralValueNode value: aNumber }.	nodes pragmas add: newPragmaNode.	self methodClass compile: nodes newSource classified: self protocol! !!Symbol methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!cull: anObject cull: anotherObject 	^ self cull: anObject! !!Object methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!exampleGtInspectorReadOnlyMagritteIn: composite	"<gtInspectorPresentationOrder: 300>"	"A simple GT presentation. Disabled by default because we have one that shows the full editable form, but could be useful..."	| table |	table := composite table		title: 'Magritte';		display: [ self magritteDescription children collect: [ :desc |			desc label -> (desc toString: (desc accessor read: self)) ] ];		when: [ self magritteDescription notEmpty ];		column: 'Field' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!Object methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!gtInspectorMagritteIn: composite	<gtInspectorPresentationOrder: 40>	composite magritte		title: 'Form';		display: [ self ];		when: [ self magritteDescription isContainer not or: [ self magritteDescription notEmpty ] ]! !!ClyTagInspectorExtensionCommand class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!canBeExecutedInContext: aToolContext	^ aToolContext selectedMethods allSatisfy: [ :e | e maIsDescription ]! !!ClyTagInspectorExtensionCommand class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMenuItemName	^'Show in GT-Inspector'! !!ClyTagInspectorExtensionCommand class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!methodContextMenuActivation	<classAnnotation>		^ CmdContextMenuActivation byItemOf: CmdExtraMenuGroup for: ClyMethod asCalypsoItemContext! !!ClyTagInspectorExtensionCommand methodsFor: 'execution' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!execute		methods do: [ :m | m  maShowInGtInspector ]! !"Magritte-GT"!!Class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maAddField	| fieldName |	fieldName := UIManager default request: 'Field name?'.	fieldName ifNil: [ ^ self ].	self maAddField: fieldName asSymbol! !!MAClyAddFieldCommand class methodsFor: 'activation' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!contextMenuActivation		<classAnnotation>		^ CmdContextMenuActivation byRootGroupItemFor: ClyClassContextOfFullBrowser! !!MAClyAddFieldCommand class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!defaultMenuItemName	^'Add Field (Magritte)'! !!MAClyAddFieldCommand methodsFor: 'execution' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!execute	targetClass maAddField: fieldName asSymbol! !!MAClyAddFieldCommand methodsFor: 'execution' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!prepareFullExecutionInContext: aToolContext	super prepareFullExecutionInContext: aToolContext.	fieldName := UIManager default request: 'Field name'.			fieldName isEmptyOrNil ifTrue: [ CmdCommandAborted signal ]! !!MAElementDescription methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!addTo: aClass as: aSymbol	| source formattedSource |	source := String streamContents: [ :s | 		s		nextPutAll: aSymbol; nextPutAll: 'Description'; cr;		nextPutAll: '<magritteDescription>'.		s 			nextPutAll: '^ ';			store: self ].	formattedSource := (RBParser parseMethod: source) formattedCode.	aClass compile: formattedSource classified: 'magritte-accessing'.	self accessor maSetUp: aClass for: self! !!MADeveloperMenus class methodsFor: 'nautilus menus' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maNautilusMethodMenu: aBuilder	<nautilusGlobalClassMenu>	| selection |	selection := aBuilder model selectedClass.	selection ifNil: [ ^ self ].		(aBuilder item: #'MA Add Field')		action: [ selection maAddField ];		order: 0;		help: 'Add Magritte Field'.! !!Object class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!instVarBoilerplateFromDescriptions	self new magritteDescription do: [ :e | 		| varName refactoring |		varName := e accessor readSelector.		(self hasInstVarNamed: varName) 			ifFalse: [ self addInstVarNamed: varName ].		refactoring := RBCreateAccessorsForVariableRefactoring					variable: varName					class: self					classVariable: false.		refactoring execute ]! !!Object class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maAddField: aSymbol	self maAddField: aSymbol with: [ :desc | ]! !!Object class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maAddField: aSymbol with: customizationBlock	"If you don't need to customize the field description, you can use the simpler `#maAddField:`		Arguments:		aSymbol - field name		customizationBlock - takes description as argument; hook to modify it before it is serialized as a constructor method"	| elementTypes aClass |	elementTypes := MAElementDescription allSubclasses sort: [ :a :b | a name < b name ].	aClass := UIManager default 		chooseFrom: (elementTypes collect: #name)		values: elementTypes		lines: #()		message: 'Choose a type for the #', aSymbol, ' field'.			aClass ifNil: [ ^ self ]. "User cancelled"		aClass new 		accessor: aSymbol;		maEditAnswering: [ :desc | 			customizationBlock value: desc.			desc addTo: self as: aSymbol ]! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionBrowse	<magritteActionDescription>	^ MAActionDescription new			label: 'Browse Class';			action: #browse;			priority: 1100;			yourself! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionFuelOut	<magritteActionDescription>	^ MAActionDescription new				action: #fuelOut;			priority: 1200;			yourself! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!descriptionInspect	<magritteActionDescription>	^ MAActionDescription new			action: #inspect;			priority: 1000;			yourself! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeVia: anAccessor inDescriptionOn: aStream	aStream		nextPutAll: anAccessor writeSelector , ' (';		store: self;		nextPutAll: ');';		cr! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maCompile: templateString asAccessor: aSymbol forinstVarNamed: variableName in: aClass 	(aClass canUnderstand: aSymbol) ifTrue: [ ^ self ].	aClass		compile: (templateString expandMacrosWith: aSymbol with: variableName)		classified: #accessing! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!maSetUp: aClass for: anMAElementDescription	| variableName needsInstVar defaultArgumentType setterArgumentName |	variableName := self readSelector.	needsInstVar := (aClass hasInstVarNamed: variableName) not.	needsInstVar ifTrue: [ aClass addInstVarNamed: variableName ].	self 		maCompile: '<1s><r><t>^ self maLazyFrom: self <2s>Description'		asAccessor: self readSelector 		forinstVarNamed: variableName 		in: aClass.	defaultArgumentType := anMAElementDescription class defaultKind.	setterArgumentName := (defaultArgumentType name first isVowel ifTrue: [ 'an' ] ifFalse: [ 'a' ]), defaultArgumentType name.	self 		maCompile: '<1s> ', setterArgumentName, '<r><t><2s> := ', setterArgumentName		asAccessor: self writeSelector		forinstVarNamed: variableName 		in: aClass.! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!store: anObject inDescriptionOn: aStream 	anObject storeVia: self inDescriptionOn: aStream.	! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!storeVia: anAccessor inDescriptionOn: aStream 	| isSymmetrical |	isSymmetrical := self writeSelector = (self readSelector, ':') asSymbol.	aStream nextPutAll: 'accessor: '.	isSymmetrical 		ifTrue: [ aStream print: self selector ]		ifFalse: [ aStream nextPut: $(; store: self; nextPut: $) ].	aStream nextPut: $;; cr.! !"Magritte-Developer"!!BaselineOfMagritte methodsFor: 'baselines' stamp: 'NorbertHartl 8/25/2020 17:49' prior: 33577351!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			"spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ]".			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ spec requires: #('PharoEnhancements') ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'NorbertHartl 8/25/2020 17:49' prior: 34061762!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			"spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ]".			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ "spec requires: #('PharoEnhancements')" ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !BaselineOfMagritte removeSelector: #baseline330ForPharo:!BaselineOfMagritte removeSelector: #baseline330:!BaselineOfMagritte removeSelector: #baseline310CommonExtDeps:!BaselineOfMagritte removeSelector: #baseline300ForGemStone:!Smalltalk globals removeClassNamed: #AnObsoleteBaselineOfMagritte!!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline300ForGemStone: spec	spec		for: #gemstone		do: [ 			spec				project: 'GsCore'				with: [ 					spec						className: 'ConfigurationOfGsCore';						versionString: #bleedingEdge;						repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].			spec				package: 'Magritte-Model'					with: [ 							spec								requires: #('GsCore');								includes: #('Magritte-GemStone-Model') ];				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-GemStone-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-GemStone-Seaside') ];				package: 'Magritte-GemStone-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-GemStone-Model' with: [ spec requires: #('Magritte-GemStone-Model') ];				package: 'Magritte-GemStone-Seaside' with: [ spec requires: #('Magritte-Seaside') ] ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline310CommonExtDeps: spec	"Common external dependencies for baseline 3.1.0"	spec		baseline: 'Grease' with: [ spec repository: 'github://SeasideSt/Grease:v1.5.x/repository' ];		baseline: 'Seaside3'			with: [ "note: we do not want to depend on Zinc, since this is not present in Squeak. Currently no adapter is loaded"			spec				repository: 'github://SeasideSt/Seaside:master/repository';				loads: #('Core') ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330: spec	<baseline>	spec		for: #common		do: [ 			spec author: 'SeanDeNigris'.			spec timestamp: '2015-04-05'.			spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'.			self baseline310CommonExtDeps: spec.			spec				package: 'Magritte-Model' with: [ 					spec 						requires: #('Grease');						includes: #('Magritte-Deprecated3dot7') ];				package: 'Magritte-Deprecated3dot7' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Seaside' with: [ spec requires: #('Magritte-Model' 'Seaside3') ];				package: 'Magritte-Bootstrap' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Deprecated' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Merging' with: [ spec requires: #('Magritte-Model') ].			spec				group: 'Core' with: #('Magritte-Model');				group: 'Tests' with: #('Magritte-Tests-Model');				group: 'Seaside' with: #('Magritte-Seaside');				group: 'Deprecated' with: #('Magritte-Deprecated') ].	self baseline330ForPharo: spec.	self baseline300ForGemStone: spec! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'CompatibleUserName 8/25/2020 17:41:10'!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ].			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ spec requires: #('PharoEnhancements') ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !"BaselineOfMagritte"!!BaselineOfMagritte methodsFor: 'baselines' stamp: 'NorbertHartl 8/25/2020 17:52' prior: 34071412!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			"spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ]."			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ spec requires: #('PharoEnhancements') ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !!BaselineOfMagritte methodsFor: 'baselines' stamp: 'NorbertHartl 8/25/2020 17:52' prior: 34074732!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			spec				package: 'Magritte-Pharo7-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo7-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo7-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo7-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x' #'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ 			"spec				baseline: 'PharoEnhancements' with: [					spec repository: 'github://seandenigris/Pharo-Enhancements' ]."			spec 				package: 'Magritte-Glamour';				package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Magritte-Glamour') ];				package: 'Magritte-Developer' with: [ "spec requires: #('PharoEnhancements')" ].			spec group: 'default' with: #('Magritte-GT' 'Magritte-Developer') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ]! !!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baseline: spec	<baseline>	self baselineCommon: spec.	self baselineSqueak: spec.	self baselinePharo: spec.	self baselineGemStone: spec! !!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselineCommon: spec	spec		for: #common		do: [ spec blessing: #baseline.			spec				package: 'Grease-Core';				package: 'Grease-Tests-Core'					with: [ spec requires: #('Grease-Core') ].			spec				group: 'Core' with: #('Grease-Core');				group: 'Core Tests' with: #('Grease-Tests-Core');				group: 'Slime' with: #('Core');				group: 'Slime Tests' with: #('Core Tests');				group: 'Tests' with: #('Core Tests' 'Slime Tests');				group: 'default' with: #('Slime') ]! !!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselineGemStone: spec  spec    for: #'gemstone'    do: [       spec        project: 'GsCore'          with: [               spec                className: 'ConfigurationOfGsCore';                versionString: #'stable';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'UTF8'          with: [               spec                className: 'ConfigurationOfGsMisc';                versionString: #'stable';                loads: #('Utf8Encoding');                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'System-Digital-Signatures'          copyFrom: 'UTF8'          with: [ spec loads: #('System-Digital-Signatures') ];        project: 'SMTPMail'          copyFrom: 'UTF8'          with: [ spec loads: #('SMTPMail') ].      spec        package: 'Grease-Core'          with: [               spec                requires: #('GsCore');                includes: #('Grease-GemStone-Core') ];        package: 'Grease-Tests-Core'          with: [               spec                requires: #('Grease-GemStone-Core');                includes: #('Grease-Tests-GemStone-Core') ];        package: 'Grease-GemStone-Core'          with: [               spec                requires:                  #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];        package: 'Grease-Tests-GemStone-Core'          with: [ spec requires: #('Grease-Tests-Core') ] ].  spec    for: #'gs2.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone200-Core') ];        package: 'Grease-GemStone200-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #'gs2.3.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone230-Core') ];        package: 'Grease-GemStone230-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #'gs2.4.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone240-Core') ];        package: 'Grease-GemStone240-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #(#'gs3.0.x' #'gs3.1.x' #'gs3.2.x')    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone300-Core') ];        package: 'Grease-GemStone300-Core'          with: [               spec                requires: #('Grease-GemStone-Core');                postLoadDoIt: #'initializeLatin1ToUtf8Encodings' ] ].  spec    for: #(#'gs3.3.x' #'gs3.4.x' #'gs3.5.x' #'gs3.6.x')    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone330-Core') ];        package: 'Grease-GemStone330-Core'          with: [               spec                requires: #('Grease-GemStone-Core');                postLoadDoIt: #'initializeLatin1ToUtf8Encodings' ] ].  spec    for: #(#'gs3.2.x' #'gs3.3.x' #'gs3.4.x' #'gs3.5.x' #'gs3.6.x')    do: [       spec        package: 'Grease-Tests-GemStone-Core'        with: [ spec file: 'Grease-Tests-GemStone-Core.v32' ] ]! !!BaselineOfGrease methodsFor: 'baselines' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselinePharo: spec	spec		for: #pharo		do: [ spec				package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ];				package: 'Grease-Pharo40-Slime' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Pharo40-Slime') ].			spec				group: 'Slime' with: #('Grease-Pharo40-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime') ].	spec		for: #(#'pharo4.x' #'pharo5.x')		do: [ spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Pharo30-Core');						includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ] ].	spec		for: #'pharo6.x'		do: [ spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo60-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Pharo60-Core');						includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo60-Core' with: [ spec requires: #('Grease-Core') ] ].	spec		for: #(#'pharo7.x' #'pharo8.x' #'pharo9.x')		do: [ spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo70-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Pharo70-Core');						includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo70-Core' with: [ spec requires: #('Grease-Core') ] ]! !!BaselineOfGrease methodsFor: 'baseline' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!baselineSqueak: spec	spec		for: #(#'squeak5.x')		do: [ 			spec				project: 'Refactoring-Core'				with: [ spec						className: 'ConfigurationOfRefactoringBrowser';						versionString: #stable;						loads: #('Core');						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Grease-Core'					with: [ spec includes: #('Grease-Squeak5-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Squeak5-Core');						includes: #('Grease-Tests-Squeak-Core' 'Grease-Tests-Squeak5-Core') ];				package: 'Grease-Squeak5-Core'					with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Squeak-Core'					with: [ spec requires: #('Grease-Tests-Core') ];				package: 'Grease-Tests-Squeak5-Core'					with: [ spec requires: #('Grease-Tests-Squeak-Core') ];				package: 'Grease-Slime'					with: [ spec requires: #('Refactoring-Core' 'Grease-Core') ];				package: 'Grease-Tests-Slime'					with: [ spec requires: #('Grease-Slime') ].			spec				group: 'Slime' with: #('Grease-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime') ].	spec		for: #(#'squeak6.x')		do: [			spec				project: 'Refactoring-Core'				with: [ spec						className: 'ConfigurationOfRefactoringBrowser';						versionString: #stable;						loads: #('Core');						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Grease-Core'					with: [ spec includes: #('Grease-Squeak6-Core') ];				package: 'Grease-Tests-Core'					with: [ spec						requires: #('Grease-Squeak6-Core');						includes: #('Grease-Tests-Squeak-Core' 'Grease-Tests-Squeak6-Core') ];				package: 'Grease-Squeak6-Core'					with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Squeak-Core'					with: [ spec requires: #('Grease-Tests-Core') ];				package: 'Grease-Tests-Squeak6-Core'					with: [ spec requires: #('Grease-Tests-Squeak-Core') ];				package: 'Grease-Slime' 					with: [ spec requires: #('Refactoring-Core' 'Grease-Core') ];				package: 'Grease-Tests-Slime'					with: [ spec requires: #('Grease-Slime') ].			spec				group: 'Slime' with: #('Grease-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime') ]! !!BaselineOfGrease methodsFor: 'doits' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeLatin1ToUtf8Encodings	"Gemstone only"	(Smalltalk at: #GRUtf8CodecStream) initialize! !!BaselineOfGrease methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!projectClass  Smalltalk at: #'MetacelloCypressBaselineProject' ifPresent: [ :cl | ^ cl ].  ^ super projectClass! !"BaselineOfGrease"!!GRNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRNotification instead of Notification.!!GRDeprecatedApiNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This notification is signaled whenever a deprecated message is sent.see WAObject>>#greaseDeprecatedApi:details: !!GRNotificationBasedDynamicVariable commentStamp: 'pmm 9/5/2017 14:34' prior: 0!An implementation of a dynamic varaible based on notifications. Dialects that do not support dynamic variables or thread/process local variables can create an empty subclass of this class called GRDynamicVariable.!!GRError commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRError instead of Error.!!GRInvalidArgumentCount commentStamp: 'jf 3/14/2009 11:05' prior: 0!Signaled whenever a message is sent with the incorrect number of arguments.!!GRInvalidUtf8Error commentStamp: 'pmm 1/10/2009 22:29' prior: 0!A WAInvalidUtf8Error signals that the input is not valid UTF-8.!!GRObject commentStamp: 'pmm 9/14/2013 15:52' prior: 0!A common superclass that ensures consistent initialization behaviour on all platforms and provides #error: methods that signal an instance of WAPlatformError.Packages that are using Seaside-Platform should normally subclass GRObject instead of Object.!!GRCodec commentStamp: 'lr 2/7/2009 09:55' prior: 0!A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding) and back outside the image (encoding). The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.!!GRNullCodec commentStamp: 'pmm 9/14/2013 15:52' prior: 0!The null codec always returns the original streams. It assumes that the outside world uses the same encoding as the inside world. This is highly efficient as no transformation is applied to the data, but has its drawbacks.!!GRDelayedSend commentStamp: 'NickAger 3/20/2012 09:04' prior: 0!A GRDelayedSend is a future message send of a message to an object. Some of the arguments can be predefined. Instances are intended to be interchangeable with blocks.This class should conform the ANSI (block) valuable protocol. Unlike a block, a GRDelayedSend is not a closure so doesn't hold onto the method context. GRDelayedSend provides similar, but portable, functionality to Pharo's MessageSend.This is an abstract class. Use the methods in the 'instance-creation' protocol on the class side to create intances.Instance Variables	receiver:		<Object>	selector:		<Symbol>receiver	- the object receiving the messageselector	- the message selector sent to the receiver!!GRDelayedSendMessage commentStamp: 'NickAger 3/19/2012 11:20' prior: 0!GRDelayedSendMessage is an abstract base for objects that provide currying functionality for GRDelayedSend!!GRBoundMessage commentStamp: 'jf 3/14/2009 11:04' prior: 0!A delayed send that has some or all of the arguments defined in advance. Additionally supplied arguments will be added, if possible, to these when the object is evaluate.Instance Variables	arguments:		<Array>arguments	- the predefined arguments!!GRUnboundMessage commentStamp: 'jf 3/14/2009 11:03' prior: 0!A delayed send that has none of the arguments defined in advance.!!GRDelegatingStream commentStamp: 'pmm 6/25/2012 20:20' prior: 0!A GRDelegatingStream is a wrapper around a write stream and defines common behavior.Instance Variables	stream:		<WriteStream>stream	- a WriteStream!!GRCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!GRCodecStream is the abstract base class for codec streams!!GRNullCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!A WANullCodecStream is a WriteStream on a String on which you can both put binary and character data without encoding happening.Instance Variables	stream:		<WriteStream>stream	- a WriteStream on a String!!GRCountingStream commentStamp: 'pmm 6/25/2012 20:39' prior: 0!A GRCountingStream counts how many elements have been added to it. This is necessary because the underlying stream may inflate the number of elements in the stream.Instance Variables:	count	<Integer>		count  - number of elements added to this stream!!GRInflector commentStamp: 'lr 12/27/2008 09:43' prior: 0!The Inflector transforms words from singular to plural.!!GRPackage commentStamp: 'pmm 9/14/2013 15:53' prior: 0!I am a platform independent package representation. I know my name, description, my dependencies, the license and the repository URL. Packages are declared by creating a class side extension method that answers a configured package instance. The expression    GRPackage packagesanswers the collection of the complete package graph.!!GRPlatform commentStamp: 'jf 2/6/2009 16:05' prior: 0!The abstract platform implementation. Each platform should provide a subclass implementing any abstract methods and overriding any other methods as necessary.Default implementations should be provided here when possible/useful but default implementations MUST be valid on ALL PLATFORMS so it is rarely practical. VA Smalltalk flags sends of uknown messages so even these must be known to exist on all platforms.Common cases where default implementations *are* appropriate are where there is a standard implementation that is valid on all platforms but one or more platforms have an additional, optimized implementation that should be used instead.All classes and methods used by methods of this class should be either:  + included in the Seaside-Platform package;  + defined by the ANSI Smalltalk standard; or  + (not ideal) referenced via 'Smalltalk at: #ClassName'.!!GRNumberPrinter commentStamp: 'pmm 2/1/2014 13:27' prior: 0!A GRNumberPrinter prints numbers (integers and floats) in various formats in a platform independent way.Instance Variables	accuracy:	<UndefinedObject|Float>	base:		<Integer>	delimiter:	<UndefinedObject|Character>	digits:		<UndefinedObject|Integer>	infinite:		<UndefinedObject|String>	nan:			<UndefinedObject|String>	padding:	<UndefinedObject|Character>	precision:	<Integer>	separator:	<UndefinedObject|Character>!!GRSmallDictionary commentStamp: 'jf 2/15/2010 15:51' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser.!!GROrderedMultiMap commentStamp: 'jf 2/15/2010 16:04' prior: 0!I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.!!GRSmallDictionary2 commentStamp: 'pmm 8/22/2016 11:49' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser and others from Eclipse Collections.!!GROrderedMultiMap2 commentStamp: 'jf 2/15/2010 16:04' prior: 0!I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.!!GRSmallOrderedSet commentStamp: 'pmm 8/25/2016 14:03' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating.!!GRVersion commentStamp: 'lr 2/19/2012 12:57' prior: 0!I model version numbers. I am comparable and I define a natural order.!!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!details	^ details! !!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!details: anObject	details := anObject! !!GRNotificationBasedDynamicVariable class methodsFor: 'defaults' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultValue	^ nil! !!GRNotificationBasedDynamicVariable class methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!use: anObject during: aBlock	"Set the dynamic value of the receiver to anObject during the evaluation of aBlock."		^ aBlock on: self do: [ :notification | notification resume: anObject ]! !!GRNotificationBasedDynamicVariable class methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value	"Answer the dynamic value of the receiver."		^ self signal! !!GRNotificationBasedDynamicVariable methodsFor: 'defaults' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultAction	^ self class defaultValue! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!excerpt: aString	"Answer an excerpt of the receiver that matches the first occurence of aString. If aString isn't found, nil is answered."		^ self excerpt: aString radius: 100! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!excerpt: aString radius: anInteger	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."		^ self excerpt: aString radius: anInteger ellipsis: '...'! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!excerpt: aString radius: anInteger ellipsis: anEllipsisString	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."	| index start stop |	(index := self indexOfSubCollection: aString) = 0		ifTrue: [ ^ nil ].	start := index - anInteger max: 1.	stop := index + anInteger + aString size - 1 min: self size.	^ (start > 1 ifTrue: [ anEllipsisString ] ifFalse: [ '' ]) ,		(self copyFrom: start to: stop) ,	  	(stop < self size ifTrue: [ anEllipsisString ] ifFalse: [ '' ])! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	"Convert the receiver to an integer, answer nil if this is not a number."	| number negated |	number := nil.	negated := false.	1 to: self size do: [ : i |		| char |		char := self at: i.		(i = 1 and: [ char = $- ])			ifTrue: [ negated := true ]			ifFalse: [				(char >= $0 and: [ char <= $9 ])					ifTrue: [						number := (number isNil							ifTrue: [ 0 ]							ifFalse: [ 10 * number ]) + (char greaseInteger - $0 greaseInteger) ]					ifFalse: [						^ number isNil ifFalse: [ 							 negated not								ifFalse: [ number negated ]								ifTrue: [ number ] ] ] ] ].	^ number isNil ifFalse: [		negated not			ifFalse: [ number negated ]			ifTrue: [ number ] ]! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize	^ GRInflector pluralize: self! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPutAll: self! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!truncate	"Truncate the receiver to 30 characters."		^ self truncate: 30! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!truncate: anInteger	"Truncate the receiver to anInteger characters."		^ self truncate: anInteger ellipsis: '...'! !!String methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!truncate: anInteger ellipsis: aString	"Truncate the receiver to anInteger characters and append aString as ellipsis if necessary."	^ anInteger < self size		ifTrue: [ (self copyFrom: 1 to: anInteger) , aString ]		ifFalse: [ self copy ]! !!Character methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPut: self! !!UndefinedObject methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream! !!Integer methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	^ self! !!Integer methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize: aSingularString 	^ self 		pluralize: aSingularString		with: (GRInflector pluralize: aSingularString)! !!Integer methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize: aSingularString with: aPluralString	^ self printString , ' ' , (self abs = 1 ifTrue: [ aSingularString ] ifFalse: [ aPluralString ])! !!GRCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allCodecs	"Answer all codecs supported in this system. This is a collection of codec instances."	^ self subclasses		inject: self codecs asArray		into: [ :result :each | result , each allCodecs ]! !!GRCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	"Create the actual instance."	self subclassResponsibility! !!GRCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	"Answer a collection of possible codecs of the receiver. To be overridden by concrete subclasses."	^ #()! !!GRCodec class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!forEncoding: aString	"Answer a new codec instance for the given encoding name. Raise an WAUnsupportedEncodingError if the encoding name is not supported by this image."	self allSubclassesDo: [ :each | 		(each supportsEncoding: aString)			ifTrue: [ ^ each basicForEncoding: aString ] ].	^ self unsupportedEncoding: aString! !!GRCodec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	"Answer whether the the given encoding name is supported by this codec class."	self subclassResponsibility! !!GRCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unsupportedEncoding: aString	"Signal an unsupported encoding."	^ GRUnsupportedEncodingError signal: 'unsupported encoding: ' , aString! !!GRCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aString	| readStream writeStream |	readStream := self decoderFor: aString readStream.	writeStream := GRPlatform current writeCharacterStreamOn: (String new: aString size).	[ readStream atEnd ]		whileFalse: [ writeStream nextPutAll: (readStream next: 1024) ].	^ writeStream contents! !!GRCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aReadStream	"Wrap aReadStream with an decoder for the codec of the receiver. Answer a read stream that delegates to and shares the state of aReadStream." 		self subclassResponsibility! !!GRCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encode: aString	| writeStream |	writeStream := self encoderFor: (GRPlatform current		writeCharacterStreamOn:  (String new: aString size)).	writeStream nextPutAll: aString.	^ writeStream contents! !!GRCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aWriteStream	"Wrap aWriteStream with an encoder for the codec of the receiver. Answer a write stream that delegates to and shares the state of aWriteStream."		self subclassResponsibility! !!GRCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	"Answer a human readable string of the receivers encoding policy."	self subclassResponsibility! !!GRCodec methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!GRCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"Answer a codec that is responsible to encode and decode URLs. In most cases an UTF-8 codec is the only valid choice, but subclasses might decide to do something else."	self subclassResponsibility! !!GRNullCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	^ self new! !!GRNullCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecName	^ '(none)'! !!GRNullCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ Array with: self new! !!GRNullCodec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	^ aString isNil! !!GRNullCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aReadStream! !!GRNullCodec methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aWriteStream! !!GRNullCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ GRNullCodec codecName! !!GRNullCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"The selfish method. Let's do it with ourselves."		^ self! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!empty	^ self receiver: nil selector: #yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self empty! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!receiver: anObject selector: aSymbol 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRUnboundMessage selector: aSymbol);		yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!receiver: anObject selector: aSymbol arguments: anArray 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRBoundMessage selector: aSymbol arguments: anArray);		yourself! !!GRDelayedSend methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	"Answer the number of arguments that must be provided to the receiver when sending it."		^ message argumentCount! !!GRDelayedSend methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithReceiver: anObject message: aDelayedSendMessage	self initialize.	receiver := anObject.	message := aDelayedSendMessage! !!GRDelayedSend methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' receiver: '; print: receiver.	aStream nextPut: $ .	message printOn: aStream! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value	^ self valueWithArguments: #()! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value: anObject	^ self valueWithArguments: (Array with: anObject)! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!value: aFirstObject value: aSecondObject	^ self valueWithArguments: (Array with: aFirstObject with: aSecondObject)! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithArguments: anArray	^ message valueFor: receiver withArguments: anArray! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithPossibleArguments: anArray	^ message valueFor: receiver withPossibleArguments: anArray! !!GRBoundMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!selector: aSymbol	^ self selector: aSymbol arguments: #()! !!GRBoundMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!selector: aSymbol arguments: anArray	^ self basicNew		initializeWithSelector: aSymbol arguments: anArray;		yourself! !!GRBoundMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	^ selector numArgs - arguments size! !!GRBoundMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithSelector: aSymbol arguments: anArray	self initializeWithSelector: aSymbol.	arguments := anArray asArray! !!GRBoundMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!mergeArguments: anArray	^ arguments , anArray! !!GRBoundMessage methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' arguments: '; print: arguments! !!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self selector: #yourself! !!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!selector: aSymbol	^ self basicNew		initializeWithSelector: aSymbol;		yourself! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	"Answer the number of arguments that must be provided when sending this message."		self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicPerformFor: receiver withArguments: anArray	^ anArray size = selector numArgs		ifTrue: [ receiver perform: selector withArguments: anArray ]		ifFalse: [ self invalidArgumentCount ]! !!GRDelayedSendMessage methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithSelector: aSymbol	self initialize.	selector := aSymbol! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!invalidArgumentCount	GRInvalidArgumentCount signal! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!mergeArguments: anArray	self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	aStream nextPutAll: 'selector: '; print: selector! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueFor: receiver withArguments: anArray	"Send the message to receiver with the arguments in anArray. Answer the result.	Signal an error if the number of arguments does not match the selector."		^ self basicPerformFor: receiver withArguments: (self mergeArguments: anArray)! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueFor: receiver withPossibleArguments: anArray	"Send the message to receiver with as many of the arguments in anArray as possible. Answer the result.	Error if not enough arguments are available for the selector."	| allArguments |	allArguments := self mergeArguments: anArray.		^ allArguments size < selector numArgs		ifTrue: [ self invalidArgumentCount ]		ifFalse: [ self basicPerformFor: receiver withArguments: (allArguments first: selector numArgs) ]! !!GRUnboundMessage methodsFor: 'delegation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	^ selector numArgs! !!GRUnboundMessage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!mergeArguments: anArray	^ anArray! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	^ stream next! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	^ stream next: anInteger! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacterOrByte	aCharacterOrByte isCharacter		ifTrue: [ stream nextPut: aCharacterOrByte ]		ifFalse: [ stream nextPut: (Character codePoint: aCharacterOrByte) ]! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aStringOrByteArray	aStringOrByteArray isString		ifTrue: [ stream nextPutAll: aStringOrByteArray ]		ifFalse: [			1 to: aStringOrByteArray size do: [ :index |				stream nextPut: (Character codePoint: (aStringOrByteArray at: index)) ] ]! !!GRCountingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!count	^ count! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	super greaseNext: anInteger putAll: aCollection startingAt: startIndex.	count := count + anInteger! !!GRCountingStream methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	count := 0! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	stream nextPut: aCharacter.	count := count + 1	! !!GRCountingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	stream nextPutAll: aString.	count := count + aString size	! !!GRCountingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!reset	super reset.	count := 0! !!GRDelegatingStream class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!on: aStream	^ self basicNew initializeOn: aStream! !!GRDelegatingStream methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!atEnd	^ stream atEnd! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!contents	^ stream contents! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!crlf	self nextPut: Character cr; nextPut: Character lf! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!flush	stream flush! !!GRDelegatingStream methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeOn: aStream	self initialize.	stream := aStream! !!GRDelegatingStream methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isStream	^ true! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!position	^ stream position! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject	anObject printOn: self! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!reset	"Reset the stream"	stream reset! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ stream size! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!space	self nextPut: Character space! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!tab	self nextPut: Character tab! !!GRInflector class methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	Uninflected := #('bison' 'bream' 'breeches' 'britches' 'carp' 'chassis' 'clippers' 'cod' 'contretemps' 'corps' 'debris' 'deer' 'diabetes' 'djinn' 'eland' 'elk' 'equipment' 'fish' 'flounder' 'gallows' 'graffiti' 'headquarters' 'herpes' 'high-jinks' 'homework' 'information' 'innings' 'ities' 'itis' 'jackanapes' 'mackerel' 'measles' 'mews' 'money' 'mumps' 'news' 'ois' 'pincers' 'pliers' 'pox' 'proceedings' 'rabies' 'rice' 'salmon' 'scissors' 'sea-bass' 'series' 'shears' 'sheep' 'species' 'swine' 'trout' 'tuna' 'whiting' 'wildebeest').	InflectionRules := #(('man' 'en' 2) ('child' 'ren' 0) ('cow' 'kine' 3) ('penis' 'es' 0) ('sex' 'es' 0) ('person' 'ople' 4) ('octopus' 'es' 0) ('quiz' 'zes' 0) ('ox' 'en' 0) ('louse' 'ice' 4) ('mouse' 'ice' 4) ('matrix' 'ices' 2) ('vertix' 'ices' 2) ('vertex' 'ices' 2) ('indix' 'ices' 2) ('index' 'ices' 2) ('x' 'es' 0) ('ch' 'es' 0) ('ss' 'es' 0) ('sh' 'es' 0) ('ay' 's' 0) ('ey' 's' 0) ('iy' 's' 0) ('oy' 's' 0) ('uy' 's' 0) ('y' 'ies' 1) ('alf' 'ves' 1) ('elf' 'ves' 1) ('olf' 'ves' 1) ('arf' 'ves' 1) ('nife' 'ves' 2) ('life' 'ves' 2) ('wife' 'ves' 2) ('sis' 'es' 2) ('tum' 'a' 2) ('ium' 'a' 2) ('buffalo' 'es' 0) ('tomato' 'es' 0) ('buffalo' 'es' 0) ('bus' 'es' 0) ('alias' 'es' 0) ('status' 'es' 0) ('octopus' 'i' 2) ('virus' 'i' 2) ('axis' 'es' 2) ('s' '' 0))! !!GRInflector class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pluralize: aString	| string |	string := aString asLowercase.	Uninflected do: [ :each |		(string endsWithSubCollection: each)			ifTrue: [ ^ aString ] ].	InflectionRules do: [ :rule |		(string endsWithSubCollection: rule first)			ifTrue: [ ^ (aString allButLast: rule third) , rule second ] ].	^ aString , 's'! !!GRObject class methodsFor: 'error handling' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultErrorClass	^ GRError! !!GRObject class methodsFor: 'error handling' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!error: aString	^ self defaultErrorClass signal: aString! !!GRObject class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self basicNew initialize! !!GRObject methodsFor: 'error handling' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!error: aString	^ self class error: aString! !!GRObject methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize! !!GRPackage class methodsFor: 'querying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grPackages	"Answer a list of all registered packages. A package is registered by adding a class extension to the receiving class answering an instance of the receiving class."	| packages package |	packages := Dictionary new.	self class selectors do: [ :each |		(each numArgs = 0 and: [ each ~= #grPackages ]) ifTrue: [ 			package := self perform: each.			packages at: package name put: package ] ].	packages do: [ :each | each resolveWith: packages ].	^ packages values! !!GRPackage class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseCore	^ self new		name: 'Grease-Core';		description: 'The main package of the Grease compatibility layer.';		url: #greaseUrl;		yourself! !!GRPackage methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addDependenciesTo: aCollection	(aCollection includes: self) ifFalse: [		self dependencies			do: [ :each | each addDependenciesTo: aCollection ].		aCollection add: self ].	^ aCollection! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addDependency: aString	dependencies add: aString! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allDependencies	"Answer all dependencies on which this package depends."	^ self addDependenciesTo: OrderedCollection new! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!dependencies	"Return a collection of package names on which this package depends."	^ dependencies! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!description	"Answer a short description of the package."	^ description! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!description: aString	description := aString! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseUrl	^ 'http://smalltalkhub.com/mc/Seaside/Grease11/main'! !!GRPackage methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	dependencies := OrderedCollection new.	license := #MIT! !!GRPackage methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isLGPL	^ self license = #LGPL! !!GRPackage methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isMIT	^ self license = #MIT! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!license	"Answer the current license of this package, by default MIT is used."	^ license! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!license: aSymbol	license := aSymbol! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	"Answer the name of the package. This string should be useable to identify the platform specific native package object, e.g. the Monticello package name."	^ name! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name: aString	name := aString! !!GRPackage methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)! !!GRPackage methodsFor: 'dependencies' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!resolveWith: aDictionary	dependencies := dependencies 		collect: [ :each |			aDictionary at: each ifAbsent: [				"if Foo-Pharo-Bar fails try Foo-Pharo20-Bar and Foo-Pharo30-Bar"				(each indexOfSubCollection: '-Pharo-' startingAt: 1) ~= 0 ifTrue: [ 					"try -Pharo20-"					aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo20-') ifAbsent: [						"try -Pharo30-"						aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo30-') ifAbsent: [							"try -Pharo40-"							aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo40-') ifAbsent: [								"try -Pharo50-"								aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo50-') ifAbsent: [									"try -Pharo60-"									aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo60-') ifAbsent: [										"try -Pharo70-"										aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo70-') ifAbsent: [											"try -Squeak-"											aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Squeak-') ifAbsent: [												"try -Squeak5-"												aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Squeak5-') ifAbsent: [													"try -Squeak6-"													aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Squeak6-') ifAbsent: [													self error: self name printString , ' depends on unknown package ' , each printString ] ] ] ] ] ] ] ] ] ] ] ]! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!seasideAddonsUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30Addons/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!seasideLGPLUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30LGPL/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!seasideUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside31/main'! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"Answer the base-URL of the package. This string is only meaningful for platforms that can directly access Monticello repositories."	^ url isSymbol		ifTrue: [ self perform: url ]		ifFalse: [ url ]! !!GRPackage methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url: aStringOrSymbol	"Set the base-URL of the package, or a symbol referring to a method in this class that answers the URL. This setting is only meaningful for platforms that can directly access Monticello repositories."	url := aStringOrSymbol! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!current	^ Current! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!current: aPlatform	Current := aPlatform! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!select	GRPlatform current: self new! !!GRPlatform class methodsFor: 'registration' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unselect	GRPlatform current class = self ifTrue: [ GRPlatform current: nil ]! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToStartUpList: anObject	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	self subclassResponsibility! !!GRPlatform methodsFor: 'encoding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base64Decode: aString	"Base64 decode the given String and answer the result as a String."	self subclassResponsibility! !!GRPlatform methodsFor: 'bindings' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!bindingOf: aClass	"Answer the binding of aClass.	The binding is the literal that get compiled into the method.	We need the binding to be updated when the class is changed.	The binding has to respond to #value.		This is mostly an issue on GemStone/S because when we hold on	to a class directly we will end up holding on to an old class version.		Dialects with namespaces will need to override this.		On VisualWorks this should like this	^ aClass fullyQualifiedReference"	^ Smalltalk associationAt: aClass name! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!compile: aString into: aClass classified: aSymbol	"The trick here is to be as silently a possible so that the package is not marked dirty when running WAFileLibrary test.	This also makes running tests much faster."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!contentsOfFile: aString binary: aBoolean	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!convertToSmalltalkNewlines: aString	"Convert any line endings (CR, CRLF, LF) to the default platform newline."		aString isNil 		ifTrue: [ ^ nil ].	^ String streamContents: [ :writeStream |		| readStream |		readStream := aString readStream.		[ readStream atEnd ] whileFalse: [			| next |			next := readStream next.			next = Character cr				ifTrue: [					readStream peek = Character lf						ifTrue: [ readStream skip: 1 ].					writeStream nextPutAll: self newline ]				ifFalse: [					next = Character lf						ifTrue: [ writeStream nextPutAll: self newline ]						ifFalse: [ writeStream nextPut: next ] ] ] ]! !!GRPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!deprecationExceptionSet	"Answer the exception set that should considered besides WADeprecation."	^ ExceptionSet new! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'transactions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!doTransaction: aBlock	"for Gemstone/S compatibility	http://gemstonesoup.wordpress.com/2007/05/10/porting-application-specific-seaside-threads-to-gemstone/	use when modifying an object from an outside thread"	^ aBlock value! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!ensureExistenceOfFolder: aString	"Create a folder named aString in the image directory."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileExists: aString	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileStreamOn: aString do: aBlock binary: aBoolean	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!filesIn: aPathString	"Answer a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."		self subclassResponsibility! !!GRPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!label	"Answer a descriptive label string for the platform implementation"		self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!localNameOf: aFilename	"Answer the local name of a file identified by an absolute file path.		Eg.	If the platform is Windwos and aFilename is 'C:\Windows\win32.dll' then it would answer 'win32.dll'.	If the platform is Unix and aFilename is '/usr/bin/vim' then it would answer 'vim'."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.	Used by Squeak to use a secure random when avaiable."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newline	"Answer a String with the default newline character of this platform."		self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!openDebuggerOn: anError	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pathSeparator	"Answer the path separator as a String, eg. '/' on Unix and '\' on Windows."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteByteStream	"Return a ReadWriteStream on a ByteArray that stores integers 0..255		^ReadWriteStream on: ByteArray new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteCharacterStream	"Return a ReadWriteStream on a String that stores characters		^ReadWriteStream on: String new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!reducedConflictDictionary	"used by Gemstone/S reduced conflict classes that can be used to avoid transaction conflicts"	^ Dictionary! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromShutDownList: anObject	"Remove anObject from the shutdown list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromStartUpList: anObject	"Remove anObject from the startup list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeSelector: aSymbol from: aClass	self subclassResponsibility! !!GRPlatform methodsFor: 'cryptography' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!secureHashFor: aString	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stackDepth	self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."		self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!thisContext	"Answer the current activation of a method execution or block activation.		For dialects with a thisContext variable and implementation can lock like this.		^ thisContext sender"	self subclassResponsibility! !!GRPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!version	"Answer the Grease version"	^ (GRVersion major: 1 minor: 4 revision: 0)		yourself! !!GRPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!versionString	^ String streamContents: [ :stream |		stream			nextPutAll: (self version greaseString);			nextPutAll: ' (';			nextPutAll: (self label);			nextPut: $) ]! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!weakDictionaryOfSize: aNumber	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"Write aStringOrByteArray to a file named aFileNameString in the folder aFolderString."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!writeCharacterStreamOn: aString	"String based write stream"	^ WriteStream on: aString! !!GRMappedPrinter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!block: aBlock next: aPrinter	^ self new 		block: aBlock;		next: aPrinter;		yourself! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!block: aBlock	block := aBlock! !!GRMappedPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self block: [ :value | value ]! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: aPrinter	next := aPrinter! !!GRMappedPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	next print: (block value: anObject) on: aStream! !!GRNumberPrinter class methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	NumbersToCharactersLowercase := '0123456789abcdefghijklmnopqrstuvwxyz'.	NumbersToCharactersUppercase := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!accuracy: aFloat	"Round towards the nearest number that is a multiple of aFloat."		accuracy := aFloat! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base: anInteger	"The numeric base to which the number should be printed."	base := anInteger! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!characters: aString	"The characters to be used to convert a number to a string."	characters := aString! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!delimiter: aCharacter	"The delimiter to separate the integer and fraction part of the number."	delimiter := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!digits: anInteger	"The number of digits to be printed in the integer part."	digits := anInteger! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!digitsOf: aNumber base: aBaseInteger	"Answer the absolute digits of aNumber in the base aBaseInteger."	| integer stream next |	integer := aNumber truncated abs.	integer = 0 ifTrue: [ ^ '0' ].	stream := WriteStream on: (String new: 10).	[ integer > 0 ] whileTrue: [		next := integer quo: aBaseInteger.		stream nextPut: (characters 			at: 1 + integer - (next * aBaseInteger)).		integer := next ].	^ stream contents reverse! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!infinite: aString	"The string that should be displayed if the number is positive or negative infinity."		infinite := aString! !!GRNumberPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self lowercase.	self base: 10.	self delimiter: $..	self infinite: 'Infinite'.	self nan: 'NaN'.	self padding: $ .	self precision: 0! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!lengthOf: aNumber base: aBaseInteger	"Answer the number of digits of aNumber in the base aBaseInteger.	Same as #decimalDigitLength"	| integer current length |	integer := aNumber truncated abs.	length := 1.	current := aBaseInteger.	[ current <= integer ] whileTrue: [ 		length := length + 1.		current := current * aBaseInteger ].	^ length! !!GRNumberPrinter methodsFor: 'actions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!lowercase	"Use lowercase characters for numbers of base 10 and higher."	self characters: NumbersToCharactersLowercase! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nan: aString	"The string that should be displayed if the number is not a number."		nan := aString! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padLeft: aCharacter to: aPadCountInteger on: aStream	"Pad to the left side of aString with aCharacter to at anInteger characters."	1 to: aPadCountInteger do: [ :index |		separator isNil ifFalse: [			(index ~= 1 and: [ (digits - index) \\ 3 = 2 ])				ifTrue: [ aStream nextPut: separator ] ].		aStream nextPut: aCharacter ]! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padding: aCharacter	"The padding for the integer part."	padding := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!precision: anInteger	"The number of digits to be printed in the fraction part."		precision := anInteger! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: aNumber on: aStream	aNumber isNaN		ifTrue: [ ^ self printNaN: aNumber on: aStream ].	aNumber isInfinite 		ifTrue: [ ^ self printInfinite: aNumber on: aStream ].	precision = 0		ifTrue: [ self printInteger: aNumber on: aStream ]		ifFalse: [ self printFloat: aNumber on: aStream ]! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printDigitsOf: aNumber withLength: aLengthInteger on: aStream	"Print the digits of aNumber with a lenght of aLengthInteger on aStream.	Also print a separator if required."	| rest |	rest := aNumber truncated abs.	1 to: aLengthInteger do: [ :index |		| divisor current |		divisor := base raisedTo: aLengthInteger - index.		current := rest // divisor.		separator isNil ifFalse: [ 			 (index ~= 1 and: [ (aLengthInteger - index) \\ 3 = 2 ])				ifTrue: [ aStream nextPut: separator ] ].		aStream nextPut: (characters at: current + 1).		rest := rest - (divisor * current) ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printFloat: aNumber on: aStream	| multiplier rounded |	multiplier := base raisedTo: precision.	rounded := aNumber roundTo: (accuracy ifNil: [ multiplier reciprocal ]).	self printInteger: rounded on: aStream.	delimiter isNil		ifFalse: [ aStream nextPut: delimiter ].	self printFraction: rounded fractionPart abs * multiplier on: aStream! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printFraction: aNumber on: aStream	| result |	result := self		pad: (self digitsOf: aNumber rounded base: base)		left: $0 to: precision.	separator isNil		ifTrue: [ aStream nextPutAll: result ]		ifFalse: [ self separate: result left: separator on: aStream ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printInfinite: aNumber on: aStream	infinite isNil		ifFalse: [ aStream nextPutAll: infinite ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printInteger: aNumber on: aStream	| length |	length := self lengthOf: aNumber base: base.		(digits notNil and: [ padding notNil ])		ifTrue: [ self padLeft: padding to: (digits - length) on: aStream ].		self printDigitsOf: aNumber withLength: length on: aStream! !!GRNumberPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printNaN: anInteger on: aStream	nan isNil		ifFalse: [ aStream nextPutAll: nan ]! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!separate: aString left: aCharacter on: aStream	"Separate from the left side every 3 characters with aCharacter."			| size |	size := aString size.	1 to: size do: [ :index |		(index ~= 1 and: [ index \\ 3 = 1 ])			ifTrue: [ aStream nextPut: aCharacter ].		aStream nextPut: (aString at: index) ]! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!separate: aString right: aCharacter	"Separate from the right side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ size - index \\ 3 = 2 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!separator: aCharacter	"Separator character to be used to group digits."	separator := aCharacter! !!GRNumberPrinter methodsFor: 'actions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!uppercase	"Use uppercase characters for numbers of base 10 and higher."		self characters: NumbersToCharactersUppercase! !!GROrdinalizePrinter methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!ordinalize: anInteger	^ (anInteger \\ 100 between: 11 and: 13)		ifTrue: [ 'th' ]		ifFalse: [ 			#('st' 'nd' 'rd')				at: anInteger \\ 10 				ifAbsent: [ 'th' ] ]! !!GROrdinalizePrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPutAll: (self ordinalize: anObject integerPart)! !!GRPluggablePrinter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!on: aBlock	^ self new block: aBlock! !!GRPluggablePrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!block: aBlock	block := aBlock! !!GRPluggablePrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self block: [ :value | String new ]! !!GRPluggablePrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	aStream nextPutAll: (block value: anObject)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!abbreviatedMonthName	^ self monthName: #('Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!abbreviatedWeekName	^ self weekName: #('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!absOffsetHoursPadded	^ GRMappedPrinter 		block: [ :date | date offset hours abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!absOffsetMinutesPadded	^ GRMappedPrinter 		block: [ :date | date offset minutes abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-units' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!binaryFileSize	^ GRUnitPrinter base: 1024 units: #('byte' 'bytes' 'KiB' 'MiB' 'GiB' 'TiB' 'PiB' 'EiB' 'ZiB' 'YiB')! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!cookieTimestamp	"Netscape's original proposal defined an Expires header that took a date value in a fixed-length variant format in place of Max-Age: Wdy, DD-Mon-YY HH:MM:SS GMT"	^ GRMappedPrinter		block: [ :timestamp | timestamp asUTC ]		next: self abbreviatedWeekName , ', ' , self paddedDay , '-' , self abbreviatedMonthName , '-' , self paddedYear , ' ' , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'parts-units' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decimalFileSize	^ GRUnitPrinter base: 1000 units: #('byte' 'bytes' 'kB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fullMonthName	^ self monthName: #('January' 'February' 'March' 'April' 'May' 'June' 'July' 'August' 'September' 'October' 'November' 'December')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fullWeekName	^ self weekName: #('Sunday' 'Monday' 'Tuesday' 'Wednesday' 'Thursday' 'Friday' 'Saturday')! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!httpDate	"Answers a printer that formats dates for HTTP1.1 (RFC 2616)"	^ self rfc1123! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isoDate	"Ansers a printer that formats dates according to ISO(YYYY-MM-DD) E.g. 2003-12-24"	^ self paddedYear , $- , self paddedMonth , $- , self paddedDay! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isoTime	"Ansers a printer that formats time according to ISO(HH:MM:SS) E.g. 12:23:34"		^ self paddedHour24 , $: , self paddedMinute , $: , self paddedSecond! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!monthName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date monthIndex ]! !!GRPrinter class methodsFor: 'parts-units' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!numberWithAtLeastDigits: anInteger	^ GRNumberPrinter new		padding: $0;		digits: anInteger;		yourself! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!offsetSign	^ GRMappedPrinter 		block: [ :date | date offset ]		next: (GRSignPrinter new				positivePrinter: $+;				negativePrinter: $-;				yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: (GRNumberPrinter new				padding: $0;				digits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!paddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: (self numberWithAtLeastDigits: 4)! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rfc1123	"Answers a printer that formats dates for HTTP1.1 (RFC 1123). Eg.	Sun, 06 Nov 1994 08:49:37 GMT "		^ GRMappedPrinter 		block: [ :date | 			"For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time)"			date asUTC ]		next: GRSequentialPrinter new , self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rfc822	"Answers a printer that formats dates according to RFC 822 (email). Eg.	Sun, 31 Aug 2008 19:41:46 +0200"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , self offsetSign , self absOffsetHoursPadded , self absOffsetMinutesPadded! !!GRPrinter class methodsFor: 'factory-http' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rfc822WithTimeZone: aString	"Answers a privter that formats dates according to RFC 822 (email) with the given time zone String. Eg.	Sun, 31 Aug 2008 19:41:46 <aString>"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , aString! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!swissCurrency	^ GRSequentialPrinter new , 'CHF ' , GRSignPrinter new , (GRNumberPrinter new			separator: $';			precision: 2;			accuracy: 0.05;			yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unpaddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!usCurrency	^ GRSignPrinter new , $$ , (GRNumberPrinter new			separator: $,;			precision: 2;			yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!weekName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date dayOfWeek ]! !!GRPrinter methodsFor: 'operators' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!, aPrinter 	^ GRSequentialPrinter new , self , aPrinter! !!GRPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pad: aString center: aCharacter to: anInteger	"Pad to the center of aString with aCharacter to at least anInteger characters."	| result index |	anInteger <= aString size		ifTrue: [ ^ aString ].	index := (anInteger - aString size) // 2.	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: index + 1		to: index + aString size		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pad: aString left: aCharacter to: anInteger	"Pad to the left side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: anInteger - aString size + 1		to: anInteger		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pad: aString right: aCharacter to: anInteger	"Pad to the right side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: 1		to: aString size		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject	^ String streamContents: [ :stream | self print: anObject on: stream ]! !!GRPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	"Subclasses override this method to produce some output."! !!GRSequentialPrinter methodsFor: 'operators' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!, aConverter	parts add: aConverter! !!GRSequentialPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	parts := OrderedCollection new! !!GRSequentialPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream 	parts do: [ :each | each print: anObject on: aStream ]! !!GRSignPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self negativePrinter: $-.	self positivePrinter: nil! !!GRSignPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!negativePrinter: aPrinter	"The printer to be used when the number is negative."		negativePrinter := aPrinter! !!GRSignPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!positivePrinter: aPrinter	"The printer to be used when the number is zero or positive."		positivePrinter := aPrinter! !!GRSignPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream 	anObject negative		ifTrue: [ negativePrinter print: anObject on: aStream ]		ifFalse: [ positivePrinter print: anObject on: aStream ]! !!GRStringPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!character: aCharacter	"The character to pad the string with."		character := aCharacter! !!GRStringPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self character: $ ; length: nil.	self trimNone; padNone! !!GRStringPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!length: anInteger	"The maximal size of the string, or the size to pad to."	length := anInteger! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padCenter	"Pad to the center."		pad := #pad:center:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padLeft	"Pad to the left."		pad := #pad:left:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padNone	"Do not pad the input."		pad := nil! !!GRStringPrinter methodsFor: 'padding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!padRight	"Pad to the right."		pad := #pad:right:to:! !!GRStringPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream 	| string |	string := anObject greaseString.	trim isNil		ifFalse: [ string := string perform: trim ].	length isNil ifFalse: [		length < string size 			ifTrue: [ string := string copyFrom: 1 to: length ].		(pad isNil or: [ character isNil ])			ifFalse: [ string := self perform: pad with: string with: character with: length ] ].	aStream nextPutAll: string! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimBoth	"Trim to the left and to the right."	trim := #trimBoth! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimLeft	"Trim to the left and to the right."	trim := #trimLeft! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimNone	"Do not trim the input."	trim := nil! !!GRStringPrinter methodsFor: 'trimming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!trimRight	"Trim to the left and to the right."	trim := #trimRight! !!GRUnitPrinter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base: anInteger units: anArray	^ self new 		base: anInteger;		units: anArray;		yourself! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base: anInteger	base := anInteger! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fractionPrinter: aPrinter	fractionPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self integerPrinter: (GRNumberPrinter new		precision: 0;		yourself).	self fractionPrinter: (GRNumberPrinter new		precision: 1;		yourself)! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!integerPrinter: aPrinter	integerPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: anObject on: aStream	anObject = 1		ifTrue: [ ^ self print: anObject unit: units first on: aStream ].	units allButFirst		inject: anObject asFloat		into: [ :value :each |			value < base				ifFalse: [ value / base ]				ifTrue: [ ^ self print: value unit: each on: aStream ] ]! !!GRUnitPrinter methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!print: aNumber unit: aString on: aStream	(units first = aString or: [ units second = aString ])		ifTrue: [ integerPrinter print: aNumber on: aStream ]		ifFalse: [ fractionPrinter print: aNumber on: aStream ].	aStream nextPut: $ ; nextPutAll: aString! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!units: anArray	units := anArray! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self privateAt: anAssociation key put: anAssociation value.	^ anAssociation! !!GROrderedMultiMap methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!"protocol: adding"addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value |			self privateAt: key put: value ].	^ aDictionary! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey	^ Array streamContents: [ :stream |		1 to: size do: [ :index |			(keys at: index) = aKey				ifTrue: [ stream nextPut: (values at: index) ] ] ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey ifAbsent: absentBlock	| results |	results := self allAt: aKey.	^ results isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ results ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey add: aValue	"Add an association between aKey and aValue. Do not replace existing	values with the same key."		^ self privateAt: aKey put: aValue! !!GROrderedMultiMap methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndAllValuesDo: aTwoArgumentBlock	| seenKeys |	seenKeys := GRSmallOrderedSet new.	1 to: size do: [ :index |		| key |		key := keys at: index.		(seenKeys includes: key) ifFalse: [			aTwoArgumentBlock				value: key				value: (self privateAllAt: key startingAt: index).			seenKeys add: key ] ]! !!GROrderedMultiMap methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAllAt: aKey startingAt: aStartInteger	^ Array new: 2 streamContents: [ :stream |		aStartInteger to: size do: [ :index |			(keys at: index) = aKey				ifTrue: [ stream nextPut: (values at: index) ] ] ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	"This is inefficient and could be optimized."	| removed |	removed := Array new: 2 streamContents: [ :stream |		| index |		[ (index := self findIndexFor: aKey) = 0 ] whileFalse: [			stream nextPut: (self removeIndex: index) ] ].	^ removed isEmpty		ifTrue: [ aBlock value ]		ifFalse: [ removed ]! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self new: 3! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!GRSmallDictionary methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value | self at: key put: value ].	^ aDictionary! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	self isEmpty		ifTrue: [ ^ self errorEmptyCollection ].	^ values at: 1! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associations	"Answer a Collection containing the receiver's associations."	| result |	result := WriteStream on: (Array new: self size).	self associationsDo: [ :assoc | result nextPut: assoc ].	^ result contents! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associationsDo: aBlock	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey	"Answer the value associated with aKey. Raise an exception, if no such key is defined."	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsent: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ aBlock value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsentPut: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ self privateAt: aKey put: aBlock value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifPresent: aBlock	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| index |	index := self findIndexFor: aKey.	^ index = 0 ifFalse: [ aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey put: aValue	"Set the value of aKey to be aValue."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index put: aValue ]		ifTrue: [ self privateAt: aKey put: aValue ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aBlock	1 to: size do: [ :index | aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorEmptyCollection	self error: 'Empty'! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorKeyNotFound	self error: 'Key not found'! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!findIndexFor: aKey	1 to: size do: [ :index |		(keys at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grow	| newKeys newValues |	newKeys := Array new: 2 * size.	newValues := Array new: 2 * size.	1 to: size do: [ :index |		newKeys at: index put: (keys at: index).		newValues at: index put: (values at: index) ].	keys := newKeys.	values := newValues! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!includesKey: aKey	"Answer whether the receiver has a key equal to aKey."	^ (self findIndexFor: aKey) ~= 0! !!GRSmallDictionary methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize: anInteger	self initialize.	size := 0.	keys := Array new: anInteger.	values := Array new: anInteger! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isCollection	^ true! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isEmpty	^ size = 0! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keys	^ keys copyFrom: 1 to: size! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndValuesDo: aBlock	1 to: size do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysDo: aBlock	1 to: size do: [ :each | aBlock value: (keys at: each) ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!noneSatisfy: aOneArgumentBlock	1 to: size do: [ :index |		(aOneArgumentBlock value: (values at: index)) ifTrue: [ ^ false ] ].	^ true! !!GRSmallDictionary methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!notEmpty	^ size ~= 0! !!GRSmallDictionary methodsFor: 'copying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!postCopy	super postCopy.	keys := keys copy.	values := values copy! !!GRSmallDictionary methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self size <= 100		ifTrue: [			| first |			first := true.			self keysAndValuesDo: [ :key :value |				"keysAndValuesDo:separatedBy: would be nice"				first					ifTrue: [ first := false ]					ifFalse: [ aStream space ].				aStream					print: key;					nextPutAll: '->';									print: value ] ]		ifFalse: [			aStream				nextPutAll: 'size ';				print: self size ].	aStream nextPut: $)	! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAt: aKey put: aValue	size = keys size ifTrue: [ self grow ].	keys at: (size := size + 1) put: aKey.	^ values at: size put: aValue! !!GRSmallDictionary methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeIndex: index	| value |	value := values at: index.	index to: size - 1 do:			[ :i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1) ].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^ value! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey	"Remove aKey from the receiver, raise an exception if the element is missing."	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	| index |	index := self findIndexFor: aKey.	index = 0 ifTrue: [ ^ aBlock value ].	^ self removeIndex: index! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ size! !!GRSmallDictionary methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted	^ self values sorted! !!GRSmallDictionary methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted: aTwoArgumentBlock	^ self values sorted: aTwoArgumentBlock! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!values	^ values copyFrom: 1 to: size! !!GROrderedMultiMap2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self privateAt: anAssociation key put: anAssociation value.	^ anAssociation! !!GROrderedMultiMap2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value |			self privateAt: key put: value ].	^ aDictionary! !!GROrderedMultiMap2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey	^ self privateAllAt: aKey startingAt: 1! !!GROrderedMultiMap2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!allAt: aKey ifAbsent: absentBlock	| results |	results := self allAt: aKey.	^ results isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ results ]! !!GROrderedMultiMap2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey add: aValue	"Add an association between aKey and aValue. Do not replace existing	values with the same key."		^ self privateAt: aKey put: aValue! !!GROrderedMultiMap2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndAllValuesDo: aTwoArgumentBlock	| seenKeys |	seenKeys := GRSmallOrderedSet new.	1 to: size * 2 - 1 by: 2 do: [ :index |		| key |		key := table at: index.		(seenKeys includes: key) ifFalse: [			aTwoArgumentBlock				value: key				value: (self privateAllAt: key startingAt: index).			seenKeys add: key ] ]! !!GROrderedMultiMap2 methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAllAt: aKey startingAt: index	^ Array new: 2 streamContents: [ :stream |		index to: size * 2 - 1 by: 2 do: [ :i |			(table at: i) = aKey				ifTrue: [ stream nextPut: (table at: i + 1) ] ] ]! !!GROrderedMultiMap2 methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	"This is inefficient and could be optimized."	| removed |	removed := Array new: 2 streamContents: [ :stream |		| index |		[ (index := self findIndexFor: aKey) = 0 ] whileFalse: [			stream nextPut: (self removeIndex: index) ] ].	^ removed isEmpty		ifTrue: [ aBlock value ]		ifFalse: [ removed ]! !!GRSmallDictionary2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self new: 3! !!GRSmallDictionary2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallDictionary2 class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !!GRSmallDictionary2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!GRSmallDictionary2 methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value | self at: key put: value ].	^ aDictionary! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	self isEmpty		ifTrue: [ ^ self errorEmptyCollection ].	^ table at: 2! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associations	"Answer a Collection containing the receiver's associations."	| result |	result := WriteStream on: (Array new: self size).	self associationsDo: [ :assoc | result nextPut: assoc ].	^ result contents! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!associationsDo: aBlock	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey	"Answer the value associated with aKey. Raise an exception, if no such key is defined."	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsent: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ table at: index + 1 ]		ifTrue: [ aBlock value ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifAbsentPut: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ table at: index + 1 ]		ifTrue: [ self privateAt: aKey put: aBlock value ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey ifPresent: aBlock	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| index |	index := self findIndexFor: aKey.	^ index = 0 ifFalse: [ aBlock value: (table at: index + 1) ]! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!at: aKey put: aValue	"Set the value of aKey to be aValue."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ table at: index + 1 put: aValue ]		ifTrue: [ self privateAt: aKey put: aValue ]! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aBlock	2 to: size * 2 by: 2 do: [ :index |		aBlock value: (table at: index) ]! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorEmptyCollection	self error: 'Empty'! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorKeyNotFound	self error: 'Key not found'! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!findIndexFor: aKey	1 to: size * 2 - 1 by: 2 do: [ :index |		(table at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grow	| newTable |	"#replaceFrom:to:with:startingAt: would be better but not portable"	newTable := Array new: 4 * size.	1 to: size * 2 do: [ :index |		newTable at: index put: (table at: index) ].	table := newTable! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!includesKey: aKey	"Answer whether the receiver has a key equal to aKey."	^ (self findIndexFor: aKey) ~= 0! !!GRSmallDictionary2 methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize: anInteger	self initialize.	size := 0.	table := Array new: anInteger * 2! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isCollection	^ true! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isEmpty	^ size = 0! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keys	| keys i |	size = 0 ifTrue: [ ^ #() ].	i := 1.	keys := Array new: size.	1 to: size * 2 - 1 by: 2 do: [ :index |		keys at: i put: (table at: index).		i := i + 1 ].	^ keys! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysAndValuesDo: aBlock	1 to: size * 2 - 1 by: 2 do: [ :index |		aBlock			value: (table at: index)			value: (table at: index + 1) ]! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!keysDo: aBlock	1 to: size * 2 - 1 by: 2 do: [ :index |			aBlock value: (table at: index) ]! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!noneSatisfy: aOneArgumentBlock	size = 0 ifTrue: [ ^ true ].	2 to: size * 2 by: 2 do: [ :index |		(aOneArgumentBlock value: (table at: index)) ifTrue: [ ^ false ] ].	^ true! !!GRSmallDictionary2 methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!notEmpty	^ size ~= 0! !!GRSmallDictionary2 methodsFor: 'copying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!postCopy	super postCopy.	table := table copy! !!GRSmallDictionary2 methodsFor: 'printing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self size <= 100		ifTrue: [			| first |			first := true.			self keysAndValuesDo: [ :key :value |				"keysAndValuesDo:separatedBy: would be nice"				first					ifTrue: [ first := false ]					ifFalse: [ aStream space ].				aStream					print: key;					nextPutAll: '->';									print: value ] ]		ifFalse: [			aStream				nextPutAll: 'size ';				print: self size ].	aStream nextPut: $)	! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAt: aKey put: aValue	size * 2 = table size ifTrue: [ self grow ].	table at: (size * 2 + 1) put: aKey.	table at: (size * 2 + 2) put: aValue.	size := size + 1.	^ aValue! !!GRSmallDictionary2 methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeIndex: index	| value |	value := table at: index + 1.	index to: size * 2 - 2 do: [ :i | 		table at: i put: (table at: i + 2) ].	table at: size * 2 - 1 put: nil.	table at: size * 2 put: nil.	size := size - 1.	^ value! !!GRSmallDictionary2 methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey	"Remove aKey from the receiver, raise an exception if the element is missing."	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary2 methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	| index |	index := self findIndexFor: aKey.	index = 0 ifTrue: [ ^ aBlock value ].	^ self removeIndex: index! !!GRSmallDictionary2 methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ size! !!GRSmallDictionary2 methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted	^ self values sorted! !!GRSmallDictionary2 methodsFor: 'sorting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!sorted: aTwoArgumentBlock	^ self values sorted: aTwoArgumentBlock! !!GRSmallDictionary2 methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!values	| values i |	size = 0 ifTrue: [ ^ #() ].	i := 1.	values := Array new: size.	2 to: size * 2 by: 2 do: [ :index |		values at: i put: (table at: index).		i := i + 1 ].	^ values! !!GRSmallOrderedSet class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self new: 3! !!GRSmallOrderedSet class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallOrderedSet class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !!GRSmallOrderedSet methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!add: newObject	(self findIndexFor: newObject) = 0		ifTrue: [ self privateAdd: newObject ].	^ newObject! !!GRSmallOrderedSet methodsFor: 'adding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addAll: aCollection	aCollection do: [ :each |		self add: each ].	^ aCollection! !!GRSmallOrderedSet methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aOneArgumentBlock	1 to: size do: [ :i |		aOneArgumentBlock value: (table at: i) ]! !!GRSmallOrderedSet methodsFor: 'enumerating' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!do: aOneArgumentBlock separatedBy: aNiladicBlock	1 to: size do: [ :i |		i > 1 ifTrue: [ aNiladicBlock value ].		aOneArgumentBlock value: (table at: i) ]! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!errorNotFound	self error: 'Not found'! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!findIndexFor: aKey	1 to: size do: [ :index |		(table at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!grow	| newTable |	"#replaceFrom:to:with:startingAt: would be better but not portable"	newTable := Array new: 2 * size.	1 to: size do: [ :index |		newTable at: index put: (table at: index) ].	table := newTable! !!GRSmallOrderedSet methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!includes: anObject	^ (self findIndexFor: anObject) ~= 0! !!GRSmallOrderedSet methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize: anInteger	self initialize.	size := 0.	table := Array new: anInteger! !!GRSmallOrderedSet methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isCollection	^ true! !!GRSmallOrderedSet methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isEmpty	^ size = 0! !!GRSmallOrderedSet methodsFor: 'copying' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!postCopy	super postCopy.	table := table copy! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!privateAdd: newObject	size = table size ifTrue: [ self grow ].	table at: (size := size + 1) put: newObject.! !!GRSmallOrderedSet methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!remove: anObject	^ self remove: anObject ifAbsent: [ self errorNotFound ]! !!GRSmallOrderedSet methodsFor: 'removing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!remove: anObject ifAbsent: aNiladicBlock	| index |	index := self findIndexFor: anObject.	index = 0		ifTrue: [ ^ aNiladicBlock value ]		ifFalse: [ self removeIndex: index ].	^ anObject! !!GRSmallOrderedSet methodsFor: 'private ' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeIndex: index	table at: index put: nil.	index to: size - 1 do: [ :i |		table at: i put: (table at: i + 1) ].	size := size - 1! !!GRSmallOrderedSet methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!size	^ size! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: majorInteger	^ self major: majorInteger minor: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: majorInteger minor: minorInteger	^ self major: majorInteger minor: minorInteger revision: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: majorInteger minor: minorInteger revision: revisionInteger	^ self basicNew		initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger;		yourself! !!GRVersion class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!new	^ self major: 1! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!< otherVersion	(major < otherVersion major) ifTrue: [ ^ true ].	(otherVersion major < major) ifTrue: [ ^ false ].	((minor ifNil: [ 0 ]) < (otherVersion minor ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion minor ifNil: [ 0 ]) < (minor ifNil: [ 0 ])) ifTrue: [ ^ false ].	((revision ifNil: [ 0 ]) < (otherVersion revision ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion revision ifNil: [ 0 ]) < (revision ifNil: [ 0 ])) ifTrue: [ ^ false ].	(stageLabel = otherVersion stage) ifTrue: [		^ ((stageNumber ifNil: [ 1 ]) < (otherVersion stageNumber ifNil: [ 1 ])) ].	stageLabel isNil ifTrue: [ ^ false ].	otherVersion stage isNil ifTrue: [ ^ true ].	^ stageLabel < otherVersion stage		! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!<= otherVersion	^ (self > otherVersion) not! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!= otherVersion	^ (major = otherVersion major) and: [		((minor ifNil: [ 0 ]) = (otherVersion minor ifNil: [ 0 ])) and: [		((revision ifNil: [ 0 ] ) = (otherVersion revision ifNil: [ 0 ])) and: [		(stageLabel = otherVersion stage) and: [		(stageNumber ifNil: [ 1 ]) = (otherVersion stageNumber ifNil: [ 1 ]) ] ] ] ]! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!> otherVersion	^ otherVersion < self! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!>= otherVersion	^ (self < otherVersion) not! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beAlpha	self beAlpha: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beAlpha: anInteger	self stage: #alpha number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beBeta	self beBeta: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beBeta: anInteger	self stage: #beta number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beFinal	self stage: nil number: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beReleaseCandidate	self beReleaseCandidate: nil! !!GRVersion methodsFor: 'convenience' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beReleaseCandidate: anInteger	self stage: #rc number: anInteger! !!GRVersion methodsFor: 'converting' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	^ String streamContents: [ :stream |		stream nextPutAll: major greaseString.		stream nextPut: $..		stream nextPutAll: (minor ifNil: [ 0 ]) greaseString.		revision isNil ifFalse: [			stream nextPut: $..			stream nextPutAll: revision greaseString ].		stageLabel isNil ifFalse: [			stream nextPutAll: stageLabel greaseString.			stageNumber isNil ifFalse: [ stream nextPutAll: stageNumber greaseString ] ] ]! !!GRVersion methodsFor: 'comparing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!hash	^ (major hash		bitXor: (minor ifNil: [ 0 ]) hash)		bitXor: (revision ifNil: [ 0 ]) hash! !!GRVersion methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger	self initialize.	major := majorInteger.	minor := minorInteger.	revision := revisionInteger! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isAlpha	^ stageLabel = #alpha! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isBeta	^ stageLabel = #beta! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isFinal	^ stageLabel isNil! !!GRVersion methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isReleaseCandidate	^ stageLabel = #rc! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major	^ major! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!major: anInteger	major := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!minor	^ minor! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!minor: anInteger	minor := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!revision	^ revision! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!revision: anInteger	revision := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stage	^ stageLabel! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stage: aSymbol number: anInteger	stageLabel := aSymbol.	stageNumber := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stageNumber	^ stageNumber! !!Object methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseDeprecatedApi: apiString details: detailsString 	GRDeprecatedApiNotification new		details: detailsString;		signal: apiString! !!Number methodsFor: '*grease-core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	"Answer an integer of the receiver, in our case we simply truncate the number."	^ self truncated! !"Grease-Core"!!GRPharoLatin1Codec commentStamp: '<historical>' prior: 0!A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).!!GRPharoUtf8Codec commentStamp: 'pmm 2/20/2009 12:51' prior: 0!A WAUtf8Codec is a WACodec optimized for UTF-8.!!GRPharoPlatform commentStamp: 'pmm 6/1/2008 01:03' prior: 0!A WASqueakPlatform is the Squeak implementation of SeasidePlatformSupport, the Seaside class that provides functionality that can not be implemented in a platform independent way.!!GRPharoConverterCodecStream commentStamp: 'pmm 6/25/2012 20:22' prior: 0!A WAConverterCodecStream is a WACodec stream around a TextConverter. It is always in text mode.Instance Variables	converter:		<TextConverter>converter	- the TextConverter used to do the encoding conversion!!GRPharoUtf8CodecStream commentStamp: 'pmm 2/20/2009 12:27' prior: 0!A WAUtf8CodecStream is a WACodecStream optimized for UTF-8 performance in the case where most of the characters are ASCII.!!GRPharoLatin1CodecStream commentStamp: '<historical>' prior: 0!A GRPharoLatin1CodecStream is a WACodecStream optimized for ISO-8859-1 (direct byte to character mapping).!!Number methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!milliseconds	^ self milliSeconds! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	Smalltalk addToStartUpList: self.	self startUp! !!GRPharoRandomProvider class methodsFor: 'public' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextInt: anInteger	"Answer a random integer in the interval [1, anInteger]"	^ mutex critical: [ generator nextInt: anInteger ]! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!randomClass	^ Random! !!GRPharoRandomProvider class methodsFor: 'public' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!randomFrom: aCollection	| random count |	random := self nextInt: aCollection size.	^ aCollection isSequenceable		ifTrue: [ aCollection at: random ]		ifFalse: [			count := 1.			aCollection do: [ :ea |				count = random ifTrue: [ ^ ea ].				count := count + 1 ] ]! !!GRPharoRandomProvider class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!startUp	generator := self randomClass new.	mutex := Semaphore forMutualExclusion! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unload	GRPlatform current removeFromStartUpList: self! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	(self supportsEncoding: aString)		ifFalse: [ self unsupportedEncoding: aString ].	^ self basicNew initializeWithName: aString! !!GRPharoLatin1Codec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ Array with: (self basicForEncoding: 'iso-8859-1')! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportedEncodingNames	^ #('iso-8859-1' 'ISO-8859-1' 'latin-1' 'latin1')! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	"Answer whether the the given encoding name is supported."	^ self supportedEncodingNames includes: aString! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aStringOrByteArray	"Overridden for efficencey."	^ aStringOrByteArray asString! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRPharoLatin1CodecStream on: aReadStream! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRPharoLatin1CodecStream on: aWriteStream! !!GRPharoLatin1Codec methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithName: aString 	self initialize.	name := aString! !!GRPharoLatin1Codec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ name! !!GRPharoGenericCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	(self supportsEncoding: aString)		ifFalse: [ self unsupportedEncoding: aString ].	^ self basicNew initializeWithName: aString! !!GRPharoGenericCodec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ (TextConverter allEncodingNames		select:  [ :each | 			"exclude UFT-8 which is handeled by WAUtf8Codec"			self supportsEncoding: each ])		collect: [ :each |			self basicForEncoding: each greaseString ]! !!GRPharoGenericCodec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportedEncodingNames	"answers the names of the encodings supported by this class"	^ (TextConverter allSubclasses gather: [ :class | class encodingNames ]) asSet asOrderedCollection		removeAllFoundIn: GRPharoLatin1Codec supportedEncodingNames;		removeAllFoundIn: UTF8TextConverter encodingNames;		yourself! !!GRPharoGenericCodec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	"Answer whether the the given encoding name is supported."	^ self supportedEncodingNames includes: aString! !!GRPharoGenericCodec methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!converter	^ TextConverter newForEncoding: self name! !!GRPharoGenericCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aStream	^ self encoderFor: aStream! !!GRPharoGenericCodec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aStream 	^ GRPharoConverterCodecStream 		on: aStream		converter: self converter! !!GRPharoGenericCodec methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeWithName: aString 	self initialize.	name := aString.	urlCodec := (#('iso-8859-15' 'cp-1252') includes: aString) 		ifFalse: [ GRCodec forEncoding: 'utf-8' ]		ifTrue: [ self ]! !!GRPharoGenericCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ name! !!GRPharoGenericCodec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	"RFC 3986: When a new URI scheme defines a component that represents textual data consisting of characters from the Universal Character Set [UCS], the data should first be encoded as octets according to the UTF-8 character encoding."	^ urlCodec! !!GRPharoUtf8Codec class methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!basicForEncoding: aString	^ self new! !!GRPharoUtf8Codec class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!codecs	^ Array with: self new! !!GRPharoUtf8Codec class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!supportsEncoding: aString	^ (#('utf-8' 'UTF-8') includes: aString) or: [ UTF8TextConverter encodingNames includes: aString ]! !!GRPharoUtf8Codec methodsFor: 'decoding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decode: aString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream byte1 byte2 byte3 byte4 unicode stream |	stream := aString readStream.	outStream := WriteStream on: (String new: aString size).	[ stream atEnd not ] whileTrue: [		byte1 := stream next asInteger.		unicode := byte1.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next asInteger.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63) ].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next asInteger.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte4 := stream next asInteger.			(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63) ].		unicode ifNil: [ self invalidUtf8 ].		unicode = 16rFEFF "ignore BOM" ifFalse: [			outStream nextPut: (Character codePoint: unicode) ].		unicode := nil ].	^ outStream contents! !!GRPharoUtf8Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!decoderFor: aStream 	^ GRPharoUtf8CodecStream 		on: aStream		converter: UTF8TextConverter new! !!GRPharoUtf8Codec methodsFor: 'conversion' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encoderFor: aStream 	^ GRPharoUtf8CodecStream 		on: aStream		converter: UTF8TextConverter new! !!GRPharoUtf8Codec methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!invalidUtf8	^ GRInvalidUtf8Error signal: 'Invalid UTF-8 input'! !!GRPharoUtf8Codec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'utf-8'! !!GRPharoUtf8Codec methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!url	^ self! !!Interval methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	"#first (used by SequenceableCollection>>anyOne) is an accessor of	Interval and does not error on an empty Interval."		^ self at: 1! !!Point methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	"Reimplemented because in Pharo 1.4	(4 @ 2) greaseString	ansers  '(4@2)'"	^ String streamContents: [ :stream |		x printOn: stream.		stream nextPut: $@.		(y notNil and: [ y negative ])			ifTrue: [				"Avoid ambiguous @- construct"				stream space ].		y printOn: stream ]! !!ByteArray methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	"ByteArrays should not automatically be converted to Strings. You should use a GRCodec for this."	^ self printString! !!GRSmallDictionary methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!customizeExplorerContents	^ true! !!GRSmallDictionary methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!explorerContents	| contents |		contents := OrderedCollection new.	self keysAndValuesDo: [ :key :value |		contents add: (ObjectExplorerWrapper			with: value			name: (key printString contractTo: 32)			model: self) ].	^ contents! !!GRSmallDictionary methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!hasContentsInExplorer	^ true! !!ScaledDecimal methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encodeOn: aDocument	| converter |	converter := GRSignPrinter new, (GRNumberPrinter new precision: self scale).	converter print: self on: aDocument! !!ScaledDecimal methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	| converter |	converter := GRSignPrinter new, (GRNumberPrinter new precision: self scale).	^ converter print: self! !!WriteStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	^ self next: anInteger putAll: aCollection startingAt: startIndex! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	self initializeXmlTable.	self initializeUrlTable.	self select! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeUrlTable	UrlTable := ByteArray new: 256.	1 to: 256 do: [ :index |		('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~' includes: (Character codePoint: index - 1))			ifTrue: [ UrlTable at: index put: 0 ]			ifFalse: [ UrlTable at: index put: 1 ] ]! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeXmlTable	XmlTable := ByteArray new: 256.	1 to: 256 do: [ :index |		('"<&>' includes: (Character codePoint: index - 1))			ifTrue: [ XmlTable at: index put: 1 ]			ifFalse: [ XmlTable at: index put: 0 ] ]! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!unload	self unselect! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	Smalltalk addToShutDownList: anObject! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!addToStartUpList: aClass	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	SessionManager default registerUserClassNamed: aClass name.! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	^ self useByteArrayLiterals		ifTrue: [ self asMethodReturningByteArrayLiteral: aByteArrayOrString named: aSymbol ]		ifFalse: [ self asMethodReturningByteArrayWithCache: aByteArrayOrString named: aSymbol ]! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArrayLiteral: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a byte array using VW/NewCompiler byte array literal syntax."	^ String streamContents: [ :stream |		stream nextPutAll: aSymbol; nextPut: Character cr.		stream tab; nextPutAll: '^ #['.		aByteArrayOrString asByteArray			do: [ :each | each printOn: stream ]			separatedBy: [ stream space ].		stream nextPutAll: ']' ]! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMethodReturningByteArrayWithCache: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a byte array and caching this array in a literal array of size 1."	^ String streamContents: [ :stream |		stream nextPutAll: aSymbol; nextPut: Character cr.		stream tab; nextPutAll: '^ #('.		aByteArrayOrString asByteArray			do: [ :each | each printOn: stream ]			separatedBy: [ stream space ].		stream nextPutAll: ') asByteArray' ]! !!GRPharoPlatform methodsFor: 'encoding' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!base64Decode: aString	^ aString base64Decoded asString! !!GRPharoPlatform methodsFor: 'bindings' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!bindingOf: aClass		^ Smalltalk globals associationAt: aClass name! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!compile: aString into: aClass classified: aSymbol 	aClass compile: aString classified: aSymbol! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!contentsOfFile: aString binary: aBoolean	^ self fileStreamOn: aString do: [ :stream | stream contents ] binary: aBoolean! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	^ Array streamContents: [ :stream | 		FileSystem disk directoriesAt: aPathString do: [ :each |			each basename first = $. ifFalse: [				stream nextPut: each asFileReference fullName  ] ] ]! !!GRPharoPlatform methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!doSilently: aBlock	^ SystemAnnouncer uniqueInstance suspendAllWhile:  aBlock! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!ensureExistenceOfFolder: aString	"creates a folder named aString in the image directory"	FileSystem disk ensureCreateDirectory: aString! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileExists: aString	^ aString asFileReference exists ! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fileStreamOn: aString do: aBlock binary: aBoolean	^ aBoolean		ifTrue: [			FileStream fileNamed: aString do: [ :stream |				stream binary.				aBlock value: stream ] ]		ifFalse: [			MultiByteFileStream fileNamed: aString do: [ :stream |				stream					ascii;					wantsLineEndConversion: true.					aBlock value: stream ] ]! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!filesIn: aPathString	"Return a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	^ Array streamContents: [ :stream | 		FileSystem disk filesAt: aPathString do: [ :each |			each basename first = $. ifFalse: [				stream nextPut: each asFileReference fullName  ] ] ]! !!GRPharoPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."	^ aProcess isTerminated! !!GRPharoPlatform methodsFor: 'version info' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!label	^ 'Pharo'! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!localNameOf: aFilename	^ (FileSystem disk resolveString: aFilename) basename! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.."	^ GRPharoRandomProvider! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!newline	^ String cr! !!GRPharoPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!openDebuggerOn: anError	| process |	process := Processor activeProcess.	"If we are running in the UI process, we don't want to suspend the active process. The	error was presumably triggered while stepping in the Debugger. If we simply immediately	signal an UnhandledError, the debugger will catch this and display the signaling context.	It isn't perfect or pretty but it works."	(ProcessBrowser isUIProcess: process)		ifTrue: [			UnhandledError signalForException: anError ]		ifFalse: [			WorldState addDeferredUIMessage: [				process					debug: anError signalerContext					title: anError description					full: true ].			process suspend ]! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!pathSeparator	^ String with: FileSystem disk delimiter! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteByteStream	"ByteArray based read write stream"		^ ReadWriteStream on: (ByteArray new: 4096)! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!readWriteCharacterStream	"String based read write stream"	^ ReadWriteStream on: (String new: 4096)! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromShutDownList: aClass	"Remove aClass from the shutdown list in the system."	SessionManager default unregisterClassNamed: aClass name! !!GRPharoPlatform methodsFor: 'startup' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeFromStartUpList: aClass	"Remove aClass from the startup list in the system."	SessionManager default unregisterClassNamed: aClass name! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!removeSelector: aSymbol from: aClass	aClass removeSelector: aSymbol! !!GRPharoPlatform methodsFor: 'cryptography' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!secureHashFor: aString	^ SHA1 new hashMessage: aString! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	^ Semaphore! !!GRPharoPlatform methodsFor: 'exceptions' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!stackDepth	| depth current |	depth := 0.	current := thisContext.	[ current isNil ] whileFalse: [		current := current sender.		depth := depth + 1 ].	^ depth - 1! !!GRPharoPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."	aProcess terminate! !!GRPharoPlatform methodsFor: 'processes' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!thisContext	^ thisContext sender! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!useByteArrayLiterals	"whether ByteArray literals can/should be used"	^ true! !!GRPharoPlatform methodsFor: 'factory' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!weakDictionaryOfSize: aNumber	^ IdentityDictionary new: aNumber! !!GRPharoPlatform methodsFor: 'file library' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"writes aStringOrByteArray to a file named aFilenameString in the folder aFolderString"	| folder stream fullFilePath |	folder := FileSystem disk resolveString: aFolderString.	fullFilePath := (folder / aFileNameString) asFileReference.	stream := aStringOrByteArray isString		ifTrue: [			(MultiByteFileStream forceNewFileNamed: fullFilePath fullName)				ascii;				wantsLineEndConversion: true;				yourself ]		ifFalse: [ (FileStream forceNewFileNamed: fullFilePath fullName) binary ].	[ stream nextPutAll: aStringOrByteArray ]		ensure: [ stream close ]! !!Duration class methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!milliseconds: anInteger	^ self milliSeconds: anInteger! !!Duration methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asMilliseconds	^ self asMilliSeconds! !!Duration methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!milliseconds	^ nanos quo: NanosInMillisecond! !!Behavior methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!fullName	"In VW, will include the namespace"	^ self name! !!PositionableStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseUpToAll: aCollection 	"Needed for Seaside ports to other dialects where #upToAll: may have	different semantics"	^ self upToAll: aCollection! !!GRPharoConverterCodecStream class methodsFor: 'instance creation' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!on: aStream converter: aConverter	^ self basicNew initializeOn: aStream converter: aConverter! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	self nextPutAll: (aCollection copyFrom: startIndex to: startIndex + anInteger - 1)! !!GRPharoConverterCodecStream methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initializeOn: aStream converter: aConverter	self initializeOn: aStream.	converter := aConverter! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	| character |	character := converter nextFromStream: stream.	^ character isNil		ifFalse: [ character asCharacter ]! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	| writeStream |	writeStream := WriteStream on: (String new: anInteger).	anInteger timesRepeat: [		writeStream nextPut: (self next			ifNil: [ ^ writeStream contents ]) ].	^ writeStream contents! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	converter nextPut: aCharacter asCharacter toStream: stream! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	aString asString do: [ :each | self nextPut: each ]! !!GRPharoUtf8CodecStream class methodsFor: 'class initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	(Smalltalk hasClassNamed: #UTF8TextConverter) "guard for Squeak 37"		ifFalse: [ ^ self ].	Latin1ToUtf8Map := ByteArray new: 256.	Latin1ToUtf8Encodings := Array new: 256.	0 to: 255 do:[ :index |		| latin1 utf8 |		latin1 := String with: (Character codePoint: index).		utf8 := latin1 convertToWithConverter: UTF8TextConverter new.		latin1 = utf8			ifTrue:[				Latin1ToUtf8Map at: index + 1 put: 0 ] "no translation needed"			ifFalse:[				Latin1ToUtf8Map at: index + 1 put: 1. "no translation needed"				Latin1ToUtf8Encodings at: index + 1 put: utf8 ] ]! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!crlf	stream nextPut: Character cr.	stream nextPut: Character lf! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encodeDefault: aString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	1 to: aString size by: 1 do: [ :index |		converter nextPut: (aString at: index) toStream: stream ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!encodeFast: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| lastIndex nextIndex |	lastIndex := 1.	nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue: [ ^ stream nextPutAll: aByteString ].	[	nextIndex > lastIndex ifTrue: [			stream greaseNext: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex ].		stream nextPutAll: (Latin1ToUtf8Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.		nextIndex = 0 ] whileFalse.	stream greaseNext: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	aCollection isByteString		ifTrue: [ self greaseNext: anInteger putAllFast: aCollection startingAt: startIndex ]		ifFalse: [ super greaseNext: anInteger putAll: aCollection startingAt: startIndex ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAllFast: aByteString startingAt: startIndex	| lastIndex nextIndex |	lastIndex := startIndex.	nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue: [ ^ stream greaseNext: anInteger putAll: aByteString startingAt: startIndex ].	[			nextIndex >= (startIndex + anInteger) ifTrue: [			^ stream greaseNext: startIndex + anInteger - lastIndex  putAll: aByteString startingAt: lastIndex ].		nextIndex > lastIndex ifTrue: [			stream greaseNext: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex ].		stream nextPutAll: (Latin1ToUtf8Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.		(nextIndex = 0 or: [ nextIndex >= (startIndex + anInteger) ]) ] whileFalse.	lastIndex >= (startIndex + anInteger) ifFalse: [		stream greaseNext: startIndex + anInteger - lastIndex putAll: aByteString startingAt: lastIndex ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!invalidUtf8	^ GRInvalidUtf8Error signal: 'Invalid UTF-8 input'! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	^ (self next: 1) first! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| output byte1 byte2 byte3 byte4 unicode count alreadyWide |	output := ByteString new: anInteger.	count := 0.	alreadyWide := false.	[ count < anInteger and: [ stream atEnd not ] ] whileTrue: [		byte1 := stream next.		unicode := byte1.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63).			alreadyWide ifFalse: [				output := WideString withAll: output.				alreadyWide := true ] ].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte4 := stream next.			(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63).			alreadyWide ifFalse: [				output := WideString withAll: output.				alreadyWide := true ] ].		unicode ifNil: [ self invalidUtf8 ].		unicode = 16rFEFF "ignore BOM" ifFalse: [			count := count + 1.			output at: count put: (Character codePoint: unicode) ].		unicode := nil ].	^ count < anInteger		ifTrue: [ output first: count ]		ifFalse: [ output ]! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPut: aCharacter	| codePoint shouldEncode |	codePoint := aCharacter codePoint.	codePoint > 255		ifTrue: [ ^ self nextPutAll: (String with: aCharacter) ].	shouldEncode := Latin1ToUtf8Map at: codePoint + 1.	shouldEncode = 1		ifTrue: [ stream nextPutAll: (Latin1ToUtf8Encodings at: codePoint + 1) ]		ifFalse: [ stream nextPut: aCharacter ]	! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!nextPutAll: aString	aString isByteString		ifTrue: [ self encodeFast: aString ]		ifFalse: [ self encodeDefault: aString ]! !!GRDelegatingStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	stream greaseNext: anInteger putAll: aCollection startingAt: startIndex! !!GRDynamicVariable class methodsFor: 'defaults' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!defaultValue	^ nil! !!GRDynamicVariable class methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!use: anObject during: aBlock	^ self		value: anObject		during: aBlock! !!GRDynamicVariable methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!default	^ self class defaultValue! !!SequenceableCollection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!beginsWithSubCollection: aSequenceableCollection	"Some platforms implement #beginsWith: to answer true for an empty argument."	^ self beginsWith: aSequenceableCollection! !!SequenceableCollection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!endsWithSubCollection: aSequenceableCollection	"Some platforms implement #endsWith: to answer true for an empty argument."	^ self endsWith: aSequenceableCollection! !!SequenceableCollection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30' prior: 61536805!sorted	^ self sorted: [ :a :b | a <= b ]! !!GRPackage class methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greasePharo70Core	^ self new		name: 'Grease-Pharo70-Core';		addDependency: 'Grease-Core';		url: #greaseUrl;		yourself! !!MessageSend methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!argumentCount	^ selector numArgs - self arguments size! !!MessageSend methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithPossibleArguments: anArray	"Evaluate the block represented by the receiver.     If the block requires one argument, use anArg, if it requires more than one,     fill up the rest with nils."	^ self valueWithEnoughArguments: anArray! !!Collection methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!any	^ self anyOne! !!GRPharoLatin1CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next	^ Character value: stream next! !!GRPharoLatin1CodecStream methodsFor: 'streaming' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!next: anInteger	^ (stream next: anInteger) asString! !!SocketStream methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	"Put a String or a ByteArray onto the stream starting at the given position.	Currently a large collection will allocate a large buffer."	| toPut |	anInteger = 0 ifTrue: [		^ aCollection ].	toPut := binary ifTrue: [ aCollection asByteArray ] ifFalse: [ aCollection asString ].	self adjustOutBuffer: anInteger.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + anInteger - 1 with: toPut startingAt: startIndex.	outNextToWrite := outNextToWrite + anInteger.	self checkFlush! !!Character methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseInteger	"Answer an unicode code point of the receiver."	^ self charCode! !!Object methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseString	^ self asString! !!BlockClosure methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!valueWithPossibleArguments: anArray	| args |	(anArray size == self numArgs)		ifTrue: [ ^ self valueWithArguments: anArray ].	args := Array new: self numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self valueWithArguments: args! !!Color methodsFor: '*Grease-Pharo70-Core' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!asHTMLColor	^'#', self asHexString! !"Grease-Pharo70-Core"!!GRObjectInRule commentStamp: 'pmm 9/12/2009 10:37' prior: 0!I detect senders of Object >> #in:!!GRTestAssertionsRule commentStamp: 'pmm 8/17/2014 11:24' prior: 0!I check for TestCase >> #fail.!!GRBasicNewInitializeMissingRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext 	(aContext isMeta not		and: [ (aContext includesSelector: #initialize)		and: [ (#(GRObject GRNotification GRNotification GRError RBLintRule RBTransformationRule) noneSatisfy: [ :each |				aContext includesBehavior: (Smalltalk globals at: each) ])		and: [ aContext class methodDictionary noneSatisfy: [ :each | 				matcher 					executeTree: each parseTree					initialAnswer: false ] ] ] ]) ifTrue: [		result 			addClass: aContext			selector: #initialize ]! !!GRBasicNewInitializeMissingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRBasicNewInitializeMissingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	matcher := RBParseTreeSearcher new.	matcher 		matches: 'self basicNew initialize'		do: [ :node :answer | true ]! !!GRBasicNewInitializeMissingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ '#basicNew initialize is missing'! !!GRBasicNewInitializeMissingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#initialize is not called implicitely when sending #new to an object in other Smalltalk dialects. Consider subclassing GRObject.'! !!GRDeprecatedApiProtocolRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	| matches |	matches := matcher		executeTree: aContext parseTree		initialAnswer: OrderedCollection new.	matches do: [ :node |		" This ensures that the description is of the form ClassName>>#selector:"		(node arguments first isLiteralNode			and: [ node arguments first value isString			and: [ aContext methodClass name greaseString , '>>#' , aContext selector greaseString ~= node arguments first value ] ]) ifTrue: [				result addClass: aContext methodClass selector: aContext selector.				result addSearchString: node arguments first value ].		" This ensures that the description is a string and ends with a dot."		(node arguments size > 1			and: [ node arguments second isLiteralNode			and: [ node arguments second value isString			and: [ (node arguments second value endsWithSubCollection: '.') not ] ] ]) ifTrue: [				result addClass: aContext methodClass selector: aContext selector.				result addSearchString: node arguments second value ] ]! !!GRDeprecatedApiProtocolRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRDeprecatedApiProtocolRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	matcher := RBParseTreeSearcher new.	matcher 		matchesAnyOf: #(			'``@receiver greaseDeprecatedApi: ``@arg1'			'``@receiver greaseDeprecatedApi: ``@arg1 details: ``@arg2' )		do: [ :node :answer | answer add: node; yourself ]! !!GRDeprecatedApiProtocolRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Invalid use of deprecated API protocol.'! !!GRDeprecatedApiProtocolRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Make sure to follow the following pattern: self greaseDeprecatedApi: ''Class>>#selector'' details: ''Some description''.'! !!GREmptyStatementsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	| periods position |	aContext parseTree nodesDo: [ :node |		(node isSequence and: [ node periods notEmpty ]) ifTrue: [			periods := OrderedCollection withAll: node periods.			1 to: node statements size - 1 do: [ :index |				position := periods removeFirst.				((node statements at: index) stop < position and: [ position < (node statements at: index + 1) start ])					ifFalse: [ ^ result addClass: aContext methodClass selector: aContext selector ] ].			(periods isEmpty or: [ periods size = 1 and: [ node statements notEmpty and: [ node statements last stop < periods first ] ] ])				ifFalse: [ ^ result addClass: aContext methodClass selector: aContext selector ] ] ]! !!GREmptyStatementsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GREmptyStatementsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Empty Statements'! !!GREmptyStatementsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Empty statements are not supported by most Smalltalk implementations.'! !!GREmptyStatementsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!resetResult	super resetResult.	result addSearchString: '..'; addSearchString: '.'! !!GRInvalidObjectInitializationRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	(aContext methodClass isMeta not 		and: [ (aContext selector beginsWithSubCollection: #initialize) 		and: [ aContext selector numArgs > 0		and: [ aContext methodClass ~= GRObject		and: [ (aContext methodClass includesBehavior: GRObject)		and: [ (aContext superMessages includes: aContext selector) not 		and: [ aContext selfMessages noneSatisfy: [ :each | each beginsWithSubCollection: #initialize ] ] ] ] ] ] ]) 			ifTrue: [ result addClass: aContext methodClass selector: aContext selector ]! !!GRInvalidObjectInitializationRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRInvalidObjectInitializationRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Invalid object initialization'! !!GRInvalidObjectInitializationRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Initialize methods are required to call the designated initializer or its super implementation.'! !!GRNonPortableMessageRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext	| selectors |	selectors := self methodNames		inject: Set new		into: [ :set :each | 			set				addAll: (aContext whichSelectorsReferTo: each);				yourself ].	selectors do: [ :each | result addClass: aContext selector: each ].	selectors isEmpty		ifFalse: [ result searchStrings: self methodNames ]! !!GRNonPortableMessageRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRNonPortableMessageRule methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!methodNames	^ #( anyOne withIndexCollect: )! !!GRNonPortableMessageRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses non portable message'! !!GRNonPortableMessageRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Some methods are not portable accross different Smalltalk dialects.'! !!GRNonPortableSourceFormatRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext 	| comment |	aContext isMeta 		ifTrue: [ ^ self ].	comment := aContext organization classComment asString.	comment isWideString ifTrue: [		result addClass: aContext ]! !!GRNonPortableSourceFormatRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	| foundLiteral |	foundLiteral := false.	"check individual literals first"	aContext literals do: [ :each | 		(each isString and: [ each isWideString ]) ifTrue: [			result 				addClass: aContext methodClass				selector: aContext selector.			result addSearchString:  each.			foundLiteral := true ] ].		"now check the whole method, could be in comments"	foundLiteral ifFalse: [		aContext sourceCode asString isWideString ifTrue: [			result addClass: aContext methodClass selector: aContext selector ] ]! !!GRNonPortableSourceFormatRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRNonPortableSourceFormatRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Non portable source format'! !!GRNonPortableSourceFormatRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'The method source is required to be a plain string, for portability reasons a wide-string is not supported.'! !!GRSlimeBlockLintRule class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isVisible	^ self name ~= #GRSlimeBlockLintRule! !!GRSlimeBlockLintRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!category	^ self group! !!GRUnnecessaryLastPeriodRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	aContext parseTree nodesDo: [ :node |		node isSequence ifTrue: [			(node statements notEmpty and: [ node periods notEmpty ]) ifTrue: [				node periods last > node statements last stop ifTrue: [					^ result addClass: aContext methodClass selector: aContext selector ] ] ] ]! !!GRUnnecessaryLastPeriodRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRUnnecessaryLastPeriodRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Unnecessary Last Period'! !!GRUnnecessaryLastPeriodRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Periods are not needed after the last satement.'! !!GRUnnecessaryLastPeriodRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!resetResult	super resetResult.	result addSearchString: '..'; addSearchString: '.'! !!GRUsesMethodAnnotationsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	(self shouldExclude: aContext) ifFalse: [		aContext pragmas do: [ :each |			result 				addClass: aContext methodClass				selector: aContext selector.			result addSearchString: each keyword ] ]! !!GRUsesMethodAnnotationsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesMethodAnnotationsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses method annotations'! !!GRUsesMethodAnnotationsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'As of now, it is unclear if method-annotations/pragmas are compatible across all supported platforms. Likely this rule will soon be removed.'! !!GRUsesMethodAnnotationsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!shouldExclude: aContext	"The REST and OmniBrowser related packages are OK to have pragmas"	| classCategory |	classCategory := aContext methodClass theNonMetaClass category.	^ #(#'-REST-' 'OmniBrowser') anySatisfy: [ :each |		 (classCategory indexOfSubCollection: each startingAt: 1) ~= 0 ]! !!GRUsesNotPortableClassRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkClass: aContext 	aContext allSuperclassesDo: [ :each |		(self classNames includes: each name) ifTrue: [			result addClass: aContext.			result addSearchString: each name ] ]! !!GRUsesNotPortableClassRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	(aContext methodClass theNonMetaClass category indexOfSubCollection: #'-Pharo-' startingAt: 1) ~= 0 ifTrue: [		"classes in a -Pharo- package are per definition not portable and therefore allowed to use non-portable classes"		^ self ].	aContext literals do: [ :each | 		(each isVariableBinding and: [ self classNames includes: each key ]) ifTrue: [			result 				addClass: aContext methodClass				selector: aContext selector.			result addSearchString: each key ] ]! !!GRUsesNotPortableClassRule methodsFor: 'private' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!classNames	^ #( Delay MIMEDocument Monitor Mutex MutexSet Random Semaphore TimeStamp Timestamp MessageSend )! !!GRUsesNotPortableClassRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesNotPortableClassRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses not portable class'! !!GRUsesNotPortableClassRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Some classes are not portable accross different Smalltalk dialects.'! !!GRPackage class methodsFor: '*Grease-Pharo40-Slime' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!greaseSlime	^ self new		name: 'Grease-Pharo40-Slime';		description: 'Code critis for Grease. Detects common types of bugs and non-portable code.';		addDependency: 'Grease-Core';		url: #seasideUrl;		yourself! !!GRBlockFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRBlockFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '[ :`@args | | `@temps | ``@.stmts ]'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [					| source |					source := node source.					(source notNil and: [ node left notNil and: [ node right notNil ] ]) ifTrue: [						| before after |						before := source at: node left + 1 ifAbsent: [ $ ].						after := source at: node right - 1 ifAbsent: [ $ ].						(before isSeparator and: [ after isSeparator ])							ifFalse: [ node ]							ifTrue: [								node bar notNil ifTrue: [ 									before := source at: node bar - 1 ifAbsent: [ $ ].									after := source at: node bar + 1 ifAbsent: [ $ ].									(before isSeparator and: [ after isSeparator ])										ifFalse: [ node ] ] ] ] ] ]! !!GRBlockFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Block formatting'! !!GRBlockFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should spaces at the beginning and end of block.'! !!GRParensFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRParensFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '`{ :node | node isValue and: [ node hasParentheses ] }'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [					| found start stop |					found := false.					start := node startWithoutParentheses.					stop := node stopWithoutParentheses.					node parentheses reverseDo: [ :interval |						found := found							or: [ start - 1 ~= interval first							or: [ stop + 1 ~= interval last ] ].						start := interval first.						stop := interval last ].					found ifTrue: [ node ] ] ]! !!GRParensFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Parentheses formatting'! !!GRParensFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should be no spaces inside parentheses.'! !!GRReturnFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRReturnFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '^ ``@expr'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [ 					node start + 2 ~= node value start						ifTrue: [ node ] ] ]! !!GRReturnFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Return formatting'! !!GRReturnFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should be a single space between the ^ and the following expression.'! !!GRSlimeParseTreeLintRule class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isVisible	^ self name ~= #GRSlimeParseTreeLintRule! !!GRSlimeParseTreeLintRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!category	^ self group! !!GRTempsFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Formatting'! !!GRTempsFormattingRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '| `temp `@temps | ``@.stmts'		do: [ :node :answer |			answer isNil 				ifFalse: [ answer ]				ifTrue: [ 					(node leftBar notNil and: [ node rightBar notNil ]) ifTrue: [						| found position |						found := false.						position := node leftBar.						node temporaries do: [ :each | 							found := found or: [ position + 2 ~= each start ].							position := each stop ].						found := found or: [ position + 2 ~= node rightBar ].						found ifTrue: [ node ] ] ] ]! !!GRTempsFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Temporaries formatting'! !!GRTempsFormattingRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'There should be a single space between the | and the individual temps.'! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matchesAnyOf: #(			'`@receiver canPerform: `@selector'			'`@receiver canUnderstand: `@selector' )		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Sends #canPerform: or #canUnderstand:'! !!GRUsesCanPerformOrUnderstandRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#canPerform: or #canUnderstand: are not portable.'! !!GRUsesClassForHashRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext	aContext parseTree selector = #hash		ifTrue: [ super checkMethod: aContext ]! !!GRUsesClassForHashRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesClassForHashRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '`@receiver class hash'		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesClassForHashRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses its class for hash'! !!GRUsesClassForHashRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'The hash of an object should not depend on the hash of its class as some Smalltalk have non-constant class hashes.'! !!GRUsesCurlyBraceArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesCurlyBraceArraysRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '{ `@.stmts }'		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesCurlyBraceArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses curly brace arrays'! !!GRUsesCurlyBraceArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Curly brace expressions are not portable accross different Smalltalk dialects.'! !!GRUsesLiteralByteArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRUsesLiteralByteArraysRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self matcher		matches: '`#literal `{ :node | node isLiteralArray and: [ node isForByteArray ] }'		do: [ :node :answer | answer isNil ifTrue: [ node ] ifFalse: [ answer ] ]! !!GRUsesLiteralByteArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Uses literal byte arrays'! !!GRUsesLiteralByteArraysRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Literal byte arrays are not portable accross different Smalltalk dialects.'! !!GRAnsiBooleansRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiBooleansRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@expr1 and: [ | `@temp2 | ``@expr2 ] and: [ | `@temp3 | ``@expr3 ]'			with: '``@expr1 and: [ | `@temp2 | ``@expr2 and: [ | `@temp3 | ``@expr3 ] ]';		replace: '``@expr1 and: [ | `@temp2 | ``@expr2 ] and: [ | `@temp3 | ``@expr3 ] and: [ | `@temp4 | ``@expr4 ]'			with: '``@expr1 and: [ | `@temp2 | ``@expr2 and: [ | `@temp3 | ``@expr3 and: [ | `@temp4 | ``@expr4 ] ] ]';		replace: '``@expr1 and: [ | `@temp2 | ``@expr2 ] and: [ | `@temp3 | ``@expr3 ] and: [ | `@temp4 | ``@expr4 ] and: [  | `@temp5 | ``@expr5 ]'			with: '``@expr1 and: [ | `@temp2 | ``@expr2 and: [ | `@temp3 | ``@expr3 and: [ | `@temp4 | ``@expr4 and: [ | `@temp5 | ``@expr5 ] ] ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ] or: [ | `@temp4 | ``@expr4 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 or: [ | `@temp4 | ``@expr4 ] ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ] or: [ | `@temp4 | ``@expr4 ] or: [ | `@temp5 | ``@expr5 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 or: [ | `@temp4 | ``@expr4 or: [ | `@temp5 | ``@expr5 ] ] ] ]';		replace: '``@expr1 or: [ | `@temp2 | ``@expr2 ] or: [ | `@temp3 | ``@expr3 ] or: [ | `@temp4 | ``@expr4 ] or: [ | `@temp5 | ``@expr5 ] or: [ | `@temp6 | ``@expr6 ]'			with: '``@expr1 or: [ | `@temp2 | ``@expr2 or: [ | `@temp3 | ``@expr3 or: [ | `@temp4 | ``@expr4 or: [ | `@temp5 | ``@expr5 or: [ | `@temp6 | ``@expr6 ] ] ] ] ]'! !!GRAnsiBooleansRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Booleans'! !!GRAnsiBooleansRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#and:and: and #or:or: are not ANSI compatible.'! !!GRAnsiCharactersRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiCharactersRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: 'Character value: ``@expr' with: 'Character codePoint: ``@expr';		replace: '`#source to: `#target' 			withValueFrom: [ :node |				RBLiteralNode value: (String streamContents: [ :stream |					node receiver value codePoint to: node arguments first value codePoint do: [ :code |						stream nextPut: (Character codePoint: code) ] ]) ]			when: [ :node | 				node receiver value isCharacter					and: [ node arguments first value isCharacter ] ] ! !!GRAnsiCharactersRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Characters'! !!GRAnsiCharactersRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Character value: 64 and $a to: $b is not ANSI compatible.'! !!GRAnsiCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiCollectionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@collection withIndexDo: [ :`each :`index |  | `@temps | ``@.body ]'			with: '``@collection keysAndValuesDo: [ :`index :`each |  | `@temps | ``@.body ]';		replace: '``@collection doWithIndex: [ :`each :`index |  | `@temps | ``@.body ]'			with: '``@collection keysAndValuesDo: [ :`index :`each |  | `@temps | ``@.body ]';		replace: '``@collection collect: ``@block1 thenDo: ``@block2'			with: '(``@collection collect: ``@block1) do: ``@block2';		replace: '``@collection collect: ``@block1 thenSelect: ``@block2'			with: '(``@collection collect: ``@block1) select: ``@block2';		replace: '``@collection pairsDo: [ :`t1 :`t2 | ``@.statements ]'			with: '1 to: ``@collection size by: 2 do:  [ :index | | `t1 `t2 | `t1 := ``@collection at: index. `t2 := ``@collection at: index + 1. ``@.statements ]';		replace: '``@collection reject: ``@block1 thenDo: ``@block2'			with: '(``@collection reject: ``@block1) do: ``@block2';		replace: '``@collection select: ``@block1 thenCollect: ``@block2'			with: '(``@collection select: ``@block1) collect: ``@block2';		replace: '``@collection select: ``@block1 thenDo: ``@block2'			with: '(``@collection select: ``@block1) do: ``@block2';		replace: '``@collection detectSum: [ :`t1 | ``@.statements. `.last ]'			with: '``@collection inject: 0 into: [ :sum :`t1 | ``@.statements. sum + (`.last) ]';		replace: '``@collection valuesDo: ``@block'			with: '``@collection do: ``@block';		replace: '``@collection reversed'			with: '``@collection reverse';			replace: '``@dictionary keysSortedSafely'			with: '``@dictionary keys asSortedCollection';		replace: '``@collectionClass new: ``@size withAll: ``@character'			with: '(``@collectionClass new: ``@size) atAllPut: ``@character'! !!GRAnsiCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Collections'! !!GRAnsiCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Some collection methods are not ANSI compatible: #pairsDo:, #collect:thenDo:, #reject:thenDo:, #detectSum:, #valuesDo:, #keysSortedSafely, #new:withAll:, etc.'! !!GRAnsiConditionalsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiConditionalsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@boolean ifNotNilDo: ``@block'			with: '``@boolean ifNotNil: ``@block';		replace: '``@boolean ifNotNilDo: ``@block1 ifNil: ``@block2'			with: '``@boolean ifNotNil: ``@block1 ifNil: ``@block2';		replace: '``@boolean ifNil: ``@block1 ifNotNilDo: ``@block2'			with: '``@boolean ifNil: ``@block1 ifNotNil: ``@block2';		replace: '``@boolean ifNotNil: [ | `@temps | ``@.body ]'			with: '``@boolean ifNotNil: [ :arg | | `@temps | ``@.body ]';		replace: '``@boolean ifNotNil: [ | `@temps | ``@.body ] ifNil: ``@block '			with: '``@boolean ifNotNil: [ :arg | | `@temps | ``@.body ] ifNil: ``@block';		replace: '``@boolean ifNil: ``@block ifNotNil: [ | `@temps | ``@.body ]'			with: '``@boolean ifNil: ``@block ifNotNil: [ :arg | | `@temps | ``@.body ]'! !!GRAnsiConditionalsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Conditionals'! !!GRAnsiConditionalsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Conditionals like #ifNotNilDo: are not ANSI compatible.'! !!GRAnsiConvertorRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiConvertorRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@object asString' with: '``@object greaseString';		replace: '``@object asInteger' with: '``@object greaseInteger'! !!GRAnsiConvertorRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Convertors'! !!GRAnsiConvertorRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'The ANSI standard does not support #asInteger and #asString on Object.'! !!GRAnsiExceptionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiExceptionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@block on: `class do: [ | `@temps | ``@.body ]'			with: '``@block on: `class do: [ :err | | `@temps | ``@.body ]'! !!GRAnsiExceptionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Exceptions'! !!GRAnsiExceptionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Exception handlers expect exactly one argument in ANSI.'! !!GRAnsiStreamsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiStreamsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '`{ :node :context | node isVariable and: [ (Smalltalk includesKey: node name asSymbol) not and: [ context at: ''`receiver'' ifAbsentPut: [ node ]. true ] ] } cr'			with: '`{ :context | context at: ''`receiver'' } nextPut: Character cr';		replace: '`{ :node :context | node isVariable and: [ (Smalltalk includesKey: node name asSymbol) not and: [ context at: ''`receiver'' ifAbsentPut: [ node ]. true ] ] } lf'			with: '`{ :context | context at: ''`receiver'' } nextPut: Character lf';		replace: '``@stream nextPut: Character cr; nextPut: Character lf'			with: '``@stream crlf';		replace: '``@collection writeStream'			with: 'WriteStream on: ``@collection'! !!GRAnsiStreamsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Streams'! !!GRAnsiStreamsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#cr and #lf are not part of the ANSI stream protocol.'! !!GRAnsiStringsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'ANSI Compatibility'! !!GRAnsiStringsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: 'String tab' with: '(String with: Character tab)';		replace: 'String cr' with: '(String with: Character cr)';		replace: 'String lf' with: '(String with: Character lf)';		replace: 'String crlf' with: '(String with: Character cr with: Character lf)';		replace: 'String space' with: '(String with: Character space)';		replace: '`@string includesSubString: `@subString'			with: '(`@string indexOfSubCollection: `@subString startingAt: 0) ~= 0';		replace: '`@string includesSubstring: `@subString'			with: '(`@string indexOfSubCollection: `@subString startingAt: 0) ~= 0';		replace: '``@string findTokens: ``@arg' withValueFrom: [ :node |			| argument |			argument := node arguments first.			argument isLiteralNode ifTrue: [ 				argument value isArray					ifTrue: [ argument replaceWith: (RBLiteralNode value: (String withAll: argument value)) ].				argument value isCharacter					ifTrue: [ argument replaceWith: (RBLiteralNode value: (String with: argument value)) ] ].			node				selector: #subStrings:;				yourself ]! !!GRAnsiStringsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Strings'! !!GRAnsiStringsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#cr, #crlf, #lf, #space, #tab, #findTokens:, ... are not part of the ANSI string protocol.'! !!GRNotPortableCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRNotPortableCollectionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '`@collection beginsWith: `@subCollection'			with: '`@collection beginsWithSubCollection: `@subCollection';		replace: '`@collection endsWith: `@subCollection'			with: '`@collection endsWithSubCollection: `@subCollection'! !!GRNotPortableCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Collections'! !!GRNotPortableCollectionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ '#beginsWith: and #endsWith: are not portable.'! !!GRObjectInRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'Grease Portability'! !!GRObjectInRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: '``@object in: [ :`var | | `@temps | `@.statements ]'		with: '[ :`var | | `@temps | `@.statements ] value: ``@object'! !!GRObjectInRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'Object>>#in:'! !!GRObjectInRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'Object>>#in: has different semantics on different Smalltalk dialects.'! !!GRSlimeTransformationRule class methodsFor: 'testing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!isVisible	^ self name ~= #GRSlimeTransformationRule! !!GRTestAssertionsRule methodsFor: 'running' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!checkMethod: aContext 	aContext methodClass isMeta		ifTrue: [ ^ self ].	(aContext methodClass allSuperclasses includes:(Smalltalk at: #TestCase))		ifFalse: [ ^ self ].	^ super checkMethod: aContext ! !!GRTestAssertionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!group	^ 'SUnit Compatibility'! !!GRTestAssertionsRule methodsFor: 'initialization' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!initialize	super initialize.	self rewriteRule		replace: 'self fail'			with: 'self assert: false'! !!GRTestAssertionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!name	^ 'TestCase >> #fail'! !!GRTestAssertionsRule methodsFor: 'accessing' stamp: 'CompatibleUserName 3/14/2020 18:25:30'!rationale	^ 'TestCase >> #fail is not portable.'! !"Grease-Pharo40-Slime"!!MAAdaptiveModel commentStamp: 'lr 6/2/2006 00:30' prior: 0!I am an adaptive model referencing a dynamic description of myself and a dictionary mapping those descriptions to actual values.!!MAFileModel commentStamp: 'lr 9/28/2007 08:04' prior: 0!I represent a file with filename, mimetype and contents within the Magritte framework.There are different file-models that you can use with Magritte. The idea is that you set the ==#kind:== of an MAFileDescription to one of the subclasses of ==*MAFileModel*==.!!MAMemoryFileModel commentStamp: 'lr 9/28/2007 08:06' prior: 0!I represent a file using a ByteArray in the object memory. I am not practicable for big files: use me for development and testing only.!!MAObject commentStamp: 'lr 5/17/2006 14:07' prior: 0!I provide functionality available to all Magritte objects. I implement a dictionary of properties, so that extensions can easily store additional data.!!MAAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am the abstract superclass to all accessor strategies. Accessors are used to implement different ways of accessing (reading and writing) data from instances using a common protocol: data can be uniformly read and written using ==#readFrom:== respectively ==#write:to:==.!!MADelegatorAccessor commentStamp: 'lr 2/14/2008 09:56' prior: 0!My access strategy is to delegate to the next accessor. I am not that useful all by myself, but subclasses might override certain methods to intercept access.!!MAChainAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am an access strategy used to chain two access strategies. To read and write a value the ==accessor== is performed on the given model and the result is passed into the ==next== accessor.!!MADictionaryAccessor commentStamp: '<historical>' prior: 0!I am an access strategy to be used on dictionaries. I use my ==key== to read from and write to indexed collections. I am mainly used for prototyping as it allows one to treat dictionaries like objects with object-based instance variables.!!MAIdentityAccessor commentStamp: 'lr 2/12/2006 20:09' prior: 0!I am a read-only access strategy and I answer the model itself when being read.!!MANullAccessor commentStamp: 'lr 5/29/2006 09:21' prior: 0!I am a null access strategy and I should be neither read nor written. I am still comparable to other strategies by holding onto a unique-identifier.!!MAPluggableAccessor commentStamp: 'lr 2/12/2006 20:04' prior: 0!I am an access strategy defined by two block-closures. The read-block expects the model as its first argument and is used to retrieve a value. The write-block expects the model as its first and the value as its second argument and is used to write a value to the model.!!MASelectorAccessor commentStamp: 'lr 6/2/2006 10:03' prior: 0!I am the most common access strategy defined by a read- and a write-selector. I am mostly used together with standard getters and setters as usually defined by the accessing protocol. If there is only a read-selector specified, the write selector will be deduced automatically by adding a colon to the read-selector.!!MAVariableAccessor commentStamp: 'lr 5/27/2006 17:20' prior: 0!I am an access strategy that directly reads from and writes to instance variables. I strongly violate encapsulation and most of the time I should be replaced by an instance of *MASelectorAccessor*.!!MADescription commentStamp: 'lr 2/5/2009 12:42' prior: 0!I am the root of the description hierarchy in Magritte and I provide most of the basic properties available to all descriptions. If you would like to annotate your model with a description have a look at the different subclasses of myself.!!ExampleIf your model has an instance variable called ==title== that should be used to store the title of the object, you could add the following description to your class:=Document class>>descriptionTitle=	^ MAStringDescription new=		autoAccessor: #title;=		label: 'Title';=		priority: 20;=		beRequired;=		yourself.The selector ==#title== is the name of the accessor method used by Magritte to retrieve the value from the model. In the above case Magritte creates the accessor method and the instance variable automatically, if necessary. The label is used to give the field a name and will be printed next to the input box if a visual GUI is created from this description.The write-accessor is automatically deduced by adding a colon to the read-selector, in this example ==#title:==. You can specify your own accessor strategy using one of the subclasses of ==*MAAccessor*==. If you have multiple description within the same object, the ==#priority:== field is used to order them. Assign a low priority to have descriptions traversed first.!!MAContainer commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a container holding a collection of descriptions, all instances of subclasses of *MAElementDescription*. I keep my children within an ==OrderedCollection==, but I don't sort them according to their priority.I fully support the collection protocol: descriptions can be added and removed. Moreover I implement most enumeration methods, so that users are able to iterate (==do:==), filter (==select:==, ==reject:==), transform (==collect:==), extract (==detect:==, ==detect:ifNone:==), and test (==allSatisfy:==, ==anySatisfy:==, ==noneSatisfy:==) my elements.!!MAPriorityContainer commentStamp: 'lr 2/12/2006 19:34' prior: 0!I am a container holding a collection of descriptions and I keep them sorted according to their priority.!!MAElementDescription commentStamp: '<historical>' prior: 0!I am an abstract description for all basic description types.!!MABooleanDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of the Boolean values ==true== and ==false==. My visual representation could be a check-box.!!MAClassDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of Smalltalk classes, possible values can be any of ==Smalltalk allClasses==.!!MAColorDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of colors, possible values are instances of ==Color==. My visual representation could be a color-chooser.!!MAFileDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of files, their contents, filename and mime-type. Possible values include instances of *MAFileModel*. My visual representation could be a file-upload dialog.!!MAMagnitudeDescription commentStamp: 'lr 4/10/2007 21:08' prior: 0!I am an abstract description for subclasses of ==Magnitude==. The range of accepted values can be limited using the accessors ==min:== and ==max:==.!!MADateAndTimeDescription commentStamp: 'pmm 8/31/2009 20:11' prior: 0!I am a description of date and times, possible values are instances of ==DateAndTime==. My visual representation could be a date- and time-picker.!!MADateDescription commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a description of dates, possible values are instances of ==Date==. My visual representation could be a date-picker.!!MADurationDescription commentStamp: 'lr 4/10/2007 21:07' prior: 0!I am a description of durations, possible values are instances of ==Duration==.!!MANumberDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of numbers, possible values are instances of ==Number== and all its subclasses, including ==Integer== and ==Float==. My visual representation could be a number input-box or even a slider-control.!!MATimeDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of times, possible values are instances of ==Time==. My visual representation could be a time-picker.!!MATimeStampDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of timestamps, possible values are instances of ==TimeStamp==. My visual representation could be a date- and time-picker.!!MAReferenceDescription commentStamp: 'lr 2/12/2006 19:38' prior: 0!I am an abstract superclass for descriptions holding onto another description.!!MAOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am an abstract description of different options the user can choose from. My instance variable ==options== references the options I am representing. The options can be sorted or unsorted.!!MAMultipleOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiple options, possible options are stored within the ==options== field, possible values are instances of ==Collection==. My visual representation could be a multi-select list or a group of check-boxes.!!MASingleOptionDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of a single option, possible values are stored within the ==options== field, but I might also be extensible so that the user can add its own option. My visual representation could be a drop-down list or a group of option-buttons.!!MARelationDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am an abstract description for descriptions representing a relation. My instance variable ==classes== references a collection of possible classes that I can relate to. If required the reference description will be automatically built from this list of classes.!!MAToManyRelationDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of an one-to-many relationship, possible values are instances of ==Collection==.!!MAToManyScalarRelationDescription commentStamp: 'pmm 11/3/2006 17:48' prior: 0!Like MAToManyRelationDescription but for scalar values.!!MAToOneRelationDescription commentStamp: '<historical>' prior: 0!I am a description of an one-to-one relationship.!!MATableDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of tables, their cells and labels. I hold a reference to the description of my cells, that are all described using the same description. Possible values include instances of *MATableModel*.!!MATokenDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of tokens all described by the referenced description, possible values are instances of ==SequenceableCollection==.!!MAStringDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of strings, possible values are instances of ==String==. My visual representation could be a single line text-field. Use ==*MAMemoDescription*== for multi-line strings.!!MAMemoDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiline strings, possible values are instances of ==String==. My visual representation could be a text-area field.!!MAPasswordDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of a password string, possible values are instances of ==String==. My visual representation could be a password field, where there are stars printed instead of the characters the user enters.!!MASymbolDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of symbols, possible values are instances of ==Symbol==.!!MAMemento commentStamp: 'SeanDeNigris 4/10/2015 20:07' prior: 0!I am an abstract memento. I reference the model I am working on and the description currently used to describe this model.!!MACachedMemento commentStamp: 'lr 5/29/2006 09:22' prior: 0!I cache values being read and written without touching the model. When committing changes, the modifications will be propagated to the model all at once.!!MACheckedMemento commentStamp: 'lr 5/17/2006 15:12' prior: 0!I cache values as my superclass and also remember the original values of the model at the time the cache is built. With this information I am able to detect edit conflicts and can prevent accidental loss of data by merging the changes.!!MAStraightMemento commentStamp: 'lr 5/17/2006 15:02' prior: 0!I am a memento that forwards read- and write-access directly to the model. I can mostly be replaced with the model itself.!!MAPragmaBuilder commentStamp: 'NickAger 3/7/2012 09:30' prior: 0!I dynamically build container descriptions from instance-side methods decorated pragmas. The pragmas used are:# ==#magritteContainer== to identify the method generating the container instance.# ==#magritteDescription== for unary methods returning valid Magritte descriptions which are added to the container.# ==#magritteDescription:== for single parameter methods returning Magritte description extensions, where the pragma parameter defines the related Magritte description method. The extension method will be called after the related method to refine the description definition.!!MATableModel commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a model class representing a table within the Magritte framework. Internally I store my cells within a flat array, however users may access data giving ''row'' and ''column'' coordinates with ==#at:at:== and ==#at:at:put:==. I can support reshaping myself, but of course this might lead to loss of data-cells.!!MAVisitor commentStamp: 'SeanDeNigris 4/10/2015 20:06' prior: 0!I am a visitor responsible for visiting Magritte descriptions. I am an abstract class providing a default implementation for concrete visitors. The protocol I implement reflects the hierarchy of *MADescription* and its subclasses. Visiting a class which my subclasses don't implement specifically automatically defaults to a less-specific implementation. The code was automatically created using code on my class-side.!!MADescriptionBuilder commentStamp: 'DiegoLont 4/2/2017 22:46' prior: 0!A MADescriptionBuilder is an abstract class for enriching a Magritte description, e.g. setting the component class based on the description class.Instance Variables:	model: the root object	target:  the object the current description belongs to	priority: when multiple builders are used, this determines the priority.	buildedDescription: The result!!MADescriptionFlattener commentStamp: 'DiegoLont 4/2/2017 22:45' prior: 0!MADescriptionFlattener  builds from a description with references to single objects a description, that is more flat. This allows us to render these descriptions, without "cluttered" labels. I.E. a nested description (MAInternalEditor) would render two labels: one for the "main" object and one for the "fields" in that object. Replacing a MAInternalEditor would not help, since this would not replace the label in front of this editor.This description is used in a QCMultipartComponent and this is extracted since, visiting gives us more elegant code for this "complex" behaviour.!!MAStringReader commentStamp: 'SeanDeNigris 4/13/2015 07:57' prior: 0!I recreate Magritte-described domain objects from strings. Typically I am used to convert string values entered into a Magritte form back to the objects they represent. For example, a user may have typed '10/01/2020' into a date field.!!ManifestMagritteModel commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!MADynamicDescriptionCache commentStamp: 'SeanDeNigris 2/19/2018 22:55' prior: 0!I am a dynamic variable that caches descriptions defined in the current call stack. I prevent infinite recursion when a description refers to itself.!!MAError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I represent a generic Magritte error.!!MAReadError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem reading serialized data.!!MAValidationError commentStamp: 'lr 5/17/2006 15:15' prior: 0!I am a generic validation error. I reference the description that caused the validation error.!!MAConditionError commentStamp: 'lr 5/30/2006 23:33' prior: 0!I am an error that is raised whenever a user-defined condition is failing.!!MAConflictError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever there is an edit conflict.!!MAKindError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever a description is applied to the wrong type of data.!!MAMultipleErrors commentStamp: 'lr 5/17/2006 15:18' prior: 0!I am an error that is raised whenever there are multiple validation rules failing.!!MARangeError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a described value is out of bounds.!!MARequiredError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a required value is not supplied.!!MAWriteError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem writing serialized data.!!MAAdaptiveModel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!description: aDescription	^ self new		magritteDescription: aDescription;		yourself! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDescription	^ MAContainer new! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDictionary	^ Dictionary new! !!MAAdaptiveModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	super initialize.	self magritteDescription: self defaultDescription.	self values: self defaultDictionary! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescription	"Answer the description of the receiver."	^ magritteDescription! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescription: aDescription	magritteDescription := aDescription! !!MAAdaptiveModel methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readUsing: aDescription	"Answer the actual value of ==aDescription== within the receiver, ==nil== if not present."	^ self values at: aDescription ifAbsent: [ nil ]! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!values	"Answer a dictionary mapping description to actual values."	^ values! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!values: aDictionary	values := aDictionary! !!MAAdaptiveModel methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject using: aDescription	"Set ==anObject== to be that actual value of the receiver for ==aDescription==."	self values at: aDescription put: anObject! !!MABasicObject class methodsFor: 'error handling' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultErrorClass	^ MAError! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMimeType	^ 'application/octet-stream'! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMimeTypes	^ #( '323' 'text/h323' 'acx' 'application/internet-property-stream' 'ai' 'application/postscript' 'aif' 'audio/x-aiff' 'aifc' 'audio/x-aiff' 'aiff' 'audio/x-aiff' 'asc' 'text/plain' 'asf' 'video/x-ms-asf' 'asr' 'video/x-ms-asf' 'asx' 'video/x-ms-asf' 'au' 'audio/basic' 'avi' 'video/x-msvideo' 'axs' 'application/olescript' 'bas' 'text/plain' 'bcpio' 'application/x-bcpio' 'bin' 'application/octet-stream' 'bmp' 'image/bmp' 'c' 'text/plain' 'cat' 'application/vnd.ms-pkiseccat' 'cc' 'text/plain' 'ccad' 'application/clariscad' 'cdf' 'application/x-netcdf' 'cer' 'application/x-x509-ca-cert' 'class' 'application/octet-stream' 'clp' 'application/x-msclip' 'cmx' 'image/x-cmx' 'cod' 'image/cis-cod' 'cpio' 'application/x-cpio' 'cpt' 'application/mac-compactpro' 'crd' 'application/x-mscardfile' 'crl' 'application/pkix-crl' 'crt' 'application/x-x509-ca-cert' 'csh' 'application/x-csh' 'css' 'text/css' 'dcr' 'application/x-director' 'der' 'application/x-x509-ca-cert' 'dir' 'application/x-director' 'dll' 'application/x-msdownload' 'dms' 'application/octet-stream' 'doc' 'application/msword' 'dot' 'application/msword' 'drw' 'application/drafting' 'dtd' 'application/xml-dtd' 'dvi' 'application/x-dvi' 'dwg' 'application/acad' 'dxf' 'application/dxf' 'dxr' 'application/x-director' 'eps' 'application/postscript' 'etx' 'text/x-setext' 'evy' 'application/envoy' 'exe' 'application/octet-stream' 'ez' 'application/andrew-inset' 'f' 'text/plain' 'f90' 'text/plain' 'fif' 'application/fractals' 'fli' 'video/x-fli' 'flr' 'x-world/x-vrml' 'gif' 'image/gif' 'gtar' 'application/x-gtar' 'gz' 'application/x-gzip' 'h' 'text/plain' 'hdf' 'application/x-hdf' 'hh' 'text/plain' 'hlp' 'application/winhlp' 'hqx' 'application/mac-binhex40' 'hta' 'application/hta' 'htc' 'text/x-component' 'htm' 'text/html' 'html' 'text/html' 'htt' 'text/webviewhtml' 'ice' 'x-conference/x-cooltalk' 'ico' 'image/vnd.microsoft.icon' 'ief' 'image/ief' 'iges' 'model/iges' 'igs' 'model/iges' 'iii' 'application/x-iphone' 'ins' 'application/x-internet-signup' 'ips' 'application/x-ipscript' 'ipx' 'application/x-ipix' 'isp' 'application/x-internet-signup' 'jfif' 'image/pipeg' 'jpe' 'image/jpeg' 'jpeg' 'image/jpeg' 'jpg' 'image/jpeg' 'js' 'application/javascript' 'json' 'application/json' 'kar' 'audio/midi' 'latex' 'application/x-latex' 'lha' 'application/octet-stream' 'lsf' 'video/x-la-asf' 'lsp' 'application/x-lisp' 'lsx' 'video/x-la-asf' 'lzh' 'application/octet-stream' 'm' 'text/plain' 'm13' 'application/x-msmediaview' 'm14' 'application/x-msmediaview' 'm3u' 'audio/x-mpegurl' 'man' 'application/x-troff-man' 'mdb' 'application/x-msaccess' 'me' 'application/x-troff-me' 'mesh' 'model/mesh' 'mht' 'message/rfc822' 'mhtml' 'message/rfc822' 'mid' 'audio/midi' 'midi' 'audio/midi' 'mif' 'application/vnd.mif' 'mime' 'www/mime' 'mny' 'application/x-msmoney' 'mov' 'video/quicktime' 'movie' 'video/x-sgi-movie' 'mp2' 'audio/mpeg' 'mp3' 'audio/mpeg' 'mpa' 'video/mpeg' 'mpe' 'video/mpeg' 'mpeg' 'video/mpeg' 'mpg' 'video/mpeg' 'mpga' 'audio/mpeg' 'mpp' 'application/vnd.ms-project' 'mpv2' 'video/mpeg' 'ms' 'application/x-troff-ms' 'msh' 'model/mesh' 'mvb' 'application/x-msmediaview' 'nc' 'application/x-netcdf' 'nws' 'message/rfc822' 'oda' 'application/oda' 'ogg' 'application/ogg' 'p10' 'application/pkcs10' 'p12' 'application/x-pkcs12' 'p7b' 'application/x-pkcs7-certificates' 'p7c' 'application/x-pkcs7-mime' 'p7m' 'application/x-pkcs7-mime' 'p7r' 'application/x-pkcs7-certreqresp' 'p7s' 'application/x-pkcs7-signature' 'pbm' 'image/x-portable-bitmap' 'pdb' 'chemical/x-pdb' 'pdf' 'application/pdf' 'pfx' 'application/x-pkcs12' 'pgm' 'image/x-portable-graymap' 'pgn' 'application/x-chess-pgn' 'pko' 'application/ynd.ms-pkipko' 'pma' 'application/x-perfmon' 'pmc' 'application/x-perfmon' 'pml' 'application/x-perfmon' 'pmr' 'application/x-perfmon' 'pmw' 'application/x-perfmon' 'png' 'image/png' 'pnm' 'image/x-portable-anymap' 'pot' 'application/mspowerpoint' 'ppm' 'image/x-portable-pixmap' 'pps' 'application/mspowerpoint' 'ppt' 'application/mspowerpoint' 'ppz' 'application/mspowerpoint' 'pre' 'application/x-freelance' 'prf' 'application/pics-rules' 'prt' 'application/pro_eng' 'ps' 'application/postscript' 'pub' 'application/x-mspublisher' 'qt' 'video/quicktime' 'ra' 'audio/x-realaudio' 'ram' 'audio/x-pn-realaudio' 'ras' 'image/cmu-raster' 'rgb' 'image/x-rgb' 'rm' 'audio/x-pn-realaudio' 'rmi' 'audio/mid' 'roff' 'application/x-troff' 'rpm' 'audio/x-pn-realaudio-plugin' 'rtf' 'application/rtf' 'rtx' 'text/richtext' 'scd' 'application/x-msschedule' 'scm' 'application/x-lotusscreencam' 'sct' 'text/scriptlet' 'set' 'application/set' 'setpay' 'application/set-payment-initiation' 'setreg' 'application/set-registration-initiation' 'sgm' 'text/sgml' 'sgml' 'text/sgml' 'sh' 'application/x-sh' 'shar' 'application/x-shar' 'silo' 'model/mesh' 'sit' 'application/x-stuffit' 'skd' 'application/x-koan' 'skm' 'application/x-koan' 'skp' 'application/x-koan' 'skt' 'application/x-koan' 'smi' 'application/smil' 'smil' 'application/smil' 'snd' 'audio/basic' 'sol' 'application/solids' 'spc' 'application/x-pkcs7-certificates' 'spl' 'application/futuresplash' 'src' 'application/x-wais-source' 'sst' 'application/vnd.ms-pkicertstore' 'step' 'application/STEP' 'stl' 'application/vnd.ms-pkistl' 'stm' 'text/html' 'stp' 'application/STEP' 'sv4cpio' 'application/x-sv4cpio' 'sv4crc' 'application/x-sv4crc' 'svg' 'image/svg+xml' 'swf' 'application/x-shockwave-flash' 't' 'application/x-troff' 'tar' 'application/x-tar' 'tcl' 'application/x-tcl' 'tex' 'application/x-tex' 'texi' 'application/x-texinfo' 'texinfo' 'application/x-texinfo' 'tgz' 'application/x-compressed' 'tif' 'image/tiff' 'tiff' 'image/tiff' 'tr' 'application/x-troff' 'trm' 'application/x-msterminal' 'tsi' 'audio/TSP-audio' 'tsp' 'application/dsptype' 'tsv' 'text/tab-separated-values' 'txt' 'text/plain' 'uls' 'text/iuls' 'unv' 'application/i-deas' 'ustar' 'application/x-ustar' 'vcd' 'application/x-cdlink' 'vcf' 'text/x-vcard' 'vda' 'application/vda' 'viv' 'video/vnd.vivo' 'vivo' 'video/vnd.vivo' 'vrml' 'model/vrml' 'wav' 'audio/x-wav' 'wcm' 'application/vnd.ms-works' 'wdb' 'application/vnd.ms-works' 'wks' 'application/vnd.ms-works' 'wmf' 'application/x-msmetafile' 'wps' 'application/vnd.ms-works' 'wri' 'application/x-mswrite' 'wrl' 'model/vrml' 'wrz' 'x-world/x-vrml' 'xaf' 'x-world/x-vrml' 'xbm' 'image/x-xbitmap' 'xhtml' 'application/xhtml+xml' 'xla' 'application/vnd.ms-excel' 'xlc' 'application/vnd.ms-excel' 'xll' 'application/vnd.ms-excel' 'xlm' 'application/vnd.ms-excel' 'xls' 'application/vnd.ms-excel' 'xlt' 'application/vnd.ms-excel' 'xlw' 'application/vnd.ms-excel' 'xml' 'text/xml' 'xof' 'x-world/x-vrml' 'xpm' 'image/x-xpixmap' 'xwd' 'image/x-xwindowdump' 'xyz' 'chemical/x-pdb' 'z' 'application/x-compress' 'zip' 'application/zip' )! !!MAFileModel class methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	MimeTypes := Dictionary new.	1 to: self defaultMimeTypes size by: 2 do: [ :index |		MimeTypes 			at: (self defaultMimeTypes at: index)			put: (self defaultMimeTypes at: index + 1) ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!mimetypeFor: aString	^ self mimetypes at: aString ifAbsent: [ self defaultMimeType ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!mimetypes	^ MimeTypes! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validCharacters	"Answer a string with all the valid characters for filenames."		^ '-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'! !!MAFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ self species = anObject species		and: [ self filename = anObject filename		and: [ self mimetype = anObject mimetype ] ]! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents	"Answer the contents of the file. This method is supposed to be overridden by concrete subclasses."	self subclassResponsibility! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents: aByteArray	"Set the contents of the receiver. This method is supposed to be overridden by concrete subclasses."	filesize := aByteArray size! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!extension	"Answer the file-extension."	^ self filename copyAfterLast: $.! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!filename	"Answer the filename of the receiver."	^ filename! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!filename: aString	"Normalize the filenames. Don't just allow any stupid windows filename.'"	filename := aString isNil ifFalse: [ 		aString collect: [ :char |			(self class validCharacters includes: char)				ifTrue: [ char ]				ifFalse: [ 					char = Character space						ifTrue: [ $- ]						ifFalse: [ $_ ] ] ] ]! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!filesize	"Answer the size of the file."	^ filesize! !!MAFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!finalize	"Cleanup after a file is removed, subclasses might require to specialize this method."		self initialize! !!MAFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ self filename hash bitXor: self mimetype hash! !!MAFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	super initialize.	filesize := 0.	filename := 'unknown'.	mimetype := self class defaultMimeType! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isApplication	"Return ==true== if the mimetype of the receiver is application-data. This message will match types like: application/postscript, application/zip, application/pdf, etc."	^ self maintype = 'application'! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAudio	"Return ==true== if the mimetype of the receiver is audio-data. This message will match types like: audio/basic, audio/tone, audio/mpeg, etc."	^ self maintype = 'audio'! !!MAFileModel methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isEmpty	^ self filesize isZero! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isImage	"Return ==true== if the mimetype of the receiver is image-data. This message will match types like: image/jpeg, image/gif, image/png, image/tiff, etc."	^ self maintype = 'image'! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isText	"Return ==true== if the mimetype of the receiver is text-data. This message will match types like: text/plain, text/html, text/sgml, text/css, text/xml, text/richtext, etc."	^ self maintype = 'text'! !!MAFileModel methodsFor: 'testing-types' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isVideo	"Return ==true== if the mimetype of the receiver is video-data. This message will match types like: video/mpeg, video/quicktime, etc."	^ self maintype = 'video'! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maintype	"Answer the first part of the mime-type."	^ self mimetype copyUpTo: $/! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!mimetype	"Answer the mimetype of the receiver."	^ mimetype! !!MAFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!mimetype: aString	mimetype := aString! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readStream	^ self contents readStream! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!subtype	"Answer the second part of the mime-type."	^ self mimetype copyAfter: $/! !!MAMemoryFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject    ^ super = anObject and: [ self contents = anObject contents ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents	^ contents ifNil: [ contents := ByteArray new ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents: aByteArray	super contents: aByteArray.	contents := aByteArray asByteArray! !!MAMemoryFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!finalize	super finalize.	contents := nil! !!MAMemoryFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self contents hash! !!MAAccessor methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asAccessor	^ self! !!MAAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	"Test if ==aModel== can be read."	^ false! !!MAAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canWrite: aModel	"Test if ==aModel== can be written."	^ false! !!MAAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultLabelFor: aDescription	^ aDescription class defaultLabel! !!MAAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!handlesSelector: aSelector	^ false! !!MAAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printOn: aStream	self storeOn: aStream! !!MAAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	"Read from ==aModel== using the access-strategy of the receiver."	^ nil! !!MAAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	self class storeOn: aStream.	aStream nextPutAll: ' new'! !!MAAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel	"Write ==anObject== to ==aModel== using the access-strategy of the receiver."! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!accessors: aSequenceableCollection	aSequenceableCollection isEmpty		ifTrue: [ self error: 'Unable to create accessor sequence from empty collection.' ].	aSequenceableCollection size = 1		ifTrue: [ ^ aSequenceableCollection first asAccessor ].	^ self 		on: aSequenceableCollection first asAccessor 		accessor: (self accessors: aSequenceableCollection allButFirst)! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!on: anAccessor accessor: anotherAccessor	^ (self on: anAccessor) accessor: anotherAccessor! !!MAChainAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject and: [ self accessor = anObject accessor ]! !!MAChainAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!accessor	^ accessor! !!MAChainAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!accessor: anAccessor	accessor := anAccessor! !!MAChainAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	^ (super canRead: aModel) and: [ self accessor canRead: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canWrite: aModel	^ (super canRead: aModel) and: [ self accessor canWrite: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionAccessor	<magritteDescription>	^ MAToOneRelationDescription new			reference: MAStringDescription new;			accessor: #accessor;			classes: MAAccessor allSubclasses;			priority: 200;			yourself! !!MAChainAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self accessor hash! !!MAChainAccessor methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	accessor := accessor copy! !!MAChainAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ self accessor read: (super read: aModel)! !!MAChainAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPutAll: ' accessor: ';		store: self accessor;		nextPut: $)! !!MAChainAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel	self accessor write: anObject to: (super read: aModel)! !!MADelegatorAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MADelegatorAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!on: anAccessor	^ self new next: anAccessor! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject and: [ self next = anObject next ]! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	^ self next canRead: aModel! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canWrite: aModel	^ self next canWrite: aModel! !!MADelegatorAccessor methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionNext	<magritteDescription>	^ MAToOneRelationDescription new			reference: MAStringDescription new;			accessor: #next;			classes: MAAccessor allSubclasses;			priority: 100;			yourself! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^  super hash bitXor: self next hash! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!next	^ next! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!next: anAccessor 	next := anAccessor asAccessor! !!MADelegatorAccessor methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	next := next copy! !!MADelegatorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ self next read: aModel! !!MADelegatorAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPut: $)! !!MADelegatorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel	self next write: anObject to: aModel! !!MADictionaryAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MADictionaryAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!key: aSymbol	^ self new		key: aSymbol;		yourself! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject		and: [ self key = anObject key ]! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	^ true! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canWrite: aModel	^ true! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self key hash! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!key	^ key! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!key: aKey	key := aKey! !!MADictionaryAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ aModel at: self key ifAbsent: [ nil ]! !!MADictionaryAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' key: ';		store: self key;		nextPut: $)! !!MADictionaryAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel	aModel at: self key put: anObject! !!MAIdentityAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAIdentityAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	^ true! !!MAIdentityAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ aModel! !!MAIdentityAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel 	MAWriteError signal: 'Not supposed to write to ' , aModel greaseString , '.'! !!MANullAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!new	| random uuid |	random := GRPlatform current newRandom.	uuid := Array new: 16.	1 to: 16 do: [ :i | uuid at: i put: (random nextInt: 256) -1 ].	^ self uuid: uuid! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uuid: anObject	^ self basicNew		uuid: anObject;		yourself! !!MANullAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject		and: [ self uuid = anObject uuid ]! !!MANullAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self uuid hash! !!MANullAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel 	MAReadError signal: 'This message is not appropriate for this object'! !!MANullAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' uuid: ';		store: self uuid;		nextPut: $)! !!MANullAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uuid	^ uuid! !!MANullAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uuid: anObject	uuid := anObject! !!MANullAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel 	MAWriteError signal: 'This message is not appropriate for this object'! !!MAPluggableAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAPluggableAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aReadBlock write: aWriteBlock	^ self new		readBlock: aReadBlock;		writeBlock: aWriteBlock;		yourself! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject		and: [ self readBlock = anObject readBlock		and: [ self writeBlock = anObject writeBlock ] ]! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	^ self readBlock notNil! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canWrite: aModel	^ self writeBlock notNil! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: (self readBlock hash bitXor: self writeBlock hash)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ self readBlock value: aModel! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readBlock	^ readBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readBlock: aBlock	readBlock := aBlock! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeBlock: aBlock on: aStream 	aStream nextPutAll: aBlock decompile greaseString allButFirst allButLast! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' read: '.	self storeBlock: self readBlock on: aStream.	aStream nextPutAll: ' write: '.	self storeBlock: self writeBlock on: aStream.	aStream nextPut: $)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel	self writeBlock value: aModel value: anObject! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!writeBlock	^ writeBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!writeBlock: aBlock	writeBlock := aBlock! !!MASelectorAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aReadSelector write: aWriteSelector	^ self new		readSelector: aReadSelector;		writeSelector: aWriteSelector;		yourself! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector: aSelector	^ self new		selector: aSelector;		yourself! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject		and: [ self readSelector = anObject readSelector		and: [ self writeSelector = anObject writeSelector ] ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	^ self readSelector notNil and: [ aModel respondsTo: self readSelector ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canWrite: aModel	^ self writeSelector notNil and: [ aModel respondsTo: self writeSelector ]! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultLabelFor: aDescription	^ self readSelector asString normalizeCamelCase capitalized! !!MASelectorAccessor methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionSelector	<magritteDescription>	^ MASymbolDescription new			accessor: #selector;			yourself! !!MASelectorAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fieldDescription	^ self readSelector asString! !!MASelectorAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!handlesSelector: aSelector	^ aSelector = self readSelector or: [ aSelector = self writeSelector ]! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^  super hash bitXor: (self readSelector hash bitXor: self writeSelector hash)! !!MASelectorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ aModel perform: self readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readSelector	^ readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readSelector: aSelector	readSelector := aSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector	^ self readSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector: aSelector 	self readSelector: aSelector asSymbol.	self writeSelector: (aSelector greaseString copyWith: $:) asSymbol! !!MASelectorAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' read: ';		store: self readSelector;		nextPutAll: ' write: ';		store: self writeSelector;		nextPut: $)! !!MASelectorAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel	^ aModel perform: self writeSelector with: anObject! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!writeSelector	^ writeSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!writeSelector: aSelector	writeSelector := aSelector! !!MAVariableAccessor class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAVariableAccessor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!name: aString	^ self new		name: aString;		yourself! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject and: [ self name = anObject name ]! !!MAVariableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canRead: aModel	^ aModel class allInstVarNames includes: self name asSymbol! !!MAVariableAccessor methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canWrite: aModel	^ self canRead: aModel! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self name hash! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!name	^ name! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!name: aString	name := aString! !!MAVariableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ aModel instVarNamed: self name! !!MAVariableAccessor methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: ';		store: self name;		nextPut: $)! !!MAVariableAccessor methodsFor: 'model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject to: aModel	aModel instVarNamed: self name put: anObject! !!MACondition class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ self name = #MACondition! !!MACondition class methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!receiver: anObject selector: aSelector	^ self receiver: anObject selector: aSelector arguments: #(nil) index: 1! !!MACondition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!receiver: anObject selector: aSelector arguments: anArray index: anInteger	(aSelector numArgs = anArray size)		ifFalse: [ self error: 'Invalid number of arguments.' ].	(anInteger between: 0 and: anArray size)		ifFalse: [ self error: 'Index out of bounds.' ].	^ MAPluggableCondition new 		initializeReceiver: anObject		selector: aSelector		arguments: anArray		index: anInteger! !!MACondition class methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector: aSelector	^ self receiver: nil selector: aSelector arguments: #() index: 0! !!MACondition class methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector: aSelector argument: anObject	^ self receiver: nil selector: aSelector arguments: (Array with: anObject) index: 0! !!MACondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!& aCondition 	^ MAConjunctiveCondition new & self & aCondition! !!MACondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!not	^ MANegationCondition with: self! !!MACondition methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!numArgs	^ 1! !!MACondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value: anObject	self subclassResponsibility! !!MACondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!| aCondition 	^ (self not & aCondition not) not! !!MAConjunctiveCondition methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!& aCondition	conditions := conditions copyWith: aCondition! !!MAConjunctiveCondition methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	conditions := #()! !!MAConjunctiveCondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value: anObject	^ conditions allSatisfy: [ :each | each value: anObject ]! !!MANegationCondition class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!with: aCondition	^ self new initializeWith: aCondition! !!MANegationCondition methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initializeWith: aCondition	condition := aCondition! !!MANegationCondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value: anObject	^ (condition value: anObject) not! !!MAPluggableCondition methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initializeReceiver: anObject selector: aSelector arguments: anArray index: anInteger	receiver := anObject.	selector := aSelector.	arguments := anArray.	index := anInteger! !!MAPluggableCondition methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value: anObject	| actualReceiver actualArguments |	actualReceiver := index = 0		ifFalse: [ receiver ]		ifTrue: [ anObject ].	actualArguments := index > 0		ifFalse: [ arguments ]		ifTrue: [			arguments copy 				at: index put: anObject;				yourself ].	^ actualReceiver		perform: selector		withArguments: actualArguments! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultAccessor	^ MAIdentityAccessor new! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultCollection	^ OrderedCollection new! !!MAContainer class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!with: aDescription	^ self new		add: aDescription;		yourself! !!MAContainer class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!MAContainer methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!MAContainer methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitContainer: self! !!MAContainer methodsFor: 'adding' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!add: aDescription	self children add: aDescription! !!MAContainer methodsFor: 'adding' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addAll: aCollection	self children addAll: aCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!allSatisfy: aBlock	^ self children allSatisfy: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!anySatisfy: aBlock	^ self children anySatisfy: aBlock! !!MAContainer methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asContainer	^ self! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!at: anIndex	^ self children at: anIndex! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!at: anIndex ifAbsent: aBlock	^ self children at: anIndex ifAbsent: aBlock! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!children	^ children! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!collect: aBlock	^ self copy		setChildren: (self children collect: aBlock);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyEmpty	^ self copy		setChildren: self class defaultCollection;		yourself! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyFrom: aStartIndex to: anEndIndex	^ self copy		setChildren: (self children			copyFrom: aStartIndex			to: anEndIndex);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyWithout: anObject	^self reject: [:each | each = anObject]! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyWithoutAll: aCollection	^self reject: [:each | aCollection includes: each]! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionBuilder	^self propertyAt: #descriptionBuilder ifAbsent: [ nil ]! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionBuilder: aBuilderClass	self propertyAt: #descriptionBuilder put: aBuilderClass! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionBuilders	^self propertyAt: #descriptionBuilders ifAbsent: [ #() ]! !!MAContainer methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionBuilders: aList 	self descriptionBuilder: MAComposedDescriptionBuilder.	self propertyAt: #descriptionBuilders put: aList! !!MAContainer methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionChildren	<magritteDescription>	^ MAToManyRelationDescription new		accessor: (MASelectorAccessor read: #children write: #setChildren:);		classes: MAElementDescription withAllConcreteClasses;		default: self class defaultCollection;		label: 'Elements';		priority: 400;		beOrdered;		yourself! !!MAContainer methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionDefault	<magritteDescription>	^ nil! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!detect: aBlock	^ self children detect: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!detect: aBlock ifNone: anExceptionBlock	^ self children detect: aBlock ifNone: anExceptionBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!do: aBlock	self children do: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!do: aBlock separatedBy: aSeparatorBlock	self children do: aBlock separatedBy: aSeparatorBlock! !!MAContainer methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!errorNotFound: aDescription	self error: aDescription class label , ' not found.'! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hasChildren	^ self notEmpty! !!MAContainer methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self children hash! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!includes: aDescription	^ self children includes: aDescription! !!MAContainer methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	super initialize.	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!inject: anObject into: aBlock	^ self children inject: anObject into: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!intersection: aCollection	^ self copy		setChildren: (self children intersection: aCollection);		yourself! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isContainer	^ true! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isEmpty	^ self children isEmpty! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!keysAndValuesDo: aBlock	self children keysAndValuesDo: aBlock! !!MAContainer methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteTemplate	^ self! !!MAContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!moveDown: aDescription	self children moveDown: aDescription! !!MAContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!moveUp: aDescription	self children moveUp: aDescription! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!noneSatisfy: aBlock	^ self children noneSatisfy: aBlock! !!MAContainer methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!notEmpty	^ self children notEmpty! !!MAContainer methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	self setChildren: self children copy! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reject: aBlock	^ self copy		setChildren: (self children reject: aBlock);		yourself! !!MAContainer methodsFor: 'removing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!remove: aDescription	self children remove: aDescription ifAbsent: [ self errorNotFound: aDescription ]! !!MAContainer methodsFor: 'removing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!removeAll	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!select: aBlock	^ self copy		setChildren: (self children select: aBlock);		yourself! !!MAContainer methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setChildren: aCollection	children := aCollection! !!MAContainer methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!size	^ self children size! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!union: aContainer	^ self copy		addAll: (aContainer reject: [ :each | self includes: each ]);		yourself! !!MAContainer methodsFor: 'enumerating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!with: aCollection do: aBlock	self children with: aCollection do: aBlock! !!MAPriorityContainer class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultCollection	^ SortedCollection new! !!MAPriorityContainer methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitPriorityContainer: self! !!MAPriorityContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!moveDown: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'moving' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!moveUp: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!resort	self setChildren: self children copy! !!MAPriorityContainer methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setChildren: aCollection	super setChildren: aCollection asSortedCollection! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultAccessor	^ MANullAccessor new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultComment	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultConditions	^ Array new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDefault	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultGroup	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Object! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultLabel	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultPersistent	^ true! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultPriority	^ 0! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultReadOnly	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultRequired	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultShouldCacheDefault	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultStringReader	^ MAStringReader! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultStringWriter	^ MAStringWriter! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultUndefined	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultValidator	^ MAValidatorVisitor! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultVisible	^ true! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultVisibleInReport	^true! !!MADescription class methodsFor: 'accessing-examples' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!grouping	^ MADescriptionHolder groupOf: self! !!MADescription methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!, aDescription	"Concatenate the receiver and ==aDescription== to one composed description. Answer a description container containing both descriptions."	^ self asContainer copy		addAll: aDescription asContainer;		yourself! !!MADescription methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!<= anObject	"Answer whether the receiver should precede ==anObject== in a priority container."	^ self priority <= anObject priority! !!MADescription methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	^ super = anObject		and: [ self accessor = anObject accessor ]! !!MADescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitDescription: self! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!accessor	"Answer the access-strategy of the model-value described by the receiver."	^ accessor ifNil: [ accessor := self class defaultAccessor ]! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!accessor: anObject	accessor := anObject asAccessor! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addCondition: aCondition 	self 		addCondition: aCondition		labelled: aCondition greaseString! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addCondition: aCondition labelled: aString	"Add ==aCondition== as an additional validation condition to the receiver and give it the label ==aString==. The first argument is either a block-context or any other object that responds to ==#value:== with ==true== or ==false==."	self conditions: (self conditions		copyWith: (Association			key: aCondition			value: aString))! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addCondition: aCondition labelled: aStringOrBlock ifValid: aDescription	self		addCondition: [ :obj | (aDescription isSatisfiedBy: obj) not or: aCondition ] 		labelled: aStringOrBlock! !!MADescription methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asContainer	"Answer a description container of the receiver."	self subclassResponsibility! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beHidden	self visible: false! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beOptional	self required: false! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beReadOnly	self readOnly: true! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beRequired	self required: true! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beVisible	self visible: true! !!MADescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beWriteable	self readOnly: false! !!MADescription methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canExpand	" used to expand a relation description into a group "	^self propertyAt: #canExpand ifAbsent: [ self defaultCanExpand ]! !!MADescription methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canExpand: aBoolean	" used to expand a relation description into a group "	^self propertyAt: #canExpand put: aBoolean! !!MADescription methodsFor: 'accessors' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!chainAccessor: anArray	"Uses ==anArray== of selectors to read from the model."	self accessor: (MAChainAccessor accessors: anArray)! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!comment	"Answer a comment or help-text giving a hint what this description is used for. GUIs that are built from this description might display it as a tool-tip."	^ self propertyAt: #comment ifAbsent: [ self class defaultComment ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!comment: aString	self propertyAt: #comment put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!conditions	"Answer a collection of additional conditions that need to be fulfilled so that the described model is valid. Internally the collection associates conditions with an error string."	^ self propertyAt: #conditions ifAbsent: [ self class defaultConditions ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!conditions: anArray	self propertyAt: #conditions put: anArray! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!conflictErrorMessage	^ self propertyAt: #conflictErrorMessage ifAbsent: [ 'Input is conflicting with concurrent modification' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!conflictErrorMessage: aString	self propertyAt: #conflictErrorMessage put: aString! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!default	^ nil! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!default: anObject! !!MADescription methodsFor: 'builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultCanExpand	" used to expand a relation description into a group "	self isVisible ifFalse: [ ^false ].	self isReadOnly ifTrue: [ ^false ].	self tabDisplay ifTrue: [ ^false ].	self group ifNotNil: [ ^false ].	^true! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultLabel	^ self accessor defaultLabelFor: self! !!MADescription methodsFor: 'owning object' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!describedObject	^ MADynamicDescribedObject value! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionAccessor	<magritteDescription>	^ MAToOneRelationDescription new		reference: MAStringDescription new;		accessor: #accessor;		classes: MAAccessor allSubclasses;		priority: 10;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionComment	<magritteDescription>	^ MAMemoDescription new		accessor: #comment;		label: 'Comment';		priority: 110;		default: self class defaultComment;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionDefault	<magritteDescription>	^ self class isAbstract		ifFalse: [ 			self class new				accessor: #default;				label: 'Default';				priority: 130;				default: self class defaultDefault;				yourself ]! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionGroup	<magritteDescription>	^ MAStringDescription new		accessor: #group;		default: self class defaultGroup;		label: 'Group';		priority: 105;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionLabel	<magritteDescription>	^ MAStringDescription new		accessor: #label;		label: 'Label';		priority: 100;		default: self defaultLabel;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionName	<magritteDescription>	^ MAStringDescription new		accessor: #name;		label: 'Kind';		priority: 0;		beReadOnly;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionPriority	<magritteDescription>	^ MANumberDescription new		accessor: #priority;		label: 'Priority';		priority: 130;		default: self class defaultPriority;		beRequired;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionReadOnly	<magritteDescription>	^ MABooleanDescription new		accessor: #readOnly;		label: 'Read-only';		priority: 200;		default: self class defaultReadOnly;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionRequired	<magritteDescription>	^ MABooleanDescription new		accessor: #required;		label: 'Required';		priority: 220;		default: self class defaultRequired;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionStringReader	<magritteDescription>	^ MASingleOptionDescription new		accessor: #stringReader;		label: 'String Reader';		priority: 300;		default: self class defaultStringReader;		options: self class defaultStringReader withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionStringWriter	<magritteDescription>	^ MASingleOptionDescription new		accessor: #stringWriter;		label: 'String Writer';		priority: 310;		default: self class defaultStringWriter;		options: self class defaultStringWriter withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionUndefined	<magritteDescription>	^ MAStringDescription new		accessor: #undefined;		label: 'Undefined String';		priority: 140;		default: self class defaultUndefined;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionValidator	<magritteDescription>	^ MASingleOptionDescription new		accessor: #validator;		label: 'Validator';		priority: 250;		default: self class defaultValidator;		options: self class defaultValidator withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionVisible	<magritteDescription>	^ MABooleanDescription new		accessor: #visible;		label: 'Visible';		priority: 210;		default: self class defaultVisible;		yourself! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fromString: aString	"Answer an object being parsed from ==aString==."	^ self fromString: aString reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fromString: aString reader: aParser	"Answer an object being parsed from ==aString== using ==aParser==."	^ aParser read: aString readStream description: self! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fromStringCollection: aCollection	"Answer a collection of objects being parsed from ==aCollection== of strings."	^ self fromStringCollection: aCollection reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fromStringCollection: aCollection reader: aParser	"Answer a collection of objects being parsed from ==aCollection== of strings using ==aParser==."	^ aCollection collect: [ :each | self fromString: each reader: aParser ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!group	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	^ self propertyAt: #group ifAbsent: [ self class defaultGroup ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!group: aString	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	self propertyAt: #group put: aString! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hasChildren	"Answer ==true== if the receiver has any child-descriptions. A description container usually has children."	^ false! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hasComment	"Answer ==true== if the the receiver has got a non empty comment."	^ self comment notNil and: [ self comment isEmpty not ]! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hasLabel	"Answer ==true== if the the receiver has got a non empty label."	^ self label notNil and: [ self label isEmpty not ]! !!MADescription methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self accessor hash! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isContainer	"Answer ==true== if the receiver is a description container."	^ false! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isDescription	"Answer ==true== if the receiver is a description."	^ true! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isGrouped	^ false! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isKindDefined	^ self propertyAt: #kind ifPresent: [ :theKind | true] ifAbsent: [ false ]! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isReadOnly	^ self readOnly! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isRequired	^ self required! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSatisfiedBy: anObject	"Answer ==true== if ==anObject== is a valid instance of the receiver's description."	[ self validate: anObject ]		on: MAValidationError		do: [ :err | ^ false ].	^ true! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSortable	"Answer ==true== if the described object can be trivially sorted, e.g. it answers to #<=."	^ false! !!MADescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isVisible	^ self visible! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!kind	"Answer the base-class (type) the receiver is describing. The default implementation answers the most generic class: Object, the root of the Smalltalk class hierarchy. Subclasses might refine this choice."	^ self propertyAt: #kind ifAbsent: [ self class defaultKind ]! !!MADescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!kind: aClass	self propertyAt: #kind put: aClass! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!kindErrorMessage	^ self propertyAt: #kindErrorMessage ifAbsent: [ 'Invalid input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!kindErrorMessage: aString	self propertyAt: #kindErrorMessage put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	"Answer the label of the receiving description. The label is mostly used as an identifier that is printed next to the input field when building a GUI from the receiver."	^ self propertyAt: #label ifAbsent: [ self defaultLabel ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label: aString	self propertyAt: #label put: aString! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!multipleErrorsMessage	^ self propertyAt: #multipleErrorsMessage ifAbsent: [ 'Multiple errors' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!multipleErrorsMessage: aString	self propertyAt: #multipleErrorsMessage put: aString! !!MADescription methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!name	"Answer the name of the description, a human-readable string describing the type."	^ self class label! !!MADescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	accessor := accessor copy! !!MADescription methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' label: '; print: self label.	aStream nextPutAll: ' comment: '; print: self comment! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!priority	"Answer a number that is the priority of the receiving description. Priorities are used to give descriptions an explicit order by sorting them according to this number."	^ self propertyAt: #priority ifAbsent: [ self class defaultPriority ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!priority: aNumber	self propertyAt: #priority put: aNumber! !!MADescription methodsFor: 'accessors' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!propertyAccessor: aSelector	"Uses ==aSelector== to read from the property dictionary of the model."	self accessor: ((MAChainAccessor on: #properties) 		accessor: (MADictionaryAccessor key: aSelector))! !!MADescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aModel	^ self accessor read: aModel! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readOnly	"Test whether my model is read-only."	^ self propertyAt: #readOnly ifAbsent: [ self class defaultReadOnly ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readOnly: aBoolean	self propertyAt: #readOnly put: aBoolean! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!required	"Answer ==true== if the model described by the receiver is required, this is it cannot be ==nil==."	^ self propertyAt: #required ifAbsent: [ self class defaultRequired ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!required: aBoolean	self propertyAt: #required put: aBoolean! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!requiredErrorMessage	^ self propertyAt: #requiredErrorMessage ifAbsent: [ 'Input is required but no input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!requiredErrorMessage: aString	self propertyAt: #requiredErrorMessage put: aString! !!MADescription methodsFor: 'accessors' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selectorAccessor: aSelector	"Uses ==aSelector== to read from the model."	self accessor: (MASelectorAccessor selector: aSelector)! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!shouldCacheDefault	^ self propertyAt: #shouldCacheDefault ifAbsent: [ self class defaultShouldCacheDefault ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringReader	"Answer a Visitor that can be used to parse the model described by the receiver from a string."	^ self propertyAt: #stringReader ifAbsent: [ self class defaultStringReader ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringReader: aClass	self propertyAt: #stringReader put: aClass! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringWriter	"Answer a Visitor that can be used to convert the model described by the receiver to a string."	^ self propertyAt: #stringWriter ifAbsent: [ self class defaultStringWriter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringWriter: aClass	self propertyAt: #stringWriter put: aClass! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!toString: anObject	"Answer a string being formatted from ==anObject==."	^ self toString: anObject writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!toString: anObject writer: aFormatter	"Answer a string being formatted from ==anObject== using ==aFormatter==."	^ aFormatter write: anObject description: self! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!toStringCollection: aCollection	"Answer a collection of strings being formatted from ==aCollection==."	^ self toStringCollection: aCollection writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!toStringCollection: aCollection writer: aFormatter	"Answer a collection of strings being formatted from ==aCollection== using ==aFormatter==."	^ aCollection collect: [ :each | self toString: each writer: aFormatter ]! !!MADescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!tryValidation: tryBlock ifPass: passBlock	| shouldContinue |	shouldContinue := true.	tryBlock on: MAValidationError do: [ :e | shouldContinue := false. e pass ].	shouldContinue ifFalse: [ ^ self ].	passBlock value! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!undefined	"Answer a string that is printed whenever the model described by the receiver is ==nil==."	^ (self propertyAt: #undefined ifAbsent: [ self class defaultUndefined ])		ifNil: [ self class defaultUndefined ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!undefined: aString	self propertyAt: #undefined put: aString! !!MADescription methodsFor: 'validation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validate: anObject	"Validate ==anObject== in the context of the describing-receiver, raises an error in case of a problem. If ==anObject== is ==nil== and not required, most tests will be skipped. Do not override this message, instead have a look at ==#validateSpecific:== what is usually a better place to define the behaviour your description requires."	self validator on: anObject description: self! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateConditions: anObject	"Validate ==anObject== to satisfy all its custom conditions."	self conditions do: [ :each |		(each key value: anObject)			ifFalse: [ MAConditionError description: self signal: each value ] ]! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateKind: anObject	"Validate ==anObject== to be of the right kind."	(anObject isKindOf: self kind)		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateRequired: anObject	"Validate ==anObject== not to be ==nil== if it is required."	(self isRequired and: [ anObject isNil ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateSpecific: anObject	"Validate ==anObject== to satisfy its descriptions specific validation rules. Subclasses mostly want to override this method."! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validator	"Answer a Visitor that can be used to validate the model described by the receiver."	^ self propertyAt: #validator ifAbsent: [ self class defaultValidator ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validator: aClass	self propertyAt: #validator put: aClass! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visible	"Answer ==true== if the model described by the receiver is visible, as an opposite to hidden."	^ self propertyAt: #visible ifAbsent: [ self class defaultVisible ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visible: aBoolean	self propertyAt: #visible put: aBoolean! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visibleInReport	^self propertyAt: #visibleInReport ifAbsent: [ self class defaultVisibleInReport ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visibleInReport: aBoolean 	self propertyAt: #visibleInReport put: aBoolean! !!MABlockDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ BlockClosure! !!MABlockDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultLineCount	^ 3! !!MABlockDescription class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MAMemoMorph! !!MABlockDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MABlockDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Block'! !!MABlockDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitBlockDescription: self! !!MABlockDescription methodsFor: 'accessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionLineCount	<magritteDescription>	^ MANumberDescription new		accessor: #lineCount;		label: 'Number of Lines';		priority: 400;		default: self class defaultLineCount;		beInteger;		min: 1;		yourself! !!MABlockDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!lineCount	^ self propertyAt: #lineCount ifAbsent: [ self class defaultLineCount ]! !!MABlockDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!lineCount: anInteger	self propertyAt: #lineCount put: anInteger! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultFalseString	^ self defaultFalseStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultFalseStrings	^ #( 'false' 'f' 'no' 'n' '0' 'off' )! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Boolean! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultTrueString	^ self defaultTrueStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultTrueStrings	^ #( 'true' 't' 'yes' 'y' '1' 'on' )! !!MABooleanDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MABooleanDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Boolean'! !!MABooleanDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitBooleanDescription: self! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!allOptions	^ self options! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!allOptionsWith: anObject	^ self options! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionFalseString	<magritteDescription>	^ MAStringDescription new		accessor: #falseString;		default: self class defaultFalseString;		label: 'False String';		priority: 410;		yourself! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionRequired	<magritteDescription>	^ nil! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionTrueString	<magritteDescription>	^ MAStringDescription new		accessor: #trueString;		default: self class defaultTrueString;		label: 'True String';		priority: 400;		yourself! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!falseString	^ self propertyAt: #falseString ifAbsent: [ self class defaultFalseString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!falseString: aString	self propertyAt: #falseString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!falseStrings	^ self class defaultFalseStrings! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isExtensible	^ false! !!MABooleanDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!labelForOption: anObject	anObject == true		ifTrue: [ ^ self trueString ].	anObject == false		ifTrue: [ ^ self falseString ].	^ self undefined! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!options	^ Array with: false with: true! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reference	^ self! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!trueString	^ self propertyAt: #trueString ifAbsent: [ self class defaultTrueString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!trueString: aString	self propertyAt: #trueString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!trueStrings	^ self class defaultTrueStrings! !!MAClassDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Class! !!MAClassDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAClassDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Class'! !!MAClassDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitClassDescription: self! !!MAColorDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ GRPlatform current magritteColorClass! !!MAColorDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAColorDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Color'! !!MAColorDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitColorDescription: self! !!MAElementDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDisplayProperty	^ #greaseString! !!MAElementDescription class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!new	"override #new so that we can create an object without adding it to the collection returned by: MAElementDescription withAllConcreteClasses,	that is so we can call  MAElementDescription new magritteDescription  and it works as expected, which is used in MADescriptionEditor>>#buildReport .	Yes it's a hack, but it works... (better ideas gratefully received)"	^ self basicNew initialize! !!MAElementDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitElementDescription: self! !!MAElementDescription methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asContainer	^ MAContainer with: self! !!MAElementDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!default	^ self propertyAt: #default ifAbsent: [ self class defaultDefault ]! !!MAElementDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!default: anObject	self propertyAt: #default put: anObject! !!MAElementDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!display: aBlockOrSymbol	"Transform how the file is converted to a string.	aSymbol		- is performed on the object	aBlock		- takes one argument, which is the domain object		- returns the string to display"	self propertyAt: #displayBlockOrSymbol put: aBlockOrSymbol.! !!MAElementDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!displayBlockOrSymbol	^self propertyAt: #displayBlockOrSymbol ifAbsent: [ self class defaultDisplayProperty ]! !!MAElementDescription methodsFor: 'displaying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!displayStringFor: anObject	"Convert object to a string. If a block was passed to #display: use that, otherwise send #greaseString by default"	^self displayBlockOrSymbol value: anObject.! !!MAElementDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!handlesSelector: aSelector	^ self accessor handlesSelector: aSelector! !!MAElementDescription methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printFor: anObject on: aWriteStream 	(self read: anObject) ifNotNil: [ :value | aWriteStream nextPutAll: value asString ]! !!MAElementDescription methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeOn: aStream	aStream 		nextPutAll: self className;		nextPutAll: ' new'; cr.	(self magritteDescription reject: #isReadOnly) do: [ :desc |		| value |		value := desc read: self.		(value ~= desc default and: [ value isNotNil ]) ifTrue: [ 			desc accessor store: value inDescriptionOn: aStream ] ].	aStream nextPutAll: 'yourself'! !!MADirectoryDescription class methodsFor: 'acessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^'Directory'! !!MADirectoryDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitDirectoryDescription: self! !!MAFileDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDisplayProperty	^ [ :e | e fullName ].! !!MAFileDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ MAMemoryFileModel! !!MAFileDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAFileDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'File'! !!MAFileDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitFileDescription: self! !!MAFileDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDirectory	^ self propertyAt: #defaultDirectory ifAbsent: [ MAFileSystem imageDirectory ].! !!MAFileDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDirectory: fileReference	"fileReference - a FileSystem FileReference, or an MAFileReference if FileSystem is not installed"	self propertyAt: #defaultDirectory put: fileReference! !!MADateAndTimeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ DateAndTime! !!MADateAndTimeDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MADateAndTimeDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Date and Time'! !!MADateAndTimeDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitDateAndTimeDescription: self! !!MADateDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDisplayProperty	^ [ :aDateOrNil | 				aDateOrNil					ifNotNil: [ aDateOrNil greaseString ]					ifNil: [ '' ] ]! !!MADateDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Date! !!MADateDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MADateDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Date'! !!MADateDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitDateDescription: self! !!MADurationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Duration! !!MADurationDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MADurationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Duration'! !!MADurationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitDurationDescription: self! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMax	^ nil! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMin	^ nil! !!MAMagnitudeDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitMagnitudeDescription: self! !!MAMagnitudeDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionMax	<magritteDescription>	^ self class new		accessor: #max;		label: 'Maximum';		priority: 410;		yourself! !!MAMagnitudeDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionMin	<magritteDescription>	^ self class new		accessor: #min;		label: 'Min';		priority: 400;		yourself! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSortable	^ true! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isWithinRange: anObject	^ (self min isNil or: [ self min <= anObject ])		and: [ self max isNil or: [ self max >= anObject ] ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!max	^ self propertyAt: #max ifAbsent: [ self class defaultMax ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!max: aMagnitudeOrNil	"Set the maximum for accepted values, or ==nil== if open."	self propertyAt: #max put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!min	^ self propertyAt: #min ifAbsent: [ self class defaultMin ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!min: aMagnitudeOrNil	"Set the minimum for accepted values, or ==nil== if open."	self propertyAt: #min put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'conveniance' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!min: aMinimumObject max: aMaximumObject	"Set the minimum and maximum of accepted values, or ==nil== if open."	self min: aMinimumObject; max: aMaximumObject! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rangeErrorMessage	| min max |	^ self propertyAt: #rangeErrorMessage ifAbsent: [		min := self toString: self min. max := self toString: self max.		(self min notNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be between ' , min , ' and ' , max ].		(self min notNil and: [ self max isNil ])			ifTrue: [ ^ 'Input must be above or equeal to ' , min ].		(self min isNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be below or equal to ' , max ] ]! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rangeErrorMessage: aString	self propertyAt: #rangeErrorMessage put: aString! !!MAMagnitudeDescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateSpecific: anObject	super validateSpecific: anObject.	(self isWithinRange: anObject)		ifFalse: [ MARangeError description: self signal: self rangeErrorMessage ]! !!MANumberDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Number! !!MANumberDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MANumberDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Number'! !!MANumberDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitNumberDescription: self! !!MANumberDescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beInteger	self addCondition: (MACondition selector: #isInteger) labelled: 'No integer was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beNegative	self addCondition: (MACondition selector: #negative) labelled: 'No negative number was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!bePositive	self addCondition: (MACondition selector: #positive) labelled: 'No positive number was entered'! !!MATimeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDisplayProperty	^ [ :time | 		time hour greaseString, ':',		time minute greaseString, ':',		time second greaseString ].! !!MATimeDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Time! !!MATimeDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MATimeDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Time'! !!MATimeDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitTimeDescription: self! !!MATimeStampDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ GRPlatform current magritteTimeStampClass! !!MATimeStampDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MATimeStampDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Timestamp'! !!MATimeStampDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitTimeStampDescription: self! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDistinct	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Collection! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultOrdered	^ false! !!MAMultipleOptionDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Multiple-Option'! !!MAMultipleOptionDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitMultipleOptionDescription: self! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beDistinct	self distinct: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beIndefinite	self distinct: false! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beOrdered	self ordered: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beUnordered	self ordered: false! !!MAMultipleOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionDistinct	<magritteDescription>	^ MABooleanDescription new		accessor: #distinct;		label: 'Distinct';		priority: 250;		default: self class defaultDistinct;		yourself! !!MAMultipleOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionOrdered	<magritteDescription>	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self class defaultOrdered;		yourself! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!distinct	^ self propertyAt: #distinct ifAbsent: [ self class defaultDistinct ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!distinct: aBoolean	self propertyAt: #distinct put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isDistinct	^ self distinct! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isMultiple	^true! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isOrdered	^ self ordered! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateKind: anObject	self 		tryValidation: [ super validateKind: anObject ]	  ifPass: [ anObject do: [ :e | self validateOptionKind: e ] ]! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultExtensible	^ false! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultOptions	^ OrderedCollection new! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultSorted	^ false! !!MAOptionDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitOptionDescription: self! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!allOptions	^ self options maAllOptionsFor: self! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!allOptionsWith: anObject	^ self prepareOptions: ((self shouldNotInclude: anObject)		ifFalse: [ self options copyWith: anObject ]		ifTrue: [ self options copy ])! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beExtensible	self extensible: true! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beLimited	self extensible: false! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beSorted	self sorted: true! !!MAOptionDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beUnsorted	self sorted: false! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionDefault	<magritteDescription>	^ nil! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionExtensible	<magritteDescription>	^ MABooleanDescription new		accessor: #extensible;		label: 'Extensible';		priority: 250;		default: self class defaultExtensible;		yourself! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionOptions	<magritteDescription>	^ MAMemoDescription new		accessor: #optionsTextual;		label: 'Options';		priority: 410;		default: self class defaultOptions;		yourself! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionSorted	<magritteDescription>	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self class defaultSorted;		yourself! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!extensible	^ self propertyAt: #extensible ifAbsent: [ self class defaultExtensible ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!extensible: aBoolean	self propertyAt: #extensible put: aBoolean! !!MAOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isExtensible	^ self extensible! !!MAOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isMultiple	^false! !!MAOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSorted	^ self sorted! !!MAOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!labelForOption: anObject	self propertyAt: #labels ifPresent: [ :labels | labels optionFor: anObject ifPresent: [ :value | ^value ] ].	^ self reference toString: anObject! !!MAOptionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!options	^ options ifNil: [ options := self class defaultOptions ]! !!MAOptionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!options: anArray	options := anArray! !!MAOptionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!optionsAndLabels: aCollection	"Set the options to be the keys of aCollection and the labels to be the values of aCollection."	self options: (aCollection collect: [ :assoc | assoc key ]).	self propertyAt: #labels put: (aCollection		inject: IdentityDictionary new		into: [ :result :assoc | result add: assoc; yourself ])! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!optionsTextual	^ (self reference toStringCollection: self options)		asMultilineString! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!optionsTextual: aString	| lines |	lines := (aString ifNil: [ String new ]) lines.	^ self options: (self reference fromStringCollection: lines)! !!MAOptionDescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	options := options copy! !!MAOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!prepareOptions: aCollection	^ self isSorted		ifFalse: [ aCollection asArray ]		ifTrue: [ 			aCollection asArray				sort: self sortBlock;				yourself ]! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!shouldNotInclude: anObject	^ self isExtensible not or: [ anObject isNil or: [ self options includes: anObject ] ]! !!MAOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!sortBlock	^ [ :a :b | (self reference toString: a) caseInsensitiveLessOrEqual: (self reference toString: b) ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!undefined: aString	super undefined: aString.	self reference isNil		ifFalse: [ self reference undefined: aString ]! !!MAOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateOptionKind: anObject	(self options includes: anObject)		ifTrue: [ ^ self ].	self isExtensible		ifTrue: [ self reference validate: anObject ]		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MASingleOptionDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MASingleOptionDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Single-Option'! !!MASingleOptionDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitSingleOptionDescription: self! !!MASingleOptionDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionGroupBy	<magritteDescription>	^ MASymbolDescription new		selectorAccessor: #groupBy;		label: 'Grouped by';		priority: 260;		default: nil;		yourself! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupBy	^ self propertyAt: #groupBy ifAbsent: [ nil ]! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupBy: anAccessor	"anAccessor to be sent to the options objects for getting their group."		self propertyAt: #groupBy put: anAccessor asAccessor! !!MASingleOptionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isGrouped	^ self groupBy notNil! !!MASingleOptionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!prepareOptions: aCollection	^ self isRequired		ifTrue: [ super prepareOptions: aCollection ]		ifFalse: [ (Array with: nil) , (super prepareOptions: aCollection) ]! !!MASingleOptionDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateKind: anObject	super validateKind: anObject.	self validateOptionKind: anObject! !!MAReferenceDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultReference	^ MAStringDescription new! !!MAReferenceDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitReferenceDescription: self! !!MAReferenceDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionReference	<magritteDescription>	^ MAToOneRelationDescription new		accessor: #reference;		classes: MADescription withAllConcreteClasses;		label: 'Description';		priority: 400;		beRequired;		yourself! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initializer	^ self propertyAt: #initializer ifAbsent: [ #yourself ]! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initializer: valuable	self propertyAt: #initializer put: valuable! !!MAReferenceDescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	reference := reference copy! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reference	^ reference ifNil: [ reference := self class defaultReference ]! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reference: aDescription	reference := aDescription! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultClasses	^ Set new! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultReference	^ nil! !!MARelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitRelationDescription: self! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!allClasses	^ (Array withAll: self classes)		sort: [ :a :b | a label caseInsensitiveLessOrEqual: b label ];		yourself! !!MARelationDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!classes	^ classes ifNil: [ classes := self class defaultClasses ]! !!MARelationDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!classes: aCollection	classes := aCollection! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!commonClass	"Answer a common superclass of the classes of the receiver. The algorithm is implemented to be as efficient as possible. The inner loop will be only executed the first few iterations."	| current |	self classes isEmpty		ifTrue: [ ^ self descriptionContainer ].	current := self classes anyOne.	self classes do: [ :each |		[ each includesBehavior: current ]			whileFalse: [ current := current superclass ] ].	^ current! !!MARelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionClasses	<magritteDescription>	^ MAMultipleOptionDescription new		accessor: #classes;		label: 'Classes';		priority: 400;		options: Smalltalk globals allClasses;		default: Set new; "To avoid storing unneeded empty set [1]"		reference: MAClassDescription new;		yourself		"1. There may be a better way. When generating description methods from meta-meta descriptions, without the line above, an unneeded `default: Set new;` was being added to the generated method."! !!MARelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionReference	<magritteDescription>	^ super descriptionReference		classes: MAContainer withAllConcreteClasses;		beOptional;		yourself! !!MARelationDescription methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	classes := classes copy! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reference	"The reference within a ==*MARelationDescription*== is calculated automatically from all the classes of the receiver, if set to ==nil==. By setting the reference to a ==*MAContainer*== instance it is possible to customize the reference description."	^ super reference ifNil: [ self commonClass magritteTemplate magritteDescription ]! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultDefinitive	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Collection! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultOrdered	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultShouldCacheDefault	^ true! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultSorted	^ false! !!MAToManyRelationDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ '1:m Relation'! !!MAToManyRelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitToManyRelationDescription: self! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beDefinitive	self definitive: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beModifiable	self definitive: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beOrdered	self ordered: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beSorted	self sorted: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beUnordered	self ordered: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beUnsorted	self sorted: false! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!definitive	"Return true if the field is non-modifiable"	^ self propertyAt: #definitive ifAbsent: [ self class defaultDefinitive ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!definitive: aBoolean	self propertyAt: #definitive put: aBoolean! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionDefinitive	<magritteDescription>	^ MABooleanDescription new		accessor: #definitive;		label: 'Definitive';		priority: 265;		default: self class defaultDefinitive;		yourself! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionOrdered	<magritteDescription>	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self class defaultOrdered;		yourself! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionSorted	<magritteDescription>	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self class defaultSorted;		yourself! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isDefinitive	"Return true if the field is non-modifiable"	^ self definitive.! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isOrdered	^ self ordered! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSorted	^ self sorted! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateKind: anObject	self		tryValidation: [ super validateKind: anObject ]		ifPass: [ 			anObject do: [ :object |				(self classes anySatisfy: [ :class | object species includesBehavior: class ])					ifFalse: [ MAKindError description: self signal: self kindErrorMessage ] ] ]! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MAToManyScalarRelationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ '1:m scalar Relation'! !!MAToManyScalarRelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitToManyScalarRelationDescription: self! !!MAToOneRelationDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAToOneRelationDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ '1:1 Relation'! !!MAToOneRelationDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitToOneRelationDescription: self! !!MAToOneRelationDescription methodsFor: 'ToMany compatibility' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isDefinitive	"I'm really not sure what this does, but we need to respond to it to get MAElementRow to work, which was copied over from ToMany"	^ false! !!MAToOneRelationDescription methodsFor: 'ToMany compatibility' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isOrdered	"See #isDefinitive comment"	^ false! !!MAToOneRelationDescription methodsFor: 'validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateKind: anObject	super validateKind: anObject.	(self classes anySatisfy: [ :class | anObject species includesBehavior: class ])		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultColumnLabels	^ OrderedCollection with: 'a' with: 'b' with: 'c'! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ MATableModel! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultRowLabels	^ OrderedCollection with: '1' with: '2' with: '3'! !!MATableDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MATableDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Table'! !!MATableDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitTableDescription: self! !!MATableDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!columnCount	^ self columnLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!columnLabels	^ self propertyAt: #columnLabels ifAbsent: [ self class defaultColumnLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!columnLabels: aCollection	self propertyAt: #columnLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!columnLabelsTextual	^ (MAStringDescription new toStringCollection: self columnLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!columnLabelsTextual: aString	self columnLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionColumnLabels	<magritteDescription>	^ MAMemoDescription new		accessor: #columnLabelsTextual;		label: 'Column Labels';		priority: 250;		yourself! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionDefault	<magritteDescription>	^ nil! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionRequired	<magritteDescription>	^ nil! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionRowLabels	<magritteDescription>	^ MAMemoDescription new		accessor: #rowLabelsTextual;		label: 'Row Labels';		priority: 250;		yourself! !!MATableDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rowCount	^ self rowLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rowLabels	^ self propertyAt: #rowLabels ifAbsent: [ self class defaultRowLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rowLabels: aCollection	self propertyAt: #rowLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rowLabelsTextual	^ (MAStringDescription new toStringCollection: self rowLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rowLabelsTextual: aString	self rowLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'private-validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateChildren: anObject 	anObject do: [ :row :value :each | self reference validate: each ].! !!MATableDescription methodsFor: 'private-validating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateCounts: anObject 	(anObject rowCount ~= self rowCount or: [ anObject columnCount ~= self columnCount ])		ifTrue: [ MAKindError description: self signal: self kindErrorMessage ].! !!MATableDescription methodsFor: 'validation-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validateSpecific: anObject	self		tryValidation: [ super validateSpecific: anObject ]		ifPass: [ 			self validateCounts: anObject.			self validateChildren: anObject ]! !!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Array! !!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultSeparators	^ ' ,;', (String with: Character cr with: Character lf with: Character tab)! !!MATokenDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MATokenDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Token'! !!MATokenDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitTokenDescription: self! !!MATokenDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionSeparators	<magritteDescription>	^ MAStringDescription new		accessor: #separators;		label: 'Separators';		priority: 250;		yourself! !!MATokenDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!separators	^ separators ifNil: [ separators := self class defaultSeparators ]! !!MATokenDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!separators: aString	"A string with the separator characters to split tokens, the first character is used as a default for printing."	separators := aString! !!MAMemoDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultLineCount	^ 3! !!MAMemoDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Memo'! !!MAMemoDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitMemoDescription: self! !!MAMemoDescription methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionLineCount	<magritteDescription>	^ MANumberDescription new		accessor: #lineCount;		label: 'Number of Lines';		priority: 400;		default: self class defaultLineCount;		beInteger;		min: 1;		yourself! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!lineCount	^ self propertyAt: #lineCount ifAbsent: [ self class defaultLineCount ]! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!lineCount: anInteger	self propertyAt: #lineCount put: anInteger! !!MAPasswordDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Password'! !!MAPasswordDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitPasswordDescription: self! !!MAPasswordDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isObfuscated: anObject	^ anObject notNil		and: [ anObject isString		and: [ anObject isEmpty not		and: [ anObject allSatisfy: [ :each | each = $* ] ] ] ]! !!MAPasswordDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSortable	^ false! !!MAPasswordDescription methodsFor: 'operators' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!obfuscated: anObject	^ String new: (self toString: anObject) size withAll: $*! !!MAStringDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ String! !!MAStringDescription class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAStringDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'String'! !!MAStringDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitStringDescription: self! !!MAStringDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSortable	^ true! !!MASymbolDescription class methodsFor: 'accessing-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultKind	^ Symbol! !!MASymbolDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'Symbol'! !!MASymbolDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitSymbolDescription: self! !!MAUrlDescription methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor	aVisitor visitUrlDescription: self! !!MACachedMemento class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MACachedMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!cache	^ cache! !!MACachedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!commit	super commit.	self push: self cache.	self reset! !!MACachedMemento methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hasChanged	"Answer ==true==, if the cached data is different to the data in the model."	^ self isDifferent: self cache to: self pullRaw! !!MACachedMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readUsing: aDescription	^ self cache at: aDescription! !!MACachedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reset	super reset.	self setCache: self pull! !!MACachedMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setCache: aDictionary	cache := aDictionary! !!MACachedMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject using: aDescription	self cache at: aDescription put: anObject! !!MACheckedMemento methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hasConflict	"Answer ==true==, if there is an edit conflict."	^ self hasChanged and: [ self isDifferent: self original to: self pullRaw ]! !!MACheckedMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!original	^ original! !!MACheckedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reset	super reset.	self setOriginal: self pullRaw! !!MACheckedMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setOriginal: aDictionary	original := aDictionary! !!MACheckedMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validate	self hasConflict		ifFalse: [ ^ super validate ].	self reset.	MAConflictError		description: self magritteDescription		signal: self magritteDescription conflictErrorMessage! !!MAMemento class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!model: aModel	^ self model: aModel description: aModel magritteDescription! !!MAMemento class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!model: aModel description: aDescription	^ self new		setModel: aModel;		setDescription: aDescription;		reset; yourself! !!MAMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!commit	"Commit the receiver into the model."! !!MAMemento methodsFor: 'reflective operations' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!doesNotUnderstand: aMessage  self model magritteDescription children detect: [ :desc | desc isMessage: aMessage selector ] ifFound: [ : desc | ^ self readUsing: desc ].  ^ super doesNotUnderstand: aMessage! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isDifferent: firstDictionary to: secondDictionary	| firstValue secondValue |	self magritteDescription do: [ :each |		(each isVisible and: [ each isReadOnly not ]) ifTrue: [			firstValue := firstDictionary at: each ifAbsent: [ nil ].			secondValue := secondDictionary at: each ifAbsent: [ nil ].			firstValue = secondValue ifFalse: [ ^ true ] ] ].	^ false! !!MAMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescription	^ description! !!MAMemento methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!model	^ model! !!MAMemento methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' model: '; print: self model! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!pull	"Utility method to pull the model into a dictionary mapping descriptions to values. nil values are replaced with the default ones of the model."	| result |	result := self pullRaw.	result keysAndValuesDo: [ :key :value |		value isNil			ifTrue: [ result at: key put: key default yourself ] ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!pullRaw	| result |	result := Dictionary new.	self magritteDescription do: [ :each |		result at: each put: (self model			readUsing: each) ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!push: aDictionary	"Utility method to push a dictionary mapping descriptions to values into the model."	aDictionary keysAndValuesDo: [ :key :value |		(key isVisible and: [ key isReadOnly not ]) 			ifTrue: [ self model write: value using: key ] ]! !!MAMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readUsing: aDescription	^ self subclassResponsibility! !!MAMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reset	"Reset the memento from the model."! !!MAMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setDescription: aDescription	description := aDescription! !!MAMemento methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setModel: aModel	model := aModel! !!MAMemento methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validate	"Check if the data in the receiver would be valid if committed. In case of problems an exception is raised."	self magritteDescription validate: self! !!MAStraightMemento class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAStraightMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readUsing: aDescription	^ (self model readUsing: aDescription)		ifNil: [ aDescription default ]! !!MAStraightMemento methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject using: aDescription	self model write: anObject using: aDescription! !!MAObject class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ true! !!MAObject class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!new	"Create a new instance of the receiving class and checks if it is concrete."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!MAObject class methodsFor: 'reflection' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!MAObject class methodsFor: 'reflection' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!withAllConcreteClassesDo: aBlock	self withAllSubclassesDo: [ :each |		each isAbstract ifFalse: [			aBlock value: each ] ]! !!MAObject methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject	"Answer whether the receiver and the argument represent the same object. This default implementation checks if the species of the compared objects are the same, so that superclasses might call super before performing their own check. Also redefine the message ==#hash== when redefining this message."	^ self species = anObject species! !!MAObject methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!acceptMagritte: aVisitor! !!MAObject methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!errorPropertyNotFound: aSelector 	MAPropertyError signal: 'Property ' , aSelector , ' not found.'! !!MAObject methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hasProperty: aKey	"Test if the property ==aKey== is defined within the receiver."	^ self properties includesKey: aKey! !!MAObject methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	"Answer a SmallInteger whose value is related to the receiver's identity. Also redefine the message ==#= == when redefining this message."	^ self species hash! !!MAObject methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	"This method is called whenever a shallow copy of the receiver is made. Redefine this method in subclasses to copy other fields as necessary. Never forget to call super, else class invariants might be violated."	super postCopy.	properties := properties copy! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!propertyAt: aKey	"Answer the value of the property ==aKey==, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, or the result of ==aBlock== if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	^ self properties at: aKey ifAbsentPut: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!propertyAt: aKey ifPresent: aBlock	"Lookup the property ==aKey==, if it is present, answer the value of evaluating ==aBlock== block with the value. Otherwise, answer ==nil==."	^ self properties at: aKey ifPresent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!propertyAt: aKey ifPresent: oneArgBlock ifAbsent: absentBlock	"Lookup ==aKey==, if it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."	^ self properties at: aKey ifPresent: oneArgBlock ifAbsent: absentBlock! !!MAObject methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue==."	^ self properties at: aKey put: aValue! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!containerPragma 	^ #magritteContainer! !!MAPragmaBuilder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!for: anObject	^ self new for: anObject! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescriptionExtensionPragma 	^ #magritteDescription:! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescriptionPragma 	^ #magritteDescription! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteSelectors	^ Array with: self containerPragma with: self magritteDescriptionExtensionPragma with: self magritteDescriptionPragma! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!build: anObject cache: cache	| container |	container := cache at: anObject put: (self buildContainer: anObject).		^ container		addAll: (self buildDescriptions: anObject);		yourself.! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildContainer: anObject	| containerPragmas containerPragma containerSelector extensionSelectors container |		containerPragmas := Pragma 		allNamed: self class containerPragma 		from: anObject class to: Object.			containerPragma := containerPragmas detect: [ :each | each method numArgs = 0 ].	containerSelector := containerPragma method selector.	extensionSelectors := (containerPragmas 		select: [ :each | each method numArgs = 1 ]) 		collect: [ :each | each method selector ]. 	MADynamicDescribedObject use: anObject during: [			container := anObject perform: containerSelector.		extensionSelectors do: [ :each | 			anObject perform: each with: container ] ].	^ container! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildDescriptions: anObject	| descriptionExtensions descriptionSelectors |		descriptionSelectors := self uniqueDescriptionSelectors: anObject.	descriptionExtensions := self descriptionExtensions: anObject.	^ (descriptionSelectors 		collect:  [ :each |			| description |			description := anObject perform: each.						description notNil ifTrue: [				descriptionExtensions at: each ifPresent: [ :extensions | 					extensions do: [ :extensionSelector | 						description := anObject perform: extensionSelector with: description ] ] ].			description ])		select: #notNil.! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionExtensions: anObject	| extensionPragmas |		extensionPragmas := Pragma		allNamed: self class magritteDescriptionExtensionPragma		from: anObject class to: Object.		^ extensionPragmas inject: Dictionary new into: [ :extensionSelectors :each | 		| extensionSelectorTarget |		extensionSelectorTarget := each arguments first.		(extensionSelectors at: extensionSelectorTarget ifAbsentPut: [ SortedCollection new ]) add: each method selector.		extensionSelectors ].! !!MAPragmaBuilder methodsFor: 'description building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!for: anObject	| cache |	cache := MADynamicDescriptionCache value.		MADynamicDescriptionCache use: cache during: [		^ cache at: anObject ifAbsentPut: [ self build: anObject cache: cache ] ]! !!MAPragmaBuilder methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uniqueDescriptionSelectors: anObject	| descriptionPragmas selectors |		descriptionPragmas := Pragma 		allNamed: self class magritteDescriptionPragma 		from: anObject class to: Object.			selectors := descriptionPragmas collect: [ :each | each method selector ].		^ Set withAll: selectors! !!MASortBlock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!accessor: anAccessor selector: aSelector	^ self basicNew initializeAccessor: anAccessor selector: aSelector! !!MASortBlock class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector: aSelector 	^ self 		accessor: MAIdentityAccessor new		selector: aSelector! !!MASortBlock methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fixTemps! !!MASortBlock methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initializeAccessor: anAccessor selector: aSelector	accessor := anAccessor asAccessor.	selector := aSelector! !!MASortBlock methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value: aFirstObject value: aSecondObject	^ (accessor read: aFirstObject)		perform: selector		with: (accessor read: aSecondObject)! !!MATableModel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rows: aRowCount columns: aColumnCount	^ self rows: aRowCount columns: aColumnCount contents: (Array new: aRowCount * aColumnCount)! !!MATableModel class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rows: aRowCount columns: aColumnCount contents: anArray	^ self new		setRowCount: aRowCount;		setColumnCount: aColumnCount;		setContents: anArray;		yourself! !!MATableModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= aTable	^ self species = aTable species		and: [ self rowCount = aTable rowCount		and: [ self columnCount = aTable columnCount		and: [ self contents = aTable contents ] ] ]! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!at: aRowIndex at: aColumnIndex	"Answer the contents of ==aRowIndex== and ==aColumnIndex==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!at: aRowIndex at: aColumnIndex put: aValue	"Set the contents of ==aRowIndex== and ==aColumnIndex==> to ==aValue==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex put: aValue! !!MATableModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!checkAt: aRowIndex at: aColumnIndex	(aRowIndex between: 1 and: self rowCount)		ifFalse: [ self error: 'Row subscript out of range.' ].	(aColumnIndex between: 1 and: self columnCount)		ifFalse: [ self error: 'Column subscript out of range.' ]! !!MATableModel methodsFor: 'enumeration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!collect: aBlock	| copy |	copy := self copyEmpty.	self do: [ :row :col :val |		copy			at: row at: col			put: (aBlock value: row value: col value: val) ].	^ copy! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!columnCount	"Answer the column count of the table."	^ columnCount! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents	"Answer the contents array of the receiver."	^ contents! !!MATableModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyEmpty	^ self class rows: self rowCount columns: self columnCount! !!MATableModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyRows: aRowCount columns: aColumnCount	| table |	table := self class rows: aRowCount columns: aColumnCount.	1 to: (self rowCount min: aRowCount) do: [ :row |		1 to: (self columnCount min: aColumnCount) do: [ :col |			table				uncheckedAt: row at: col				put: (self uncheckedAt: row at: col) ] ].	^ table! !!MATableModel methodsFor: 'enumeration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!do: aBlock	1 to: self rowCount do: [ :row |		1 to: self columnCount do: [ :col |			aBlock				value: row value: col				value: (self uncheckedAt: row at: col) ] ]! !!MATableModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ self contents hash! !!MATableModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!indexAt: aRowIndex at: aColumnIndex	^ (aRowIndex - 1) * self columnCount + aColumnIndex! !!MATableModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!pointAt: anIndex	^ Point x: (anIndex - 1 // self columnCount + 1) y: (anIndex - 1 \\ self columnCount + 1)! !!MATableModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	super postCopy.	self setContents: self contents copy! !!MATableModel methodsFor: 'operations' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reshapeRows: aRowCount columns: aColumnCount	"Change the size of the receiving table to ==aRowCount== times ==aColumnCount==, throwing away elements that are cut off and initializing empty cells with ==nil==."	self setContents: (self copyRows: aRowCount columns: aColumnCount) contents.	self setRowCount: aRowCount; setColumnCount: aColumnCount! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rowCount	"Answer the row count of the table."	^ rowCount! !!MATableModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setColumnCount: anInteger	columnCount := anInteger! !!MATableModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setContents: anArray	contents := anArray! !!MATableModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setRowCount: anInteger	rowCount := anInteger! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uncheckedAt: aRowIndex at: aColumnIndex	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex)! !!MATableModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uncheckedAt: aRowIndex at: aColumnIndex put: aValue	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex) put: aValue! !!MADescriptionHolder class methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionClasses	^ MAElementDescription withAllConcreteClasses asOrderedCollection! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupChoice	^ Set new		add: MABooleanDescription;		add: MASingleOptionDescription;		add: MAMultipleOptionDescription;		add: MAToOneRelationDescription;		add: MAToManyRelationDescription;		add: MAToManyScalarRelationDescription;				yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupMagnitude	^ Set new		add: MANumberDescription;		add: MADurationDescription;		add: MADateDescription;		add: MATimeDescription;		add: MATimeStampDescription;		add: MADateAndTimeDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupMisc	^ Set new		add: MAFileDescription;		add: MAClassDescription;		add: MATableDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupOf: aClass 	(self groupText includes: aClass)		ifTrue: [ ^ 'Text' ].	(self groupChoice includes: aClass)		ifTrue: [ ^ 'Choice' ].	(self groupMagnitude includes: aClass)		ifTrue: [ ^ 'Magnitude' ].	(self groupPick includes: aClass)		ifTrue: [ ^ 'Pick' ].	(self groupMisc includes: aClass)		ifTrue: [ ^ 'Miscellaneous' ].	^ 'Other'! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupPick	^ Set new		add: MAColorDescription;		add: MATokenDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!groupText	^ Set new		add: MAStringDescription;		add: MAMemoDescription;		add: MASymbolDescription;		add: MAPasswordDescription;		yourself! !!MADescriptionHolder methodsFor: 'acessing-magritte' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionValue	<magritteDescription>	^ MASingleOptionDescription new		reference: MAClassDescription new;		options: self class descriptionClasses;		selectorAccessor: 'contents';		groupBy: #grouping;		label: 'Type';		priority: 20;		yourself! !!MADescriptionHolder methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	super initialize.	self contents: self class descriptionClasses first! !!MAValueHolder class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!on: anObject	^ self new contents: anObject! !!MAValueHolder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents	^ contents! !!MAValueHolder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents: anObject	contents := anObject! !!MAComposedDescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setBuiltDescription: aDescription 	| builders |	builders := self target magritteDescription descriptionBuilders.	builtDescription := aDescription.	builders do: [ :each | builtDescription := each buildFrom: builtDescription target: target model: model ]! !!MAComposedDescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitContainer: aContainer	| builders |	builders := aContainer descriptionBuilders.	builtDescription := aContainer.	builders do: [ :each | builtDescription := each buildFrom: builtDescription target: self target model: self model ]! !!MAComposedDescriptionBuilder methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitRelationDescription: aDescription	| builders buildedReference relationValue |	builders := self target magritteDescription descriptionBuilders.	buildedReference := aDescription reference.	relationValue := (target readUsing: aDescription).	relationValue ifNotNil: [ 		builders do: [ :each | buildedReference := each buildFrom: buildedReference target: relationValue model: self model ].		aDescription reference: buildedReference].	super visitRelationDescription: aDescription! !!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildFrom: aDescription target: aTarget	^ self new 		target: aTarget;		visit: aDescription;		builtDescription! !!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildFrom: aDescription target: aTarget model: aModel	^ self new 		target: aTarget;		model: aModel;		visit: aDescription;		builtDescription! !!MADescriptionBuilder class methodsFor: 'accessing defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultPriority	^0! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildFrom: aDescription target: aTarget 	self target: aTarget; visit: aDescription.	^self builtDescription! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!builtDescription	^builtDescription! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!model	^model! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!model: aModel	model := aModel! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!priority	^ priority ifNil: [ ^self class defaultPriority ]! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!priority: anObject	priority := anObject! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setBuiltDescription: aDescription 	builtDescription := aDescription! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!target	^ target! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!target: anObject	target := anObject! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitContainer: aContainer	builtDescription := aContainer copy.	builtDescription removeAll.	aContainer do: [ :each |		self visit: each copy ]! !!MADescriptionBuilder methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDescription: anObject	builtDescription		ifNil: [ self setBuiltDescription: anObject]		ifNotNil: [ builtDescription add: anObject ]! !!MADescriptionFlattener methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addToBuildedDescription: aDescription for: aValue	"aValue is the intermediate value that can be processed by further expansion"	aDescription canExpand		ifTrue: [ self expandDescription: aDescription for: aValue ]		ifFalse: [ builtDescription add: aDescription ]! !!MADescriptionFlattener methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!expandDescription: aDescription for: aValue	aValue magritteDescription do: [ :each |		| val |		val := aValue readUsing: each.		each			addToAccessor: aDescription accessor;			priority: aDescription priority + (each priority / 1000).		aDescription groupExpandOnLabel			ifTrue: [ each group: aDescription label ]			ifFalse: [ each group: aDescription group ].		self addToBuildedDescription: each for: val ]! !!MADescriptionFlattener methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitToOneRelationDescription: aDescription	| sample |	aDescription canExpand ifFalse: [ ^ super visitToOneRelationDescription: aDescription ].	sample := self target isCollection		ifTrue: [			self target ifEmpty: [ ^ super visitToOneRelationDescription: aDescription ].			self target anyOne ]		ifFalse: [ self target ].	(sample readUsing: aDescription)		ifNil: [ super visitToOneRelationDescription: aDescription ]		ifNotNil: [ :value | self expandDescription: aDescription for: value ]! !!MAReader class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aStream description: aDescription	^ self new read: aStream description: aDescription! !!MAReader methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!error: aString 	MAReadError signal: aString! !!MAReader methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aStream description: aDescription	self		stream: aStream;		visit: aDescription.	^ self object! !!MAStringReader methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!nextMatchAll: aCollection on: aStream	"Tries to match ==aCollection== on ==aStream==. Answer ==true== if ==aCollection== was consumed, otherwise ==false==."	| position |	(aCollection isNil or: [ aCollection isEmpty ])		ifTrue: [ ^ false ].	position := aStream position.	aCollection do: [ :char |		(aStream atEnd or: [ aStream next ~= char ]) ifTrue: [			aStream position: position.			^ false ] ].	^ true! !!MAStringReader methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!read: aStream description: aDescription	(aStream atEnd or: [ self nextMatchAll: aDescription undefined on: aStream ])		ifTrue: [ ^ nil ].	^ super read: aStream description: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitBlockDescription: aDescription	self object: (Smalltalk compiler evaluate: self contents)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitBooleanDescription: aDescription	(aDescription trueString = self contents		or: [ aDescription trueStrings includes: self contents ])			ifTrue: [ ^ self object: true ].	(aDescription falseString = self contents		or: [ aDescription falseStrings includes: self contents ])			ifTrue: [ ^ self object: false ].	MAReadError signal! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitClassDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitColorDescription: aDescription	(self contents notEmpty and: [ self contents allSatisfy: [ :each | '#0123456789ABCDEFabcdef.' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind fromString: self contents)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitContainer: anObject	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDurationDescription: aDescription	| contents |	contents := self contents.	contents isEmpty		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents indexOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $.) > 1		ifTrue: [ MAReadError signal ].	(contents allSatisfy: [:each | '-0123456789.:' includes: each])		ifFalse: [ MAReadError signal ].	super visitDurationDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitElementDescription: aDescription	"This implementation can be very dangerous and might lead to a potential security hole (this is tested), since the default implementation of #readFrom: in Object evaluates the expression to find its value. Most subclasses like Number, Date, Time, ... override this implementation, but some others (like Boolean) do not."	self object: ([ aDescription kind readFrom: self stream ]		on: Error do: [ :err | MAReadError signal: err messageText ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitFileDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitMultipleOptionDescription: aDescription	self object: (Array streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			output nextPut: (aDescription reference				fromString: (self stream upTo: $,)).			self stream peek = Character space				ifTrue: [ self stream next ] ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitNumberDescription: aDescription	| isContentsValid |	isContentsValid := NumberParser isValidNumber: self contents.	isContentsValid ifFalse: [ MAReadError signal ].	super visitNumberDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitRelationDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitSingleOptionDescription: aDescription	aDescription propertyAt: #labels ifPresent: [ :labels |		labels keysAndValuesDo: [ :key :value |			(self nextMatchAll: value on: self stream)				ifTrue: [ ^ self object: key ] ] ].	self visit: aDescription reference! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitStringDescription: aDescription	self object: self contents! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitSymbolDescription: aDescription	self object: self contents asSymbol! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTableDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTimeDescription: aDescription	| string |	string := self contents.	(string notEmpty and: [ string allSatisfy: [ :each | '0123456789: apm' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind readFrom: string readStream)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTokenDescription: aDescription	| token |	self object: (aDescription kind streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			token := WriteStream on: String new.			[ self stream atEnd or: [ aDescription separators includes: self stream peek ] ]				whileFalse: [ token nextPut: self stream next ].			self stream atEnd 				ifFalse: [ self stream next ].			token contents isEmpty				ifFalse: [ output nextPut: (aDescription reference fromString: token contents) ] ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitUrlDescription: aDescription	self object: self contents asUrl! !!MAStreamingVisitor methodsFor: 'streaming' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents	^ self stream contents! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!object	^ object! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!object: anObject	object := anObject! !!MAStreamingVisitor methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!object: anObject during: aBlock	| previous |	previous := self object. self object: anObject.	aBlock ensure: [ self object: previous ]! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stream	^ stream! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stream: aStream	stream := aStream! !!MAStringWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultWriteStream	^ WriteStream on: String new! !!MAStringWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printObjectDescribedBy: aDescription	| string |	string := aDescription displayStringFor: self object.	self stream nextPutAll: string.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitBooleanDescription: aDescription	self stream nextPutAll: (self object		ifTrue: [ aDescription trueString ]		ifFalse: [ aDescription falseString ])! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitClassDescription: aDescription	self stream nextPutAll: self object name! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitColorDescription: aDescription	stream nextPut: $#.	stream nextPutAll: ((255 * self object red) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object green) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object blue) asInteger		printPaddedWith: $0 to: 2 base: 16)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitContainer: aDescription	aDescription do: [ :each |		each isVisible ifTrue: [			each stringWriter				write: (self object readUsing: each)				description: each to: stream.			^ self ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDateAndTimeDescription: aDescription	self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitElementDescription: aDescription 	self stream nextPutAll: self object greaseString! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitFileDescription: aDescription	self stream nextPutAll: self object filename! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitMultipleOptionDescription: aDescription	self object isEmpty		ifTrue: [ self stream nextPutAll: aDescription undefined ]		ifFalse: [			self object				do: [ :each | self stream nextPutAll: (aDescription labelForOption: each) ]				separatedBy: [ self stream nextPutAll: ', ' ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitSingleOptionDescription: aDescription	self stream nextPutAll: (aDescription labelForOption: self object)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitStringDescription: aDescription	self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTimeDescription: aDescription 		self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTimeStampDescription: aDescription	self stream print: self object asDate; space.	self stream print: self object asTime! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitToManyRelationDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: each magritteDescription ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitToOneRelationDescription: aDescription	self visit: self object magritteDescription! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTokenDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPut: aDescription separators first ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitUrlDescription: aMAUrlDescription 	self stream nextPutAll: self object asString! !!MAStringWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject description: aDescription to: aStream	anObject isNil 		ifTrue: [ aStream nextPutAll: aDescription undefined ]		ifFalse: [ super write: anObject description: aDescription to: aStream ].	^ aStream contents! !!MAWriter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject	^ self new write: anObject! !!MAWriter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject description: aDescription	^ self new write: anObject description: aDescription! !!MAWriter class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject description: aDescription to: aStream	^ self new write: anObject description: aDescription to: aStream! !!MAWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultWriteStream	self subclassResponsibility! !!MAWriter methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!error: aString 	MAWriteError signal: aString! !!MAWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject	^ self write: anObject description: anObject magritteDescription! !!MAWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject description: aDescription	^ self write: anObject description: aDescription to: self defaultWriteStream! !!MAWriter methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject description: aDescription to: aStream	self		object: anObject;		stream: aStream;		visit: aDescription.	^ self contents! !!MAValidatorVisitor class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!on: anObject description: aDescription	^ self new on: anObject description: aDescription! !!MAValidatorVisitor methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!object	"Answer the currently validated object."	^ object! !!MAValidatorVisitor methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!on: anObject description: aDescription	self use: anObject during: [ self visit: aDescription ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!use: anObject during: aBlock	| previous |	previous := object. object := anObject.	^ aBlock ensure: [ object := previous ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validate: anObject using: aDescription	aDescription validateRequired: anObject.	anObject isNil ifTrue: [ ^ self ].	aDescription		tryValidation: [ aDescription validateKind: anObject ]		ifPass: [ 			aDescription				validateSpecific: anObject;				validateConditions: anObject ]		! !!MAValidatorVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visit: aDescription	"Only visit objects that are visible and that can be changed."		(aDescription isVisible and: [ aDescription isReadOnly not ])		ifTrue: [ super visit: aDescription ].	! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitContainer: aDescription		super visitContainer: aDescription.	self object ifNotNil: [		aDescription do: [ :description |			self				use: (self object readUsing: description)				during: [ self visit: description ] ] ]! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDescription: aDescription	self validate: self object using: aDescription! !!MAVisitor class methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildVisitorHierarchyForClass: aClass selector: aBlock classified: aSelector	" self buildVisitorHierarchyForClass: MADescription selector: [ :class | 'visit' , (class name allButFirst: 2) , ':' ] classified: #'visiting-description' "	| visitSourceCode acceptSourceCode classesOwnedByMagritte |	classesOwnedByMagritte := aClass withAllSubclasses select: [ :class | class category beginsWith: 'Magritte' ].	classesOwnedByMagritte do: [ :class | | visitSelector |			visitSelector := aBlock value: class.			visitSourceCode := String streamContents: [ :stream |					stream nextPutAll: visitSelector; nextPutAll: ' anObject'; cr.					class = aClass ifFalse: [						stream tab; nextPutAll: 'self '; nextPutAll: (aBlock value: class superclass); nextPutAll: ' anObject' ] ].			self compile: visitSourceCode classified: aSelector.							acceptSourceCode := String streamContents: [ :stream |					stream nextPutAll: 'acceptMagritte: aVisitor'; cr.					stream tab; nextPutAll: 'aVisitor '; nextPutAll: visitSelector; nextPutAll: ' self' ].			class compile: acceptSourceCode classified: #visiting ]! !!MAVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visit: anObject	"Visit ==anObject== with the receiving visitor."	| errors |	errors := OrderedCollection new.	[		anObject acceptMagritte: self.	]		on: MAValidationError		do: [ :err | 			errors add: err. 			err resume ].			errors isEmpty ifFalse: [		MAMultipleErrors			description: anObject 			errors: errors			signal: anObject label ]! !!MAVisitor methodsFor: 'visiting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitAll: aCollection	"Visit all elements of ==aCollection== with the receiving visitor."	aCollection do: [ :each | self visit: each ]! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitBlockDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitBooleanDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitClassDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitColorDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitContainer: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDateAndTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDateDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDirectoryDescription: anObject	self visitFileDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitDurationDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitElementDescription: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitFileDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitMagnitudeDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitMemoDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitMultipleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitNumberDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitOptionDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitPasswordDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitPriorityContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitReferenceDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitRelationDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitReportContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitSingleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitStringDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitSymbolDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTableDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTableReference: anObject	^ self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTimeStampDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitToManyRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitToManyScalarRelationDescription: anObject	self visitToManyRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitToOneRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitTokenDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-descriptions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!visitUrlDescription: aMAUrlDescription 	self visitElementDescription: aMAUrlDescription! !!ManifestMagritteModel class methodsFor: 'code-critics' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!ruleRBBadMessageRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#Object #maLazyFrom: #false)) #'2019-03-23T09:33:42.523345-04:00') )! !!Class methodsFor: '*magritte-model-configuration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionContainer	"Return the default description container."	<magritteContainer>	^ MAPriorityContainer new		label: self label;		yourself! !!Class methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	"Answer a human-readable name of the receiving class. This implementation tries to be smart and return a nice label, unfortunately for a lot of classes this doesn't work well so subclasses might want to override this method and return soemthing more meaningfull to end-users."	| start input |	start := self name findFirst: [ :each | each isLowercase ].	input := (self name copyFrom: (1 max: start - 1) to: self name size)		readStream.	^ String streamContents: [ :stream |		[ input atEnd ] whileFalse: [			stream nextPut: input next.			(input atEnd or: [ input peek isLowercase ])				ifFalse: [ stream nextPut: Character space ] ] ]! !!MADynamicDescriptionCache class methodsFor: 'defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultValue	^ IdentityDictionary new! !!MADynamicVariable class methodsFor: 'defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultValue	^ nil! !!MADynamicVariable class methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!use: anObject during: aBlock	"Set the dynamic value of the receiver to anObject during the evaluation of aBlock."		^ aBlock on: self do: [ :notification | notification resume: anObject ]! !!MADynamicVariable class methodsFor: 'evaluating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value	"Answer the dynamic value of the receiver."		^ self signal! !!MADynamicVariable methodsFor: 'defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultAction	^ self class defaultValue! !!WriteStream methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maPrint: anMADescription for: anObject	anMADescription printFor: anObject on: self		"# Motivation: Printing ConvenienceTypically, `#printOn:` and friends have a lot of nil checks sprinkled around. Modern Pharo's tools are typically robust to printString errors, but you still get a not-very-helpful ""error printing"" message. Here comes Magritte to the rescue with `WriteStream >> #maPrint:for:`. Here's an example:```smalltalkprintOn: aStream	aStream 		maPrint: self descriptionDescription for: self;		nextPutAll: 'whatever'.```This reads the value and behaves gracefully if it is unset (by doing nothing). Notice that it also fits into the typical cascade without breaking it into multiple statements.Without this the options are not as nice...## Old (Typical) PatternNil checks everywhere...```smalltalkprintOn: aStream	description ifNotNil: [ :desc | aStream nextPutAll: desc ]	""repeated for each relevant field""```## Naive Magritte FixYou might just supply a reasonable default value for each description, like:```smalltalkdescriptionDescription	<magritteDescription>	^ MAStringDescription new		accessor: #description;		default: '';		yourself```which allows you to simplify to:```smalltalkprintOn: aStream	aStream nextPutAll: self description.```However, that requires cluttering descriptions with default values which may not fit the domain."! !!Dictionary methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!optionFor: anObject ifPresent: aBlock	self at: anObject ifPresent: aBlock! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteAllSubInstancesOf: aClass do: aBlock	"Evaluate the aBlock for all instances of aClass and all its subclasses."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteClassNamed: aString	"Return the class named aString, nil if the class can't be found."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteColorClass	"Return a Color class"		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteEvaluatorClassFor: aClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteTimeStampClass	"Return the platform's TimeStamp class. It is currently assumed that all platforms	have one, though this may not be correct and could require moving timestamp stuff	to its own package in order to resolve."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteUniqueObject	"Answer a random object, such as a UUID, that is extremely likely to	be unique over space and time."		self subclassResponsibility! !!Symbol methodsFor: '*magritte-model-converting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asAccessor	^ MASelectorAccessor selector: self! !!Symbol methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!optionFor: anObject ifPresent: aBlock	aBlock value: (anObject perform: self)! !!NumberParser class methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isValidNumber: aStringOrStream	| stream parser |	stream := aStringOrStream readStream.	parser := (Smalltalk at: #ExtendedNumberParser ifAbsent: [self]).	parser parse: stream onError: [ ^ false ].	^ stream atEnd! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asAccessor	^ MAChainAccessor accessors: self! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!moveDown: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := (first > 0 and: [ first < self size ])		ifTrue: [ first + 1 ]		ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!moveUp: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := first > 1 ifTrue: [ first - 1 ] ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!MAMultipleErrors class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!description: aDescription errors: aCollection signal: aString 	^ self new		setDescription: aDescription;		setCollection: aCollection;		signal: aString;		yourself! !!MAMultipleErrors methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!collection	^ collection! !!MAMultipleErrors methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printOn: aStream	self collection		do: [ :each | aStream print: each ]		separatedBy: [ aStream nextPut: Character cr ]! !!MAMultipleErrors methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setCollection: aCollection	collection := aCollection! !!MAValidationError class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!description: aDescription signal: aString 	^ self new		setDescription: aDescription;		signal: aString;		yourself! !!MAValidationError methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isResumable	^ true! !!MAValidationError methodsFor: 'printing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printOn: aStream	(self tag isDescription and: [ self tag label notNil ])		ifTrue: [ aStream nextPutAll: self tag label greaseString; nextPutAll: ': ' ].	aStream nextPutAll: self messageText greaseString ! !!MAValidationError methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setDescription: aDescription	self tag: aDescription! !!UndefinedObject methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asAccessor	^ MANullAccessor new! !!UndefinedObject methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ 'n/a'! !!UndefinedObject methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescription	^ MAContainer new! !!GRPackage class methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteModel	^ self new		name: 'Magritte-Model';		description: 'The Magritte metamodel.';		addDependency: 'Grease-Core';		url: #magritteUrl;		yourself! !!GRPackage methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteUrl	^ 'http://source.lukas-renggli.ch/magritte2'! !!Integer methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asFileSize	#( 'B' 'KB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB' )		inject: self		into: [ :value :each |			value < 1024				ifFalse: [ value // 1024 ]				ifTrue: [ ^ value asString , ' ' , each ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asMultilineString	^ String streamContents: [ :stream |		self			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream nextPut: Character cr ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyWithAll: aCollection	^ self copy		addAll: aCollection;		yourself! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyWithoutFirst: anObject	| done |	done := false.	^ self reject: [ :each |		(each = anObject			and: [ done not ])				and: [ done := true ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyWithoutFirstOccurrenceOf: anObject	| done |	done := false.	^ self reject: [ :each |		each = anObject			and: [ done not			and: [ done := true ] ] ]! !!Collection methodsFor: '*magritte-model-dynopt' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maAllOptionsFor: aDescription	^ aDescription prepareOptions: self copy! !!Collection methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maSelectMatching: aString 	^ self select: [ :e | e asString startsWith: aString ]! !!ArrayedCollection methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!copyWithAll: aCollection	^ (self species new: self size + aCollection size)		replaceFrom: 1 to: self size with: self startingAt: 1;		replaceFrom: self size + 1 to: self size + aCollection size with: aCollection startingAt: 1;		yourself! !!MAActionDescription class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maPragma	"Annotate constructor methods with this pragma to get picked up by Magritte; similar to #magritteDescription"	^ #magritteActionDescription! !!MAActionDescription methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!<= anObject	^ self priority <= anObject priority! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!action	^ action! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!action: aValuable	action := aValuable.! !!MAActionDescription methodsFor: 'converting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asGlmAction	| result |	result := GLMGenericAction new			action: [ :pres :receiver | 				self performOn: receiver.				self isMutator ifTrue: [ pres update ] ];			enabledCondition: self enableBlock;			help: self comment;			shortcut: self shortcut;			title: self label;			yourself.		"Glamour doesn't like setting a nil icon!!"	self icon ifNotNil: [ :i | result icon: i ].	^ result			! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!comment	^ comment! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!comment: aString	comment := aString.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!enableBlock	^ [ true ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!enableBlock: aBlock	"aBlock		- one argument (optional); the model object		- returns a boolean indicating whether the button should be enabled"		enableBlock := aBlock.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!icon	^ icon ifNotNil: [ self iconNamed: icon ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!icon: aSymbol	"Browse available via `Smalltalk ui icons`"	icon := aSymbol! !!MAActionDescription methodsFor: 'initialize-release' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	super initialize.	enableBlock := [ true ].! !!MAActionDescription methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isEnabled	^ enableBlock cull: model.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isMutator	^ isMutator ifNil: [ true ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isMutator: anObject	"Does the action I describe potentially change the object it acts on?"	isMutator := anObject! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label	^ label ifNil: [ action asString capitalized normalizeCamelCase ].! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!label: aString	label := aString.! !!MAActionDescription methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!performOn: aModel	action cull: aModel.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' label: '; print: self label.	aStream nextPutAll: ' comment: '; print: self comment! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!priority	^ priority ifNil: [ 0 ]! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!priority: anInteger 	priority := anInteger.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector	self 		deprecated: 'Renamed to #action because now accepts any valuable as an action (e.g. aBlock).'		on: '10/24/2017'		in: #Pharo61		transformWith: '`@receiver selector' 						-> '`@receiver action'.	^ self action! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selector: aValuable		self 		deprecated: 'Renamed to #action: because now accepts any valuable as an action (e.g. aBlock).'		on: '10/24/2017'		in: #Pharo61		transformWith: '`@receiver selector: `@arg' 						-> '`@receiver action: `@arg'.	self action: aValuable.! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!shortcut	^ shortcut! !!MAActionDescription methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!shortcut: anObject	shortcut := anObject! !!MADynamicOptions class methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!block: aBlock	^ self new			block: aBlock;			yourself.! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!block	^ block! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!block: aBlock	block := aBlock! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!detect: anObject	"Convert from a possibly-optimized object for entry-completion, to the object that should be saved"	^ self reader value: anObject! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!includes: anObject	^ includesBlock value: anObject! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!includesBlock	^ includesBlock! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!includesBlock: aBlock	includesBlock := aBlock! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maAllOptionsFor: anOptionDescription 	^ self! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maSelectMatching: aString 	^ self block value: aString! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reader	^ completionToObjectBlock ifNil: [ [ :obj | obj ] ]! !!MADynamicOptions methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reader: aBlock	completionToObjectBlock := aBlock! !!Object class methodsFor: '*magritte-model-description' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteTemplate	"Allow subclasses to have a prototype instance for creating a Magritte description (especially reference description)."	^self new! !!Object methodsFor: '*magritte-model-accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!basicMagritteDescription	^ MAPragmaBuilder for: self! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionContainer	"Return the default description container."	<magritteContainer>	^ MAPriorityContainer new		label: self class label;		yourself! !!Object methodsFor: '*magritte-model-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initializeMagritte	"Initializes the receiving object with the default values of its description."	self magritteDescription do: [ :each |		each isReadOnly			ifFalse: [ self write: each default using: each ] ]! !!Object methodsFor: '*magritte-model-testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isDescription	^ false! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSameAs: rhs	^ self isSameAs: rhs using: [ self magritteDescription ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isSameAs: rhs using: valuableDescription	"Use #isSameAs: unless you need to cache the description for efficiency.	CAUTION: this may not work if the description depends on the instance e.g. uses `self` in a block	(See comment below for more details)"	^ valuableDescription value allSatisfy: [ :desc |			| myVal rhsVal |			(desc accessor canRead: rhs)				ifFalse: [ false ]				ifTrue: [					myVal := desc read: self.					rhsVal := desc read: rhs.					({ nil. desc default } includesAll: { myVal. rhsVal })						ifTrue: [ true ]						ifFalse: [ myVal = rhsVal ] ] ].	"Motivation: We cache the description because profiling on a large dataset (120,000 records) showed about 66% of processing time was spent (re)building it"! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maHash	^ self maHashUsing: [ self magritteDescription ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maHashUsing: valuabledescription	"See isSameAs:using: comments"	^ valuabledescription value children 			inject: 0 hash 			into: [ :hash :desc | hash bitXor: (desc read: self) hash ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maLazyFrom: description	"Return the current value of a field as specified by its description		- NB: Only works with a selector accessor with matching inst var name e.g. (readSelector = instVarName = #myField). It could be extended to other cases if the need arises.		- The default value is cached if the description's #shouldCacheDefault property is true. An example when caching is necessary is for to-many relations because the user may modify the collection, which will then be thrown away if not cached	Usage: 		MyDomainObject>>#getter			^ self maLazyFrom: self descriptionName				MyDomainObject>>#descriptionName			^ MAStringDescription new					accessor: #name;					default: 'Alan';					yourself"	| currentValue defaultValue |	currentValue := self instVarNamed: description accessor readSelector.	currentValue ifNotNil: [ ^ currentValue ].	defaultValue := description default.	description shouldCacheDefault ifTrue: [ self write: defaultValue using: description ].	^ defaultValue.! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maPrintOn: aStream	"Print the current values of all described fields. Customize the printing of a field with the #maPrintString property, which should store a valuable with the value of the field as an optional argument"		self magritteDescription		do: [ :d | 			| value |			value := d read: self.			value ifNotNil: [ 				| stringValue |				stringValue := d 					propertyAt: #maPrintString					ifPresent: [ :map | map cull: value ]					ifAbsent: [ d toString: value ].				aStream nextPutAll: stringValue ] ]		separatedBy: [ aStream space ]! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maValidate	^ self magritteDescription validate: self! !!Object methodsFor: '*magritte-model-actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteActionDescriptions	^ self uniqueActionSelectors collect: [ :each | self perform: each ] as: SortedCollection! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteAllDescriptionsFor: aDescriptionSelector	"Experiment: What if our object has a field that can be thought of in different ways? For example, a messages field that can be filtered into #read, #unread, and #all. #descriptionMessages would be the actual description, and then there could be a #descriptionUnreadMessages and #descriptionReadMessages which are dcescriptions of the filtered collections. By annotating these alternate descriptions with <magritteAltFor: #descriptionMessages>, these could be e.g. displayed as tabs in a Magritte form"		^ OrderedCollection new			add: (self perform: aDescriptionSelector);			addAll: (self magritteAlternatesFor: aDescriptionSelector);			sort;			yourself! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteAlternatesFor: aDescriptionSelector	| altDescriptionMethods relevantDescMeths |	altDescriptionMethods := Pragma		allNamed: #magritteAltFor:		from: self class		to: Object.	relevantDescMeths := altDescriptionMethods select: [ :p | p arguments first = aDescriptionSelector ].	^ relevantDescMeths collect: [ :m | self perform: m method selector ]! !!Object methodsFor: '*magritte-model-builder' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescription	|basicDescription builders|	basicDescription := self basicMagritteDescription.	builders := self magritteDescriptionBuilders.	builders ifNotNil: [^builders buildFrom: basicDescription target: self].	^basicDescription! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescriptionBuilders	|builderPragmas container|	builderPragmas := Pragma allNamed: #magritteBuilder from: self class to: Object.	builderPragmas ifEmpty: [ ^nil ].	container := QCDescriptionBuilderContainer new.	builderPragmas do: [ :pragma |		|bld |		pragma method numArgs = 0 ifTrue: [ 			bld := self perform: pragma method selector.			bld ifNotNil: [ container add: bld ] ] ].	^container! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!mementoClass	"Return a class to be used to remember or cache the receiver, namely a memento object."	^ MACheckedMemento! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readUsing: aDescription	"Dispatch the read-access to the receiver using the accessor of aDescription."	^ aDescription accessor read: self! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uniqueActionSelectors	| descriptionPragmas selectors |		descriptionPragmas := Pragma 		allNamed: MAActionDescription maPragma		from: self class to: Object.			selectors := descriptionPragmas collect: [ :each | each method selector ].		^ Set withAll: selectors! !!Object methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!write: anObject using: aDescription	"Dispatch the write-access to the receiver of anObject using the accessor of aDescription."	aDescription accessor write: anObject to: self! !!BlockClosure methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!optionFor: anObject ifPresent: aBlock	aBlock value: (self cull: anObject)! !!String methodsFor: '*Magritte-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!matches: aString	aString isEmpty ifTrue: [ ^ true ].	^ (aString includesAnyOf: '*#')		ifTrue: [ aString match: self ]		ifFalse: [ self includesSubstring: aString caseSensitive: false ]! !!String methodsFor: '*magritte-model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!normalizeCamelCase	^ self class streamContents: [ :out |		self do: [ :e |			(e isUppercase and: [ out position > 0 ]) ifTrue: [ out nextPut: Character space ].			out nextPut: e ] ]! !"Magritte-Model"!!MAExternalFileModel commentStamp: '<historical>' prior: 0!I manage the file-data I represent on the file-system. From the programmer this looks the same as if the file would be in memory (==*MAMemoryFileModel*==), as it is transparently loaded and written out as necessary.I delegate my actual location on disk to MAFileDatabase (see class comment).!!MAFileDatabase commentStamp: '<historical>' prior: 0!I provide locations for external files.- The ==#baseDirectory== is the place where Magritte puts its file-database. Keep this value to nil to make it default to a subdirectory next to the Smalltalk image.- The ==#baseUrl== is a nice optimization to allow Apache (or any other Web Server) to directly serve the files. ==#baseUrl== is an absolute URL-prefix that is used to generate the path to the file. If you have specified one the file data does not go trough the image anymore, but instead is directly served trough the properly configured Web Server.The files are currently stored using the following scheme:=/files/9d/bsy8kyp45g0q7blphknk48zujap2wd/earthmap1k.jpg=1     2   3                            						  41. is the #baseDirectory as specified in the settings.2. Are 256 directories named '00' to 'ff' to avoid having thousands of files in the same directory. Unfortunately this leads to problems with the Squeak file primitives and some filesystems don't handle that well. This part is generated at random.3. This is a secure ID, similar to the Seaside session key. It is generated at random and provides a security system that even works through Apache (you have to disable directory listings of course): if you don't know the filename you can not access the file.4. This is the original filename. Subclasses might want to store other cached versions of the same file there, for example resized images, etc.!!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseDirectoryPath	" deprecated: use MAFileDatabase baseDirectoryPath instead "	^MAFileDatabase baseDirectory fullName! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseDirectoryPath: aString 	" deprecated, but still used by pier "	MAFileDatabase baseDirectory: aString! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseUrl	" deprecated: use MAFileDatabase baseDirectoryPath instead "	^ MAFileDatabase baseUrl! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseUrl: aString	" deprecated: use MAFileDatabase baseUrl instead "	^ MAFileDatabase baseUrl: aString! !!MAExternalFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!= anObject    ^ super = anObject and: [ self directory = anObject directory ]! !!MAExternalFileModel methodsFor: 'configuration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseUrl	^ self database baseUrl! !!MAExternalFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents	| stream |	^ self file exists		ifFalse: [ ByteArray new ]		ifTrue: [			stream := self readStream.			[ stream contents ]				ensure: [ stream close ] ]! !!MAExternalFileModel methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contents: aByteArray	| stream |	stream := self writeStream.	[ stream nextPutAll: aByteArray asByteArray ]		ensure: [ stream close ].	super contents: aByteArray! !!MAExternalFileModel methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!database	^ MAFileDatabase new.! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!directory	^ directory ifNil: [ directory := self database uniqueLocation ].! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!file	^(self directory / self filename) asFileReference! !!MAExternalFileModel methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!finalize	|  dir |	dir := self directory.	dir exists		ifTrue: [ dir deleteAll ].	[ (dir := dir parent) hasChildren ]		whileFalse: [ dir ensureDelete ].	super finalize.	location := nil! !!MAExternalFileModel methodsFor: 'comparing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!hash	^ super hash bitXor: self directory hash! !!MAExternalFileModel methodsFor: 'copying' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!postCopy	| previous |	super postCopy.	previous := self contents.	location := nil.	self contents: previous! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readStream	^ self file binaryReadStream ! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!writeStream	^ self file binaryWriteStream ! !!MorphicUIManager methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!chooseFile: windowTitle in: directoryString	| chooser |	chooser := FileDialogWindow newWithTheme: Smalltalk ui theme.	chooser		title: windowTitle;		selectDirectory: directoryString;		answerFileEntry.	^ chooser openModal answer		ifNotNil: [ :answer | answer asFileReference ]! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteAllSubInstancesOf: aClass do: aBlock	"Evaluate the aBlock for all instances of aClass and all its subclasses."	aClass allSubInstancesDo: aBlock! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteClassNamed: aString	"Return the class named aString, nil if the class can't be found."	^ Smalltalk classNamed: aString! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteColorClass	"Return a Color class"		^ Color! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteEvaluatorClassFor: aClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."		^ aClass compilerClass! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteTimeStampClass	"Return the platform's TimeStamp class. It is currently assumed that all platforms	have one, though this may not be correct and could require moving timestamp stuff	to its own package in order to resolve."		^ DateAndTime! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteTimeStampIfAbsent: absentBlock	"Return the TimeStamp class, or if the platform does not have a TimeStamp	return the result of evaluating absentBlock."		^ DateAndTime! !!GRPharoPlatform methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteUniqueObject	"Answer a random object, such as a UUID, that is extremely likely to	be unique over space and time."	^ ByteArray withAll: UUID new! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseDirectory	^ baseDirectory ifNil: [ FileLocator imageDirectory / 'files' ].! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseDirectory: aStringOrDirectory	"Defines where the files are stored. If this value is set to nil, it defaults to a subdirectory of of the current image-location."	baseDirectory := aStringOrDirectory asFileReference.! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseUrl	^ baseUrl! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseUrl: aString	"Defines the base-URL where the files are served from, when using an external web server. This setting is left to nil by default, causing the files to be served trough the image."	baseUrl := aString isNil ifFalse: [		aString last = $/			ifFalse: [ aString ]			ifTrue: [ aString copyUpToLast: $/ ] ]! !!MAFileDatabase class methodsFor: 'public' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!garbageCollect	"Remove obsolete files from the file-system that are not referenced from the image anymore. This method has to be called manually and is not intended to be portable."		| mark sweep |	mark := self allInstances		collect: [ :each | each directory ].	sweep := Array with: self baseDirectory.	self locationDefinition do: [ :definition |		sweep := sweep gather: [ :directory |			directory hasChildren ifFalse: [ directory delete ].			FileLocator imageDirectory directories select: [ :e | e basename size = definition first ] ] ].	sweep do: [ :directory |		(mark includes: directory) ifFalse: [ directory recursiveDelete ] ]! !!MAFileDatabase class methodsFor: 'public' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!locationDefinition	^ #( ( 2 '63450af8d9c2e17b' ) ( 30 'iaojv41bw67e0tud5m9rgplqfy8x3cs2kznh' ) )! !!MAFileDatabase methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseDirectory	^ self class baseDirectory.! !!MAFileDatabase methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!baseUrl	^ self class baseUrl.! !!MAFileDatabase methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!randomIdentifierName	| digits idLength allowedCharacters |	digits := $0 to: $9.	allowedCharacters := digits, Character alphabet.	idLength := 30.	^ String streamContents: [ :str |		idLength timesRepeat: [ str nextPut: allowedCharacters atRandom ] ].! !!MAFileDatabase methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!randomPartitionFolderName	"Returns a string between '00' to 'FF'"	| twoCharacterHexString |	twoCharacterHexString := 16rFF atRandom printStringBase: 16 length: 2 padded: true.	^ twoCharacterHexString asLowercase.! !!MAFileDatabase methodsFor: 'public' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!uniqueLocation	"Finds an unique path to be used and create the necessary sub directories."	| partition id result |	[		partition := self randomPartitionFolderName.		id := self randomIdentifierName.		result := self baseDirectory ensureCreateDirectory / partition / id.	] doWhileTrue: [ result exists ].		^ result ensureCreateDirectory.! !!MAFileSystem class methodsFor: 'paths' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!extensionFor: aString 	^ aString asFileReference extension.! !!MAFileSystem class methodsFor: 'entries' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fileSizeFor: filenameString 	^ filenameString asFileReference size! !!MAFileSystem class methodsFor: 'paths' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!fullNameFor: aString 	^ aString asFileReference fullName.! !!MAFileSystem class methodsFor: 'locations' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!imageDirectory	^ FileLocator imageDirectory.! !!MAFileSystem class methodsFor: 'mime types' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!mimeTypesForExtension: aString 	| types |	types := MIMEType forExtensionReturnMimeTypesOrNil: aString.	^ types ifNotNil: [ types collect: [ :e | e asString ] ].! !!GRPackage class methodsFor: '*Magritte-Pharo7-Model' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magrittePharoModel	^ self new		name: 'Magritte-Pharo-Model';		addDependency: 'Magritte-Model';		url: #magritteUrl;		yourself! !"Magritte-Pharo7-Model"!!MADescription class methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultReadonly	self 		deprecated: 'Use #defaultReadOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver defaultReadonly' 						-> '`@receiver defaultReadOnly'.	^ self defaultReadOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!beReadonly	self 		deprecated: 'Use #beReadOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver beReadonly' 						-> '`@receiver beReadOnly'.		^ self beReadOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isReadonly	self 		deprecated: 'Use #isReadOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver isReadonly' 						-> '`@receiver isReadOnly'.	^ self isReadOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readonly	self 		deprecated: 'Use #readOnly instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver readonly' 						-> '`@receiver readOnly'.		^ self readOnly! !!MADescription methodsFor: '*Magritte-Deprecated3dot7' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!readonly: aBoolean	self 		deprecated: 'Use #readOnly: instead.' 		on: '2020-01-23'		in: #'v3.7'		transformWith: '`@receiver readonly:' 						-> '`@receiver readOnly:'.		^ self readOnly: aBoolean! !!MASilentContainerMorph commentStamp: 'tg 5/6/2009 13:26' prior: 0!The only difference to the superclass is that on answer it does not delete the morph. This is useful when we want the morph to be embedded.!!MAElementRow class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addMorphFor: anObject of: aDescriptionMorph to: aMorph	| instance |	instance := self for: anObject of: aDescriptionMorph.	aMorph addMorphBack: instance.! !!MAElementRow class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!for: anObject of: aDescriptionMorph	^ self basicNew		object: anObject;		container: aDescriptionMorph;		initialize.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildButton: aSymbol	^ Smalltalk ui theme builder		newButtonFor: self		action: aSymbol		label: aSymbol capitalized		help: ''! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildCommands	| commands |	commands := self rectangleMorph		listDirection: #leftToRight;		cellInset: self cellInset;		yourself.	container magritteDescription isDefinitive ifFalse: [		commands			addMorphBack: (self buildButton: #edit);			addMorphBack: (self buildButton: #remove) ].	container magritteDescription isOrdered ifTrue: [		self shouldBeImplemented.		"commands			addCommandOn: self selector: #up: text: 'up';			addCommandOn: self selector: #down: text: 'down'" ].	^ commands! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!cellInset	^ 4@4.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!container: aDescriptionMorph	container := aDescriptionMorph! !!MAElementRow methodsFor: 'callbacks' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!edit	object asMagritteMorph		onAnswer: [ :result | self summary: result printString ];		addButtons;		addWindow;		openInWorld.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	super initialize.	self		borderWidth: 0;		color: Color transparent;		layoutPolicy: TableLayout new;		cellPositioning: #topLeft;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		listDirection: #leftToRight;		cellInset: self cellInset;		layoutInset: 0@2.	self		addMorphBack: (container magritteDescription displayStringFor: object) asMorph;		addMorphBack: self buildCommands! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!object: anObject	object := anObject! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rectangleMorph	^ MADescriptionMorph new rectangleMorph.! !!MAElementRow methodsFor: 'callbacks' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!remove	container remove: object.	self owner addMorph: container buildSelectList.	self delete.! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!summary: aString	submorphs first contents: aString! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value	^ self memento readUsing: self magritteDescription! !!MAElementRow methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value: anObject	self memento write: anObject using: self magritteDescription! !!MAContainerMorph methodsFor: 'decorating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addButtons	self addButtons: #( save cancel )! !!MAContainerMorph methodsFor: 'decorating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addButtons: anArray	morph := self rectangleMorph		addMorphBack: self morph;		addMorphBack: (self barMorph: anArray);		yourself! !!MAContainerMorph methodsFor: 'decorating' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addWindow	| scrollPane newMorph |	scrollPane := GeneralScrollPane new.	newMorph := self morph 		vResizing: #spaceFill;		hResizing: #spaceFill.	scrollPane changeScrollerTableLayout; scrollTarget: newMorph.		morph := self windowMorph		model: self;		vResizing: #shrinkWrap;		addMorph: (scrollPane layoutInset: 5 @ 5)			frame: (0 @ 0 corner: 1 @ 1);		yourself! !!MAContainerMorph methodsFor: 'answering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!answer: anObject	| didUserCancel |	self morph delete.		didUserCancel := anObject isNil.	didUserCancel | answerBlock isNil ifTrue: [ ^ self ].	answerBlock value: anObject.! !!MAContainerMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildChildren	^ Array streamContents: [ :stream |		self magritteDescription do: [ :each |			each isVisible ifTrue: [				stream nextPut: (each morphClass					memento: self memento					description: each					parent: self) ] ] ]! !!MAContainerMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphViewOn: aMorph	| toolbar |	aMorph		listDirection: #topToBottom;		cellInset: 3.	self children do: [ :each |		aMorph addMorphBack: each morph ].	toolbar := self rectangleMorph		listDirection: #leftToRight;		cellInset: 4@0;		layoutInset: 4@4;		yourself.	self model magritteActionButtons do: [ :e | toolbar addMorphBack: e ].	aMorph addMorphBack: toolbar.		! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!callInHand	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInHand; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!callInWorld	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInWorld; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!cancel	self reset; answer: nil! !!MAContainerMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!children	^ children! !!MAContainerMorph methodsFor: 'error handling' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!doesNotUnderstand: aMessage	"Forward callbacks from #addButtons: to the model if appropriate"	(self model respondsTo: aMessage selector)		ifTrue: [ self model perform: aMessage selector ]		ifFalse: [ super doesNotUnderstand: aMessage ].! !!MAContainerMorph methodsFor: 'answering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!onAnswer: aBlock	answerBlock := aBlock! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!openInHand	^ self morph openInHand! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!openInWindow	^ self		addWindow;		openInWorld.! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!openInWorld	^ self morph openInWorld! !!MAContainerMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!save	[ self validate ]		on: MAValidationError		do: [ :err | ^ self inform: err greaseString ].	self commit; answer: self model! !!MAContainerMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setChildren: aCollection	children := aCollection! !!MAContainerMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setDescription: aDescription	super setDescription: aDescription.	self setChildren: self buildChildren! !!MAContainerMorph methodsFor: 'morphic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!waitUntilClosed	[ self morph world notNil ]		whileTrue: [ self morph outermostWorldMorph doOneCycle ]! !!MASilentContainerMorph methodsFor: 'answering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!answer: anObject	answerBlock isNil		ifFalse: [ answerBlock value: anObject ].! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!memento: aMemento	^ self memento: aMemento description: aMemento magritteDescription! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!memento: aMemento description: aDescription	^ self memento: aMemento description: aDescription parent: nil! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!memento: aMemento description: aDescription parent: aComponent	^ self new		setMemento: aMemento;		setDescription: aDescription;		setParent: aComponent;		yourself! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!barMorph: anArray	| bar |	bar := self rectangleMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		listCentering: #center;		wrapCentering: #bottomRight;		cellInset: self defaultSpacerSize;		yourself.	anArray do: [ :selector |		bar addMorphBack: (self buttonMorph: selector) ].	^ bar! !!MADescriptionMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorph	| result |	result := self rectangleMorph		setBalloonText: self magritteDescription comment;		yourself.	self magritteDescription isReadOnly		ifTrue: [ self buildMorphViewOn: result ]		ifFalse: [ self buildMorphEditorOn: result ].	^ result! !!MADescriptionMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphEditorOn: aMorph	self buildMorphViewOn: aMorph! !!MADescriptionMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphViewOn: aMorph	self subclassResponsibility! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buttonMorph: aSelector	| button |	button := PluggableButtonMorph		on: self		getState: #buttonState		action: aSelector.	button		label: aSelector;		hResizing: #spaceFill;		shortcutCharacter: aSelector first.	^ button! !!MADescriptionMorph methodsFor: 'private-morphic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buttonState	^ true! !!MADescriptionMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!commit	self memento commit! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultBackgroundColor	^ self magritteDescription morphColor! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultSpacerSize	^ 5! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescription	^ description! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!memento	^ memento! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!model	^ self memento model! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!morph	^ morph ifNil: [ morph := self buildMorph ]! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!parent	^ parent! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!rectangleMorph	^ BorderedMorph new		borderWidth: 0;		color: Color transparent;		layoutPolicy: TableLayout new;		cellPositioning: #topLeft;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		yourself! !!MADescriptionMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reset	self memento reset! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!root	^ self parent isNil		ifTrue: [ self ]		ifFalse: [ self parent root ]! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setDescription: aDescription	description := aDescription! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setMemento: aMemento	memento := aMemento! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!setParent: aMorph	parent := aMorph! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringMorph	^ StringMorph new! !!MADescriptionMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!validate	"Flushes the cached state of some morphic elements (such as text-morphs) to the memento and then does the validation. I don't know of a better flush the morphic contents (happy flickering), probably morphic is just too limited to customize that easily or I am too dumb to find out."	self morph allMorphsDo: [ :each |		(each respondsTo: #accept)			ifTrue: [ each accept ] ].	self memento validate! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!windowMorph	^ SystemWindow labelled: self magritteDescription label! !!MACheckboxMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	^ Smalltalk ui theme		newCheckboxIn: nil		for: self		getSelected: #selected		setSelected: #selected:		getEnabled: #enabled		label: ''		help: self magritteDescription comment! !!MACheckboxMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!enabled	^ true! !!MACheckboxMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected	^ (self value ifNil: [ self magritteDescription default ]) ifNil: [ false ]! !!MACheckboxMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected: aBoolean	self value: aBoolean ! !!MADateMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	| model |	model := DateModel new		displayBlock: [ :e | description displayStringFor: e ];		date: self value;		whenDateChanged: [ :newDate | self value: newDate ];		yourself.	^ model buildWithSpec			yourself.! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphLabel	^ self stringMorph		contents: self magritteDescription label , ':';		width: 100;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphRequired	^ self stringMorph		contents: ' *';		color: Color red;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	^ self stringMorph		contents: self string;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphViewOn: aMorph	aMorph		layoutInset: 1 @ 1;		listDirection: #leftToRight;		addMorphBack: self buildMorphLabel;		addMorphBack: self buildMorphView.	self magritteDescription hasComment		ifTrue: [ aMorph setBalloonText: self magritteDescription comment ].	self magritteDescription isRequired		ifTrue: [ aMorph addMorphBack: self buildMorphRequired ]! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!string	^ self magritteDescription toString: self value! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!string: aString	| value |	value := self magritteDescription fromString: aString greaseString.	self value: value; changed: #string! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value	^ self memento readUsing: self magritteDescription! !!MAElementMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!value: anObject	self memento write: anObject using: self magritteDescription.	self changed: #value! !!MADirectoryMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!choose: titleString in: defaultDirectory	^ UIManager default chooseDirectory: titleString from: defaultDirectory.! !!MAFileMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	| button |	rectangleMorph := self rectangleMorph		listDirection: #leftToRight;		yourself.	button := self buttonMorph: #choose.	button		hResizing: #shrinkWrap.	rectangleMorph addMorphBack: button.	self value ifNotNil: [ self displayCurrentValue ].	^ rectangleMorph.! !!MAFileMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!choose	| file |	file := self		choose: 'Choose ', self magritteDescription label		in: self magritteDescription defaultDirectory. 	file ifNil: [ ^ self ].	self value: file.	self displayCurrentValue.! !!MAFileMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!choose: titleString in: defaultDirectory	^ UIManager default chooseFile: titleString in: defaultDirectory.	"We're using UIManager apparently for two reasons:		1. To maintain compatibility between Pharo and Squeak.		2. If this is a Seaside app, we may be headless	However, none of the Squeak/Pharo common UIManager API does what's needed e.g. to specify a starting folder. So I'm implementing the #chooseFile:in: for headful Pharo. At such time when someone tries in another scenario i.e. headless/Squeak, we have an entry point to implement support for those"! !!MAFileMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!currentValueMorph	| exists |	exists := rectangleMorph submorphs size = 2.	exists ifFalse: [ rectangleMorph addMorph: StringMorph new ].	^ rectangleMorph submorphs first.! !!MAFileMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!displayCurrentValue	| displayString |	displayString := description displayStringFor: self value.	self currentValueMorph contents: displayString.! !!MADropListMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView		| list |	list := DropListModel new.	list		items: self options;		displayBlock: [ :e | 			e				ifNil: [ '' ]				ifNotNil: [ self magritteDescription reference toString: e ] ];		setSelectedItem: self value;		whenSelectedItemChanged: [ :e | self value: e ].		^ list buildWithSpec.! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!options	^ self magritteDescription allOptions! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!strings	^ self options collect: [ :each | self magritteDescription reference toString: each ]! !!MAMultiSelectListMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorph			^ super buildMorph.! !!MAMultiSelectListMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	^ (PluggableListMorph on: self list: #strings primarySelection: #selected changePrimarySelection: #selected: listSelection: #selectionAt: changeListSelection: #selectionAt:put: menu: nil)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 1;		beMultipleSelection;		yourself! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected	^ selected ifNil: [ selected := 0 ]! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected: anInteger	selected := anInteger.	self changed: #selected! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selectionAt: anInteger	^ self value includes: (self options at: anInteger)! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selectionAt: anInteger put: aBoolean	| option |	option := self options at: anInteger.	self value: (aBoolean		ifTrue: [ self value copyWith: option ]		ifFalse: [ self value copyWithout: option ]).	self changed: #selected! !!MASingleSelectListMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	^ (PluggableListMorph on: self list: #strings selected: #selected changeSelected: #selected:)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 1;		yourself! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected	^ self options indexOf: self value! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected: anInteger	self value: (self options at: anInteger ifAbsent: [ nil ]).	self changed: #selected! !!MATokenCompletionMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	self flag: 'Obviously, the inline conditionals are horrifying. I think the nil check will go away if we set a default value'.	^ TokenCollectorMorph new			hResizing: #spaceFill;			vResizing: #rigid;			borderColor: #inset;			borderWidth: 1;			options: self options;			objects: (self magritteDescription isMultiple				ifTrue: [ self value copy ]				ifFalse: [ self value copy ifNotNil: [ :v | { v } ] ifNil: [ OrderedCollection new ] ]);			whenObjectsChanged: [ :e | 				self magritteDescription isMultiple					ifTrue: [ self value: e ]					ifFalse: [ self value: e first ] ];			factory: self magritteDescription initializer;			height: 150;			yourself! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!annotation	^ self string! !!MAMemoMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	"The selector #annotation should be #string instead, but we use this one and dispatch since this prevents morphic to draw a thin red border around changed fields. Stupid hack, really, but doesn't work otherwise."	| result lineSpacingFactor height |	result := RubPluggableTextMorph on: self text: #annotation accept: #string: readSelection: nil menu: nil.		"We want to set the height to honor the #lineCount from the description, but PluggableTextMorph doesn't seem to have an API to get the height of a hypothetical block of text e.g. 5 lines in the current font. So we work out an approximation as follows..."	lineSpacingFactor := 1.1. "This seems to account well for space between lines"	height := (description lineCount * result font height * lineSpacingFactor) + (result borderWidth * 2).		^ result			height: height;			hResizing: #spaceFill;			borderColor: #inset;			borderWidth: 1! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!enabled	^ self magritteDescription readOnly not! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected	^ (self value ifNil: [ self magritteDescription default ]) ifNil: [ false ]! !!MAMemoMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected: aBoolean	self value: aBoolean ! !!MAPasswordMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	^ super buildMorphView		font: (StrikeFont passwordFontSize: 12);		yourself! !!MATextMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	^ Smalltalk ui theme		newTextEntryIn: nil		for: self		get: #string		set: #string:		class: String		getEnabled: #enabled		help: self magritteDescription comment! !!MAOneToManyMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!add	self newRelation asMagritteMorph		onAnswer: [ :result |			result isNil ifFalse: [ self value: (self value copyWith: result) ].			self add: result ];		addButtons; 		addWindow;		openInWorld! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!add: anObject	| rowParent lastRowIndex newRow |	rowParent := morph submorphs second.	newRow := MAElementRow for: anObject of: self.	lastRowIndex := rowParent submorphs findLast: [ :e | e isKindOf: MAElementRow ].	lastRowIndex = 0 		ifTrue: [ rowParent addMorph: newRow ]		ifFalse: [ rowParent 			addMorph: newRow 			after: (rowParent submorphs at: lastRowIndex) ].! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	| table scrollPane |	table := self rectangleMorph		listDirection: #topToBottom;		yourself.	self value ifNotNil: [ :v | v do: [ :e | MAElementRow addMorphFor: e of: self to: table ] ].	self magritteDescription isDefinitive		ifFalse: [ self addSelectListTo: table ].	scrollPane := GeneralScrollPane new			changeScrollerTableLayout;			hResizing: #shrinkWrap;			yourself.	table computeBounds. "Layout so we know the height, which is needed below"	scrollPane		height: (table height min: 200);		scrollTarget: table.	^ scrollPane! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildSelectButton	^ Smalltalk ui theme builder		newButtonFor: self		action: #add		label: 'Add'		help: ''! !!MAOneToManyMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!remove: anObject	self value: (self value copyWithout: anObject).! !!MAExternalEditorMorph class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAExternalEditorMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!create	self newRelation asMagritteMorph		onAnswer: [ :result | result isNil ifFalse: [ self value: result ] ];		addButtons; 		addWindow;		openInWorld! !!MAExternalEditorMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!edit	self chooser: (self editorFor: self value)! !!MAExternalEditorMorph methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!renderButtonsOn: html	html submitButton on: #remove of: self.	html submitButton on: #edit of: self! !!MAExternalEditorMorph methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!renderViewerOn: html	html render: (self reference toString: self value)! !!MAInternalEditorMorph class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!isAbstract	^ false! !!MAInternalEditorMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildComponent	^ self value isNil ifFalse: [ 		(self magritteDescription reference asComponentOn: self value)			setParent: self;			yourself ]! !!MAInternalEditorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!children	^ Array with: self component! !!MAInternalEditorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!component	^ component ifNil: [ component := self buildComponent ]! !!MAInternalEditorMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!create	self value: self newRelation.	component := nil! !!MAInternalEditorMorph methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!renderViewerOn: html	html render: (self component		readOnly: self isReadOnly;		yourself)! !!MAOneToOneMorph methodsFor: 'as yet unclassified' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildMorphView	| table |	table := self rectangleMorph		listDirection: #topToBottom;		yourself.	self value		ifNotNil: [ MAElementRow addMorphFor: self value of: self to: table ]		ifNil: [ self addSelectListTo: table ].	^ table.! !!MAOneToOneMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildSelectButton	^ Smalltalk ui theme builder		newButtonFor: self		action: #create		label: 'Create'		help: ''! !!MAOneToOneMorph methodsFor: 'actions' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!create	self subclassResponsibility! !!MAOneToOneMorph methodsFor: 'removing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!remove: anObject	self value: nil! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addSelectListTo: aMorph	self classes ifEmpty: [ ^ self ].	aMorph addMorphBack: self buildSelectList! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildClassChooser	| items |	items := self classes collect: [ :e | e label ].	^ Smalltalk ui theme builder		newDropListFor: self		list: items		getSelected: #selectedIndex		setSelected: #selectedIndex:		help: ''! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildSelectButton	self subclassResponsibility! !!MARelationMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buildSelectList	| list |	list := self rectangleMorph		listDirection: #leftToRight;		yourself.	self classes size > 1 ifTrue: [ list addMorphBack: self buildClassChooser ].	^ list 			addMorphBack: self buildSelectButton;			yourself.! !!MARelationMorph methodsFor: 'accessing-dynamic' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!classes	^ self magritteDescription classes asSortedCollection.! !!MARelationMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!newRelation	| instance |	instance := self selected new.	self magritteDescription initializer value: instance.	^ instance! !!MARelationMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selected	^ self classes at: self selectedIndex! !!MARelationMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selectedIndex	^ selectedIndex ifNil: [ selectedIndex := 1 ]! !!MARelationMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!selectedIndex: anInteger	selectedIndex := anInteger.! !!MAToManyRelationDescription class methodsFor: '*magritte-morph-defaults' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MAOneToManyMorph! !!MAMultipleOptionDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MATokenCompletionMorph with: MAMultiSelectListMorph! !!MADirectoryDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MADirectoryMorph! !!MAFileDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MAFileMorph! !!MAElementDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MATextMorph! !!TokenCollectorMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!accept: text	| object |	object := self options		detect: [ :e | self stringDecoder value: e value: text asString ]		ifNone: [ factory value: text ].	self objects add: object.	whenObjectsChangedBlock ifNotNil: [ :blk | blk value: self objects ].	self refresh! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!entryCompletion	entryCompletion ifNotNil: [ ^ entryCompletion ].	^ entryCompletion := EntryCompletion new			dataSourceBlock: [ :currText | self options collect: self stringEncoder ];			filterBlock: [ :currApplicant :currText | currApplicant asString asUppercase includesSubstring: currText asString asUppercase ];			yourself.! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!factory	^ factory ifNil: [ factory := [ :text | text ] ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!factory: aBlock	factory := aBlock! !!TokenCollectorMorph methodsFor: 'initialization' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	| scrollPane |	super initialize.	self		changeTableLayout;		color: Color transparent.	self addMorphBack: self textInput.	scrollPane := GeneralScrollPane new			changeScrollerTableLayout;			hResizing: #spaceFill;			vResizing: #spaceFill;			scrollTarget: self tokenViewer;			yourself.	self addMorphBack: scrollPane! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!objects	^ objects ifNil: [ objects := OrderedCollection new ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!objects: aCollection	objects := aCollection.	self refresh! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!options	^ options! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!options: anObject	options := anObject! !!TokenCollectorMorph methodsFor: 'private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!refresh	self textInput model model text: ''.	self tokenViewer removeAllMorphs.	self objects do: [ :object |		self tokenViewer addMorphBack: (TokenMorph on: object) ]					! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringDecoder	"Test whether a string represents an object"	^ stringDecoder ifNil: [ stringDecoder := [ :obj :str | obj asString = str ] ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringDecoder: aBlock	stringDecoder := aBlock! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringEncoder	^ stringEncoder ifNil: [ stringEncoder := [ :obj | obj asString ] ]! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!stringEncoder: aBlock	"Turn data object into a string"	stringEncoder := aBlock! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!textInput	textInput ifNotNil: [ ^ textInput ].	textInput := TextInputFieldModel new		entryCompletion: self entryCompletion;		acceptBlock: [ :text | self accept: text ];		buildWithSpec.	textInput		vResizing: #rigid;		height: textInput textFont height + (textInput borderWidth * 2).	^ textInput! !!TokenCollectorMorph methodsFor: 'private-building' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!tokenViewer	tokenViewer ifNotNil: [ ^ tokenViewer ].	^ tokenViewer := Morph new		color:			Smalltalk ui theme backgroundColor;		changeTableLayout;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		listDirection: #leftToRight;		wrapDirection: #topToBottom;		cellInset: 5 @ 5;		yourself! !!TokenCollectorMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!whenObjectsChanged: aBlock	whenObjectsChangedBlock := aBlock! !!TokenMorph class methodsFor: 'instance creation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!on: anObject 	^ self new		object: anObject;		yourself! !!TokenMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!initialize	super initialize.	self roundedCorners: #(1 2 3 4).	"Seems to do nothing"	self		color:			Smalltalk ui theme buttonColor;		changeTableLayout;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 5 @ 1! !!TokenMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!object	^ object! !!TokenMorph methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!object: anObject	object := anObject.	self removeAllMorphs.	self addMorph: object asString asMorph! !!MABooleanDescription class methodsFor: '*magritte-morph-default' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MACheckboxMorph with: MASingleSelectListMorph! !!MADateDescription class methodsFor: '*magritte-morph-default' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MADateMorph.! !!GRPackage class methodsFor: '*magritte-morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteMorph	^ self new		name: 'Magritte-Morph';		description: 'Morphic integration for the Magritte metamodel.';		addDependency: 'Magritte-Model';		url: #magritteUrl;		yourself! !!MADescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClass	^ self defaultMorphClasses notEmpty		ifTrue: [ self defaultMorphClasses first ]! !!MADescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array new! !!MADescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphColor	^ Color white! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionMorphClass	<magritteDescription>	^ MASingleOptionDescription new		accessor: #morphClass;		label: 'Morph Class';		priority: 2000;		reference: MAClassDescription new;		options: self class defaultMorphClasses;		default: self class defaultMorphClass;		yourself! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!morphClass	^ self propertyAt: #morphClass ifAbsent: [ self class defaultMorphClass ]! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!morphClass: aClass	^ self propertyAt: #morphClass put: aClass! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!morphColor	^ self propertyAt: #morphColor ifAbsent: [ self class defaultMorphColor ]! !!MADescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!morphColor: aColor	^ self propertyAt: #morphColor put: aColor! !!MAContainer class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MAContainerMorph! !!MAContainer methodsFor: '*magritte-morph-converting' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asMorphOn: anObject	^ self morphClass		memento: (anObject mementoClass			model: anObject			description: self)! !!MASingleOptionDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array			with: MASingleSelectListMorph			with: MADropListMorph! !!MAMemoDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MAMemoMorph! !!MAActionDescription methodsFor: '*magritte-morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!buttonOn: anObject	^ Smalltalk ui theme builder		newButtonFor: self		getState: nil		action: #performOn:		arguments: {anObject}		getEnabled: #isEnabled		label: self label		help: comment! !!MAToOneRelationDescription class methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MAExternalEditorMorph with: MAInternalEditorMorph! !!MAPasswordDescription class methodsFor: '*magritte-morph-default' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMorphClasses	^ Array with: MAPasswordMorph! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!asMagritteMorph	^ self magritteDescription asMorphOn: self! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maEdit 	self maEditAnswering: [ :editedObj | ]! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maEditAnswering: aBlock 	self asMagritteMorph		addButtons;		addWindow;		onAnswer: aBlock;		openInWorld.! !!Object methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteActionButtons	^ self magritteActionDescriptions collect: [ :e | e buttonOn: self ].! !!MARelationDescription methodsFor: '*Magritte-Morph' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionClassesWithMorphic: description	<magritteDescription: #descriptionClasses>	^ description			morphClass: MATokenCompletionMorph;			yourself! !"Magritte-Morph"!!GLMCompositePresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritte	^ self custom: GLMMagrittePresentation new! !!MAStringDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!glmDefaultPresentation	^ #text! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!description: anObject	"convenience method for scripting"		magritteDescription := anObject! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteDescription	"By default the we read it via the #description selector"	^ magritteDescription ifNil: [ magritteDescription := #magritteDescription ]! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!onAnswer: aBlock	answerBlock := aBlock! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!reactOnAnswerFor: aValue	self update.	^ answerBlock glamourValue:		(aValue asGlamorousMultiValue, 		self asGlamorousMultiValue, 		self entity asGlamorousMultiValue)! !!GLMMagrittePresentation methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!renderGlamorouslyOn: aRenderer 	^ aRenderer renderMagrittePresentation: self! !!GLMPresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!glmAddActions	self dynamicActions: [ :pres | pres entity magritteActionDescriptions collect: #asGlmAction ]! !!GLMPresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!glmAddSelectionActions	self dynamicActionsOnSelection: [ :pres | 			pres selection magritteActionDescriptions collect: #asGlmAction ]! !!GLMMorphicRenderer methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!renderMagrittePresentation: aMagrittePresentation 	^ GLMMorphicMagritteRenderer render: aMagrittePresentation from: self! !!MAElementDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!glmCustomizePresentation: presentation for: domainObject	presentation hasTitle ifFalse: [ presentation title: self label ].	presentation hasTransformation ifFalse: [ presentation display: (self accessor read: domainObject) ].	presentation glmAddSelectionActions! !!MAElementDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!glmPresentation	| valuable |	valuable := self 		propertyAt: #glmPresentation		ifAbsent: [ self glmDefaultPresentation ].			valuable ifNil: [ ^ [ ] ].		^ [ :composite :context :subject |			| presentation |			presentation := valuable cull: composite cull: context.			self glmCustomizePresentation: presentation for: subject ]! !!MAElementDescription methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!glmPresentation: aValuable	"aValuable:		- Return value: a Glamour presentaion; FYI a default title, label, and selection actions will be added automatically by Magritte (see #glmCustomizePresentation:for:).		- Arguments (all optional) 				- composite - the container presentation				- context - e.g. an Inspector				- subject - the object being visualized		- To disable the presentation, make aValuable = `nil`"	self propertyAt: #glmPresentation put: aValuable! !!GLMListingPresentation methodsFor: '*Magritte-Glamour' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maAddSelectionActionsFor: aClass 		aClass magritteActionDescriptions do: [ :desc |		| glmAction actionBlock |		actionBlock := [ :list |			desc performOn: list selection.			desc isMutator ifTrue: [ list update ] ].		glmAction := GLMGenericAction new			action: actionBlock;			icon: desc icon;			title: desc label;			yourself.		desc shortcut ifNotNil: [ :sc | glmAction shortcut: sc key "assumes single key" ].		self addSelectionAction: glmAction ].! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!actOnPresentationUpdated: ann	scrollPane scrollTarget: (self magritteMorphFrom: ann presentation) ! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!magritteMorphFrom: aMagrittePresentation	| toShow description magritteMorph magritteDescriptionMorph |	toShow := aMagrittePresentation displayValue.	description := (aMagrittePresentation magritteDescription glamourValue: toShow) copy.	"Using MAContainerMorph can raise some problems, as it try to delete morphs after commiting. We don't want this behavior."	(description morphClass = MAContainerMorph)		ifTrue: [description morphClass: MASilentContainerMorph]. 	magritteDescriptionMorph :=  (description asMorphOn: toShow)		onAnswer: [ :value | aMagrittePresentation reactOnAnswerFor: value ].	magritteMorph := magritteDescriptionMorph		addButtons;		morph.	magritteMorph		hResizing: #spaceFill;		vResizing: #shrinkWrap;		layoutChanged.	^ magritteMorph! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!render: aMagrittePresentation	scrollPane := GeneralScrollPane new.	scrollPane changeScrollerTableLayout.	scrollPane scrollTarget: (self magritteMorphFrom: aMagrittePresentation).	scrollPane layoutFrame: (LayoutFrame identity bottomOffset: 25).	aMagrittePresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.	^ scrollPane! !"Magritte-Glamour"!!CompiledMethod class methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maNautilusMethodMenu: aBuilder	<nautilusGlobalMethodMenu>	| selectedMethod |	selectedMethod := aBuilder model selectedMethod.	(selectedMethod isNil or: [ selectedMethod maIsDescription not ]) ifTrue: [ ^ self ].		(aBuilder item: #'Show in GT Inspector')		action: [ selectedMethod maShowInGtInspector ];		order: 0;		enabled: [ :browser | true "Disable if already toggled, but we'll probably make two-way soon i.e. add disable" ];		help: 'Display in Inspector'.! !!CompiledMethod methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maIsDescription	^ self hasPragmaNamed: #magritteDescription! !!CompiledMethod methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maShowInGtInspector		| order |	order := UIManager default request: 'Presentation Order' initialAnswer: 1 asString.	order 		ifNotNil: [ order := order asNumber ]		ifNil: [ ^ self ].			self maShowInGtInspectorOrder: order! !!CompiledMethod methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maShowInGtInspectorOrder: aNumber		| nodes newPragmaNode |		nodes := self parseTree.	newPragmaNode := RBPragmaNode 		selector: #gtInspectorPresentationOrder: 		arguments: { RBLiteralValueNode value: aNumber }.	nodes pragmas add: newPragmaNode.	self methodClass compile: nodes newSource classified: self protocol! !!Symbol methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!cull: anObject cull: anotherObject 	^ self cull: anObject! !!Object methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!exampleGtInspectorReadOnlyMagritteIn: composite	"<gtInspectorPresentationOrder: 300>"	"A simple GT presentation. Disabled by default because we have one that shows the full editable form, but could be useful..."	| table |	table := composite table		title: 'Magritte';		display: [ self magritteDescription children collect: [ :desc |			desc label -> (desc toString: (desc accessor read: self)) ] ];		when: [ self magritteDescription notEmpty ];		column: 'Field' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!Object methodsFor: '*Magritte-GT' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!gtInspectorMagritteIn: composite	<gtInspectorPresentationOrder: 40>	composite magritte		title: 'Form';		display: [ self ];		when: [ self magritteDescription isContainer not or: [ self magritteDescription notEmpty ] ]! !!ClyTagInspectorExtensionCommand class methodsFor: 'testing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!canBeExecutedInContext: aToolContext	^ aToolContext selectedMethods allSatisfy: [ :e | e maIsDescription ]! !!ClyTagInspectorExtensionCommand class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMenuItemName	^'Show in GT-Inspector'! !!ClyTagInspectorExtensionCommand class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!methodContextMenuActivation	<classAnnotation>		^ CmdContextMenuActivation byItemOf: CmdExtraMenuGroup for: ClyMethod asCalypsoItemContext! !!ClyTagInspectorExtensionCommand methodsFor: 'execution' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!execute		methods do: [ :m | m  maShowInGtInspector ]! !"Magritte-GT"!!Class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maAddField	| fieldName |	fieldName := UIManager default request: 'Field name?'.	fieldName ifNil: [ ^ self ].	self maAddField: fieldName asSymbol! !!MAClyAddFieldCommand class methodsFor: 'activation' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!contextMenuActivation		<classAnnotation>		^ CmdContextMenuActivation byRootGroupItemFor: ClyClassContextOfFullBrowser! !!MAClyAddFieldCommand class methodsFor: 'accessing' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!defaultMenuItemName	^'Add Field (Magritte)'! !!MAClyAddFieldCommand methodsFor: 'execution' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!execute	targetClass maAddField: fieldName asSymbol! !!MAClyAddFieldCommand methodsFor: 'execution' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!prepareFullExecutionInContext: aToolContext	super prepareFullExecutionInContext: aToolContext.	fieldName := UIManager default request: 'Field name'.			fieldName isEmptyOrNil ifTrue: [ CmdCommandAborted signal ]! !!MAElementDescription methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!addTo: aClass as: aSymbol	| source formattedSource |	source := String streamContents: [ :s | 		s		nextPutAll: aSymbol; nextPutAll: 'Description'; cr;		nextPutAll: '<magritteDescription>'.		s 			nextPutAll: '^ ';			store: self ].	formattedSource := (RBParser parseMethod: source) formattedCode.	aClass compile: formattedSource classified: 'magritte-accessing'.	self accessor maSetUp: aClass for: self! !!MADeveloperMenus class methodsFor: 'nautilus menus' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maNautilusMethodMenu: aBuilder	<nautilusGlobalClassMenu>	| selection |	selection := aBuilder model selectedClass.	selection ifNil: [ ^ self ].		(aBuilder item: #'MA Add Field')		action: [ selection maAddField ];		order: 0;		help: 'Add Magritte Field'.! !!Object class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!instVarBoilerplateFromDescriptions	self new magritteDescription do: [ :e | 		| varName refactoring |		varName := e accessor readSelector.		(self hasInstVarNamed: varName) 			ifFalse: [ self addInstVarNamed: varName ].		refactoring := RBCreateAccessorsForVariableRefactoring					variable: varName					class: self					classVariable: false.		refactoring execute ]! !!Object class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maAddField: aSymbol	self maAddField: aSymbol with: [ :desc | ]! !!Object class methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maAddField: aSymbol with: customizationBlock	"If you don't need to customize the field description, you can use the simpler `#maAddField:`		Arguments:		aSymbol - field name		customizationBlock - takes description as argument; hook to modify it before it is serialized as a constructor method"	| elementTypes aClass |	elementTypes := MAElementDescription allSubclasses sort: [ :a :b | a name < b name ].	aClass := UIManager default 		chooseFrom: (elementTypes collect: #name)		values: elementTypes		lines: #()		message: 'Choose a type for the #', aSymbol, ' field'.			aClass ifNil: [ ^ self ]. "User cancelled"		aClass new 		accessor: aSymbol;		maEditAnswering: [ :desc | 			customizationBlock value: desc.			desc addTo: self as: aSymbol ]! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionBrowse	<magritteActionDescription>	^ MAActionDescription new			label: 'Browse Class';			action: #browse;			priority: 1100;			yourself! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionFuelOut	<magritteActionDescription>	^ MAActionDescription new				action: #fuelOut;			priority: 1200;			yourself! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!descriptionInspect	<magritteActionDescription>	^ MAActionDescription new			action: #inspect;			priority: 1000;			yourself! !!Object methodsFor: '*Magritte-Developer' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeVia: anAccessor inDescriptionOn: aStream	aStream		nextPutAll: anAccessor writeSelector , ' (';		store: self;		nextPutAll: ');';		cr! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maCompile: templateString asAccessor: aSymbol forinstVarNamed: variableName in: aClass 	(aClass canUnderstand: aSymbol) ifTrue: [ ^ self ].	aClass		compile: (templateString expandMacrosWith: aSymbol with: variableName)		classified: #accessing! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!maSetUp: aClass for: anMAElementDescription	| variableName needsInstVar defaultArgumentType setterArgumentName |	variableName := self readSelector.	needsInstVar := (aClass hasInstVarNamed: variableName) not.	needsInstVar ifTrue: [ aClass addInstVarNamed: variableName ].	self 		maCompile: '<1s><r><t>^ self maLazyFrom: self <2s>Description'		asAccessor: self readSelector 		forinstVarNamed: variableName 		in: aClass.	defaultArgumentType := anMAElementDescription class defaultKind.	setterArgumentName := (defaultArgumentType name first isVowel ifTrue: [ 'an' ] ifFalse: [ 'a' ]), defaultArgumentType name.	self 		maCompile: '<1s> ', setterArgumentName, '<r><t><2s> := ', setterArgumentName		asAccessor: self writeSelector		forinstVarNamed: variableName 		in: aClass.! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!store: anObject inDescriptionOn: aStream 	anObject storeVia: self inDescriptionOn: aStream.	! !!MASelectorAccessor methodsFor: '*Magritte-Developer-private' stamp: 'CompatibleUserName 8/25/2020 17:52:36'!storeVia: anAccessor inDescriptionOn: aStream 	| isSymmetrical |	isSymmetrical := self writeSelector = (self readSelector, ':') asSymbol.	aStream nextPutAll: 'accessor: '.	isSymmetrical 		ifTrue: [ aStream print: self selector ]		ifFalse: [ aStream nextPut: $(; store: self; nextPut: $) ].	aStream nextPut: $;; cr.! !"Magritte-Developer"!